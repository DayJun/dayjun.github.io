<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    
    <title>CVE-2012-0002分析 | DaJun的Blog | 脑袋空空</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="windows kernel">
    <link rel="shortcut icon" href="/img/girl.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.4.4">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	false,
            lv: JSON.parse('{"enable":true,"app_id":"ekgad1tINypClpAa8y0wrbvl-gzGzoHsz","app_key":"Qn93YchF3LXlS54tbXjzMvAI","icon":true}'),
            v: JSON.parse('{"enable":true,"appid":"ekgad1tINypClpAa8y0wrbvl-gzGzoHsz","appkey":"Qn93YchF3LXlS54tbXjzMvAI","notify":true,"verify":true,"placeholder":"想说什么...","avatar":"wavatar"}'),
            g: JSON.parse('{"enable":false,"lazy":true,"owner":"codefine","repo":"gitment","oauth":{"client_id":null,"client_secret":null},"perPage":10}'),
            d: JSON.parse('{"app_id":null}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
</head>


<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/girl.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">DaJun</h5>
          <a href="mailto:571986260@qq.com" title="571986260@qq.com" class="mail">
            
              <span>5</span>
            
              <span>7</span>
            
              <span>1</span>
            
              <span>9</span>
            
              <span>8</span>
            
              <span>6</span>
            
              <span>2</span>
            
              <span>6</span>
            
              <span>0</span>
            
              <span>@</span>
            
              <span>q</span>
            
              <span>q</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
        </hgroup>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                HOME
              </a>
            </li>
        
            <li class="">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                CATEGORIES
              </a>
            </li>
        
            <li class="">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                TAGS
              </a>
            </li>
        
            <li class="">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                ARCHIVES
              </a>
            </li>
        
            <li class="">
              <a href="/about"  >
                <i class="icon icon-lg icon-user"></i>
                ABOUT
              </a>
            </li>
        
            <li class="">
              <a href="/pwn-tips"  >
                <i class="icon icon-lg icon-info"></i>
                PWN TIPS
              </a>
            </li>
        
            <li class="">
              <a href="/todo"  >
                <i class="icon icon-lg icon-clock-o"></i>
                TODO
              </a>
            </li>
        
            <li class="">
              <a href="https://github.com/DayJun" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>CVE-2012-0002分析</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/dawn.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title">CVE-2012-0002分析</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-09-23T16:33:01.000Z" itemprop="datePublished" class="page-time">
  2020-09-24
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/CVE/">CVE</a></li></ul>

            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
    <article id="post-CVE-2012-0002分析"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">CVE-2012-0002分析</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-09-24 00:33:01" datetime="2020-09-23T16:33:01.000Z"  itemprop="datePublished">2020-09-24</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/CVE/">CVE</a></li></ul>



            
	<span id="/2020/09/24/CVE-2012-0002分析/" class="leancloud_visitors" data-flag-title="CVE-2012-0002分析" title="CVE-2012-0002分析">
		
			<i class="icon icon-eye"></i>
		
		<span class="leancloud-visitors-count"></span>
	</span>
 

            
    <span class="leancloud-comment">
        <i class="icon icon-comment-o"></i>
        <a href="/2020/09/24/CVE-2012-0002分析/#comment">
            <span class="valine-comment-count" data-xid="/2020/09/24/CVE-2012-0002分析/"></span>
        </a>
    </span>



            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <p>关于该漏洞，网上并没有什么详细的分析文章，大多所述都非常浅显，说root cause是HandleAttachUserReq函数处理错误，但是经过我的分析，发现他们的结论是错误的……</p>
<a id="more"></a>

<h1 id="1-overview"><a href="#1-overview" class="headerlink" title="1. overview"></a>1. overview</h1><p>CVE-2012-0002是windows下RDP协议的UAF漏洞，内核在处理T.125 ConnectMCSPDU包的<code>maxChannelIds</code>字段的时候，如果该字段被设置为小于等于5，则会触发该漏洞</p>
<h1 id="2-Analyze"><a href="#2-Analyze" class="headerlink" title="2. Analyze"></a>2. Analyze</h1><p>该报告所使用的环境为：windows 7 sp1 x86，rdpwd.sys的版本为：6.1.7601.17514，调试工具为：WinDbg Preview</p>
<h2 id="a-Poc"><a href="#a-Poc" class="headerlink" title="a. Poc"></a>a. Poc</h2><p>poc详见cve-2012-0002.py，于linux下使用python2运行</p>
<p>该poc只发送了一个 MCS Attach User Request PDU包，并设置了其中的<code>maxChannelIds</code>的值为5，正是该值引发了漏洞</p>
<h2 id="b-Root-Cause"><a href="#b-Root-Cause" class="headerlink" title="b. Root Cause"></a>b. Root Cause</h2><p>以下分析全部发生于<code>RDPWD</code>模块中</p>
<p><code>WDLIB_MCSIcaRawInput</code>函数处理了poc发送的包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> # ChildEBP RetAddr      Args to Child              </span><br><span class="line">00 a2951174 9066995a     967c7008 00000000 87b376a4 RDPWD!WDLIB_MCSIcaRawInput</span><br><span class="line">01 a2951198 99df3a31     87b74154 00000000 87b376a4 termdd!IcaRawInput+0x5a</span><br><span class="line">02 a29511d0 9066995a     87ba3300 00000000 87b376a4 tssecsrv!ScrRawInput+0x7b</span><br><span class="line">03 a29511f4 99de96a9     87b75e7c 00000000 87b376a4 termdd!IcaRawInput+0x5a</span><br><span class="line">04 a2951a30 90668671     87b37558 00000008 87b8b420 tdtcp!TdInputThread+0x34d</span><br><span class="line">05 a2951a4c 90668780     879ce008 00380173 87938a40 termdd!_IcaDriverThread+0x53</span><br><span class="line">06 a2951a74 9066922f     87b8b420 879389d0 8696a668 termdd!_IcaStartInputThread+0x6c</span><br><span class="line">07 a2951ab4 90666f9f     8696a668 879389d0 87938a40 termdd!IcaDeviceControlStack+0x629</span><br><span class="line">08 a2951ae4 90667173     879389d0 87938a40 87b46ba0 termdd!IcaDeviceControl+0x59</span><br><span class="line">09 a2951afc 83c48593     86a356a8 879389d0 879389d0 termdd!IcaDispatch+0x13f</span><br><span class="line">0a a2951b14 83e3c99f     87b46ba0 879389d0 87938a40 nt!IofCallDriver+0x63</span><br><span class="line">0b a2951b34 83e3fb71     86a356a8 87b46ba0 00000000 nt!IopSynchronousServiceTail+0x1f8</span><br><span class="line">0c a2951bd0 83e863f4     86a356a8 879389d0 00000000 nt!IopXxxControlFile+0x6aa</span><br><span class="line">0d a2951c04 83c4f1ea     000003dc 00000000 00000000 nt!NtDeviceIoControlFile+0x2a</span><br><span class="line">0e a2951c04 779070b4 (T) 000003dc 00000000 00000000 nt!KiFastCallEntry+0x12a</span><br><span class="line">0f 0236f968 77905864 (T) 6edc1948 000003dc 00000000 ntdll!KiFastSystemCallRet</span><br><span class="line">10 0236f96c 6edc1948     000003dc 00000000 00000000 ntdll!ZwDeviceIoControlFile+0xc</span><br><span class="line">WARNING: Frame IP not in any known module. Following frames may be wrong.</span><br><span class="line">11 0236f9a8 6edc25f1     000003dc 00380173 001cfd80 0x6edc1948</span><br><span class="line">12 0236f9d8 77a63c45     80000000 0236fa24 779237f5 0x6edc25f1</span><br><span class="line">13 0236f9e4 779237f5     001cfd78 75afa2ce 00000000 kernel32!BaseThreadInitThunk+0xe</span><br><span class="line">14 0236fa24 779237c8     6edc25ba 001cfd78 00000000 ntdll!__RtlUserThreadStart+0x70</span><br><span class="line">15 0236fa3c 00000000     6edc25ba 001cfd78 00000000 ntdll!_RtlUserThreadStart+0x1b</span><br></pre></td></tr></table></figure>

<p><code>maxChannelIds</code>字段，按照字面意思来看，意为最大通道ID值，或者最多通道ID数目，在poc的包中其被定义为5，那么就意味着只能创建5个通道</p>
<p><code>WDLIB_MCSIcaRawInput</code>函数会将包中的配置存入一个全局的结构体中，该结构体的部分字段：</p>
<table>
<thead>
<tr>
<th align="center">offset</th>
<th align="center">size</th>
<th align="center">origin value</th>
<th align="center">description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">34</td>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">已分配的ID数目</td>
</tr>
<tr>
<td align="center">A8</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">maxChannelIds</td>
</tr>
<tr>
<td align="center">C8</td>
<td align="center">4</td>
<td align="center">3ea</td>
<td align="center">ID值</td>
</tr>
</tbody></table>
<p><code>WDLIB_MCSIcaRawInput</code>中相调用了<code>MCSIcaRawInputWorker</code>之后，在<code>MCSIcaRawInputWorker</code>中会调用<code>RecognizeMCSFrame</code>来识别当前的包的类别，然后根据类别调用相应的处理函数</p>
<p>而在本次调用中，其对应的处理函数为<code>HandleAttachUserReq</code>，用来处理<code>Attach User Request</code></p>
<p>该函数再调用<code>MCSAttachUserRequest</code>函数，来对该请求做实际的处理</p>
<p><code>MCSAttachUserRequest</code>函数中，有<code>GetNewDynamicChannel</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">GetNewDynamicChannel</span><span class="params">(_DWORD *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( a1[<span class="number">0xD</span>] &gt;= a1[<span class="number">0x2A</span>] )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ++a1[<span class="number">0x32</span>] - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中0xD，0x2A，0x32分别对应偏移0x34，0xA8，0xC8</p>
<p>这就可以看出，该函数的作用实际上就是根据当前存在的Channel ID的数目来返回ID值，但是这里要注意一点，如果已分配的ID数目大于等于<code>maxChannelIds</code>，那么该函数就会返回0</p>
<p>就实际上来说，偏移0x34的位置是一个SList结构体，将其作为第一个参数调用<code>SListAppend</code>，如果函数执行成功，偏移0x34会增1</p>
<p>在这次的<code>MCSAttachUserRequest</code>中，偏移0x34增1，代表已经分出了一个通道ID</p>
<p>在之后的处理流程中，<code>WDSYS_Ioctl</code>的调用号为<code>382403</code>的时候，会调用<code>WDLIB_TShareConfConnect</code>函数，在该函数中便会一路执行到<code>NM_Connect</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> # ChildEBP RetAddr      Args to Child              </span><br><span class="line">00 a283797c 8cbbc26e     83247ae0 8684c134 832475ce RDPWD!NM_Connect</span><br><span class="line">01 a283799c 8cbba296     832477f4 8684c128 8684c134 RDPWD!SM_Connect+0x11d</span><br><span class="line">02 a28379d8 8cbbaa96     832471d8 8684c044 8684c128 RDPWD!WDWConnect+0x557</span><br><span class="line">03 a2837a14 8cbb5af2     832471d8 00000000 86a642fc RDPWD!WDLIB_TShareConfConnect+0xa0</span><br><span class="line">04 a2837a30 906686f5     832471d8 a2837a8c 86a642f8 RDPWD!WDSYS_Ioctl+0x79c</span><br><span class="line">05 a2837a4c 90668bad     87b9fc38 00000005 a2837a8c termdd!_IcaCallSd+0x37</span><br><span class="line">06 a2837a6c 90669109     86a642f0 00000005 a2837a8c termdd!_IcaCallStack+0x57</span><br><span class="line">07 a2837ab4 90666f9f     86a642f0 876f17e0 876f1850 termdd!IcaDeviceControlStack+0x503</span><br><span class="line">08 a2837ae4 90667173     876f17e0 876f1850 879a42b0 termdd!IcaDeviceControl+0x59</span><br><span class="line">09 a2837afc 83c48593     86a356a8 876f17e0 876f17e0 termdd!IcaDispatch+0x13f</span><br><span class="line">0a a2837b14 83e3c99f     879a42b0 876f17e0 876f1850 nt!IofCallDriver+0x63</span><br><span class="line">0b a2837b34 83e3fb71     86a356a8 879a42b0 00000000 nt!IopSynchronousServiceTail+0x1f8</span><br><span class="line">0c a2837bd0 83e863f4     86a356a8 876f17e0 00000000 nt!IopXxxControlFile+0x6aa</span><br><span class="line">0d a2837c04 83c4f1ea     00000860 00000000 00000000 nt!NtDeviceIoControlFile+0x2a</span><br><span class="line">0e a2837c04 779070b4 (T) 00000860 00000000 00000000 nt!KiFastCallEntry+0x12a</span><br><span class="line">0f 0147e4f8 77905864 (T) 6edc1948 00000860 00000000 ntdll!KiFastSystemCallRet</span><br><span class="line">10 0147e4fc 6edc1948     00000860 00000000 00000000 ntdll!ZwDeviceIoControlFile+0xc</span><br><span class="line">11 0147e538 6edc1bc6     00000860 00382403 03591928 ICAAPI!IcaIoControl+0x29</span><br><span class="line">12 0147e564 6edc1b76     00191330 00382403 03591928 ICAAPI!_IcaStackIoControlWorker+0x64</span><br><span class="line">13 0147e58c 6e9d50fe     00191330 00382403 03591928 ICAAPI!IcaStackIoControl+0x29</span><br><span class="line">14 0147e5c4 6e9d532c     00191330 00000000 0147e614 rdpwsx!TSrvInitWDConnectInfo+0x6a</span><br><span class="line">15 0147e5ec 6e9d53c1     035907d8 0147e614 00000000 rdpwsx!TSrvInitWD+0x23</span><br><span class="line">16 0147e60c 6e9d54b1     00000000 00000000 035907d8 rdpwsx!TSrvConfCreateResp+0x26</span><br><span class="line">17 0147e620 6e9d559d     035907d8 0147e680 00000000 rdpwsx!TSrvDoConnectResponse+0x10</span><br><span class="line">18 0147e64c 6e9d55fe     035907d8 0000028c 01f50c60 rdpwsx!TSrvDoConnect+0xb6</span><br><span class="line">19 0147e660 6e9d44da     0000028c 00191330 0147e680 rdpwsx!TSrvStackConnect+0x33</span><br><span class="line">1a 0147e684 6e9ffaf7     01f50c60 0000028c 00191330 rdpwsx!WsxIcaStackIoControl+0x19b</span><br><span class="line">1b 0147e6b0 6e9fac07     0000028c 00191330 0038004b rdpcorekmts!CWsx::StackIoControl+0x2f</span><br><span class="line">1c 0147e6d8 6edc1f28     011bf480 00191330 0038004b rdpcorekmts!CStack::staticExtensionIoControl+0x32</span><br><span class="line">1d 0147e708 6edc28f5     00191330 0038004b 00000000 ICAAPI!_IcaStackIoControl+0x33</span><br><span class="line">1e 0147ecf0 6edc3264     00191330 011b9c00 0147ed37 ICAAPI!_IcaStackWaitForIca+0x40</span><br><span class="line">1f 0147f2f8 6e9fe28e     0000028c 00191330 011b9bbc ICAAPI!IcaStackConnectionAccept+0x19d</span><br><span class="line">20 0147f5cc 6e9ff482     011b9bbc 011b9c00 011bdd64 rdpcorekmts!CStack::Accept+0x69</span><br><span class="line">21 0147f600 6ee30997     011b9b80 011afdb0 6ee31af0 rdpcorekmts!CKMRDPConnection::AcceptConnection+0xbf</span><br><span class="line">22 0147f770 6ee31ab7     0119ed94 0119ed88 0119ed98 termsrv!CConnectionEx::Accept+0x20e</span><br><span class="line">23 0147f784 6ee31def     011afdb0 00000000 00000000 termsrv!CListenerEx::TransferWorkItem+0x21</span><br><span class="line">24 0147f7a0 77a63c45     0119ed88 0147f7ec 779237f5 termsrv!CListenerEx::staticTransferWorkItem+0x1c</span><br><span class="line">25 0147f7ac 779237f5     0119ed88 76deaf06 00000000 kernel32!BaseThreadInitThunk+0xe</span><br><span class="line">26 0147f7ec 779237c8     6ee31dd3 0119ed88 00000000 ntdll!__RtlUserThreadStart+0x70</span><br><span class="line">27 0147f804 00000000     6ee31dd3 0119ed88 00000000 ntdll!_RtlUserThreadStart+0x1b</span><br></pre></td></tr></table></figure>

<p>该函数目测是建立连接的相关函数，在此函数中会依次按顺序调用这几个函数（只显示关键函数）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MCSAttachUserRequest</span><br><span class="line">MCSChannelJoinRequest</span><br><span class="line">MCSChannelJoinRequest</span><br></pre></td></tr></table></figure>

<p>在<code>MCSAttachUserRequest</code>函数中，在这段代码处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !v9 )</span><br><span class="line">  &#123;</span><br><span class="line">    v12 = WDLIBRT_MemAlloc(<span class="number">0x4C</span>u, <span class="number">0x636D5354</span>u); <span class="comment">// 分配</span></span><br><span class="line">    v9 = v12;</span><br><span class="line">    <span class="keyword">if</span> ( !v12 )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    v12[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>此时，偏移0x34所存的值是1，而且这里分配出来的内存就是UAF所发生在的堆块</p>
<p><code>MCSAttachUserRequest</code>和<code>MCSChannelJoinRequest</code>都对前面所述的结构体的偏移0x34调用了<code>SListAppend</code>，所以执行完这三个函数，偏移0x34所存的值加了3，现在为4</p>
<p>然后会进入一个循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( Src != (struct tagRNS_UD_CS_NET *)<span class="number">7</span> )	<span class="comment">//Src最开始是1</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( MCSChannelJoinRequest(*((_DWORD *)v3 + <span class="number">3</span>), <span class="number">0</span>, (<span class="keyword">int</span>)&amp;v24, (<span class="keyword">int</span>)&amp;a1 + <span class="number">3</span>) )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">    v17 = MCSGetChannelIDFromHandle(v24);</span><br><span class="line">    *(_WORD *)v25 = v17;</span><br><span class="line">  &#125;</span><br><span class="line">  Src = (struct tagRNS_UD_CS_NET *)((<span class="keyword">char</span> *)Src + <span class="number">1</span>);</span><br><span class="line">  v25 += <span class="number">36</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)Src &lt; *((_DWORD *)v3 + <span class="number">12</span>) );	<span class="comment">//最开始是3</span></span><br></pre></td></tr></table></figure>

<p>而在<code>MCSChannelJoinRequest</code>中，会按顺序调用这些函数（只显示关键函数）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GetNewDynamicChannel	//参数为上述结构体</span><br><span class="line">SListAppend				//参数为上述结构体偏移0x34</span><br></pre></td></tr></table></figure>

<p>那么这就意味着，每执行一次<code>MCSChannelJoinRequest</code>，偏移0x34所存的值就会加1</p>
<p>而这个循环只会执行两轮，第一轮执行完之后偏移0x34的值变为5，第二轮执行的时候，由于<code>GetNewDynamicChannel</code>中的if判断成立了，导致<code>GetNewDynamicChannel</code>返回了0</p>
<p>在<code>MCSChannelJoinRequest</code>中，<code>GetNewDynamicChannel</code>返回0会导致该函数直接返回15</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v5 = (PVOID)GetNewDynamicChannel(*v4);</span><br><span class="line">   <span class="keyword">if</span> ( !v5 )</span><br><span class="line">     <span class="keyword">return</span> <span class="number">15</span>;</span><br></pre></td></tr></table></figure>

<p>那么就会执行后面的<code>goto LABEL_5</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LABEL_5:</span><br><span class="line">      NMAbortConnect((struct tagNM_HANDLE_DATA *)v3);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_6;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">LABEL_6:</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">    WDLIBRT_MemFree(v4);</span><br><span class="line">  <span class="keyword">return</span> v23;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后执行<code>NMAbortConnect</code>函数，最关键的问题也出在这里</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">stdcall <span class="title">NMAbortConnect</span><span class="params">(struct tagNM_HANDLE_DATA *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">0x1C</span>) &amp; <span class="number">1</span> )</span><br><span class="line">    NMDetachUserReq(a1);</span><br><span class="line">  SM_OnConnected(*(_DWORD *)a1, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里取了<code>a1+0x1c</code>的一个字节，看其最后一位是不是1，如果是的话，则调用<code>NMDetachUserReq</code></p>
<p>而a<code>1+0x1c</code>的赋值就位于<code>NM_Connect</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*((_DWORD *)v3 + <span class="number">7</span>) |= <span class="number">1u</span>;			<span class="comment">//这里</span></span><br><span class="line">  *((_DWORD *)v3 + <span class="number">8</span>) = v15;</span><br><span class="line">  <span class="keyword">if</span> ( MCSChannelJoinRequest(*((_DWORD *)v3 + <span class="number">3</span>), <span class="number">0</span>, (<span class="keyword">int</span>)&amp;v24, (<span class="keyword">int</span>)&amp;a1 + <span class="number">3</span>) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">  v16 = MCSGetChannelIDFromHandle(v24);</span><br><span class="line">  *((_DWORD *)v3 + <span class="number">7</span>) |= <span class="number">4u</span>;		<span class="comment">//这里</span></span><br><span class="line">  *((_DWORD *)v3 + <span class="number">4</span>) = v16;</span><br><span class="line">  *((_DWORD *)v3 + <span class="number">5</span>) = v24;</span><br><span class="line">  <span class="keyword">if</span> ( MCSChannelJoinRequest(*((_DWORD *)v3 + <span class="number">3</span>), *((PVOID *)v3 + <span class="number">8</span>), (<span class="keyword">int</span>)&amp;v24, (<span class="keyword">int</span>)&amp;a1 + <span class="number">3</span>) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">  *((_DWORD *)v3 + <span class="number">7</span>) |= <span class="number">2u</span>;		<span class="comment">//这里</span></span><br></pre></td></tr></table></figure>

<p>所以执行<code>NMAbortConnect</code>的时候，其最后一个字节是1，因此这里会调用<code>NMDetachUserReq</code>函数，且该函数的参数为上文提到的UAF的堆块</p>
<p>进入执行流程后，会执行到这样的路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">NMDetachUserReq -&gt; MCSDetachUserRequest -&gt; DetachUser</span><br><span class="line"></span><br><span class="line"> # ChildEBP RetAddr      Args to Child              </span><br><span class="line">00 959218f4 8cbd5762     967ac3f0 909db960 00000003 RDPWD!DetachUser</span><br><span class="line">01 95921918 8cbc1a68     909db960 00000010 83247ae0 RDPWD!MCSDetachUserRequest+0x6a</span><br><span class="line">02 9592192c 8cbc1a9a     83247ae0 967ef8c0 9592197c RDPWD!NMDetachUserReq+0x14</span><br><span class="line">03 9592193c 8cbbc805     83247ae0 00000002 832477f4 RDPWD!NMAbortConnect+0x15</span><br><span class="line">04 9592197c 8cbbc26e     00247ae0 00000002 832475ce RDPWD!NM_Connect+0x68</span><br><span class="line">05 9592199c 8cbba296     832477f4 86b5ac38 86b5ac44 RDPWD!SM_Connect+0x11d</span><br><span class="line">06 959219d8 8cbbaa96     832471d8 86b5ab54 86b5ac38 RDPWD!WDWConnect+0x557</span><br><span class="line">07 95921a14 8cbb5af2     832471d8 00000000 86967674 RDPWD!WDLIB_TShareConfConnect+0xa0</span><br><span class="line">08 95921a30 906686f5     832471d8 95921a8c 86967670 RDPWD!WDSYS_Ioctl+0x79c</span><br><span class="line">09 95921a4c 90668bad     87c23928 00000005 95921a8c termdd!_IcaCallSd+0x37</span><br><span class="line">0a 95921a6c 90669109     86967668 00000005 95921a8c termdd!_IcaCallStack+0x57</span><br><span class="line">0b 95921ab4 90666f9f     86967668 863120a8 86312118 termdd!IcaDeviceControlStack+0x503</span><br><span class="line">0c 95921ae4 90667173     863120a8 86312118 87b9e288 termdd!IcaDeviceControl+0x59</span><br><span class="line">0d 95921afc 83c48593     86a356a8 863120a8 863120a8 termdd!IcaDispatch+0x13f</span><br><span class="line">0e 95921b14 83e3c99f     87b9e288 863120a8 86312118 nt!IofCallDriver+0x63</span><br><span class="line">0f 95921b34 83e3fb71     86a356a8 87b9e288 00000000 nt!IopSynchronousServiceTail+0x1f8</span><br><span class="line">10 95921bd0 83e863f4     86a356a8 863120a8 00000000 nt!IopXxxControlFile+0x6aa</span><br><span class="line">11 95921c04 83c4f1ea     00000670 00000000 00000000 nt!NtDeviceIoControlFile+0x2a</span><br><span class="line">12 95921c04 779070b4 (T) 00000670 00000000 00000000 nt!KiFastCallEntry+0x12a</span><br><span class="line">13 0188ebf0 77905864 (T) 6edc1948 00000670 00000000 ntdll!KiFastSystemCallRet</span><br><span class="line">14 0188ebf4 6edc1948     00000670 00000000 00000000 ntdll!ZwDeviceIoControlFile+0xc</span><br><span class="line">15 0188ec30 6edc1bc6     00000670 00382403 03591928 ICAAPI!IcaIoControl+0x29</span><br><span class="line">16 0188ec5c 6edc1b76     001910b0 00382403 03591928 ICAAPI!_IcaStackIoControlWorker+0x64</span><br><span class="line">17 0188ec84 6e9d50fe     001910b0 00382403 03591928 ICAAPI!IcaStackIoControl+0x29</span><br><span class="line">18 0188ecbc 6e9d532c     001910b0 00000000 0188ed0c rdpwsx!TSrvInitWDConnectInfo+0x6a</span><br><span class="line">19 0188ece4 6e9d53c1     035907d8 0188ed0c 00000000 rdpwsx!TSrvInitWD+0x23</span><br><span class="line">1a 0188ed04 6e9d54b1     00000000 00000000 035907d8 rdpwsx!TSrvConfCreateResp+0x26</span><br><span class="line">1b 0188ed18 6e9d559d     035907d8 0188ed78 00000000 rdpwsx!TSrvDoConnectResponse+0x10</span><br><span class="line">1c 0188ed44 6e9d55fe     035907d8 0000080c 01f50e60 rdpwsx!TSrvDoConnect+0xb6</span><br><span class="line">1d 0188ed58 6e9d44da     0000080c 001910b0 0188ed78 rdpwsx!TSrvStackConnect+0x33</span><br><span class="line">1e 0188ed7c 6e9ffaf7     01f50e60 0000080c 001910b0 rdpwsx!WsxIcaStackIoControl+0x19b</span><br><span class="line">1f 0188eda8 6e9fac07     0000080c 001910b0 0038004b rdpcorekmts!CWsx::StackIoControl+0x2f</span><br><span class="line">20 0188edd0 6edc1f28     011be760 001910b0 0038004b rdpcorekmts!CStack::staticExtensionIoControl+0x32</span><br><span class="line">21 0188ee00 6edc28f5     001910b0 0038004b 00000000 ICAAPI!_IcaStackIoControl+0x33</span><br><span class="line">22 0188f3e8 6edc3264     001910b0 011afe30 0188f42f ICAAPI!_IcaStackWaitForIca+0x40</span><br><span class="line">23 0188f9f0 6e9fe28e     0000080c 001910b0 011afdec ICAAPI!IcaStackConnectionAccept+0x19d</span><br><span class="line">24 0188fcc4 6e9ff482     011afdec 011afe30 011b3f94 rdpcorekmts!CStack::Accept+0x69</span><br><span class="line">25 0188fcf8 6ee30997     011afdb0 011b42f0 6ee31af0 rdpcorekmts!CKMRDPConnection::AcceptConnection+0xbf</span><br><span class="line">26 0188fe68 6ee31ab7     0119ed94 0119ed88 0119ed98 termsrv!CConnectionEx::Accept+0x20e</span><br><span class="line">27 0188fe7c 6ee31def     011b42f0 00000000 00000000 termsrv!CListenerEx::TransferWorkItem+0x21</span><br><span class="line">28 0188fe98 77a63c45     0119ed88 0188fee4 779237f5 termsrv!CListenerEx::staticTransferWorkItem+0x1c</span><br><span class="line">29 0188fea4 779237f5     0119ed88 7611a60e 00000000 kernel32!BaseThreadInitThunk+0xe</span><br><span class="line">2a 0188fee4 779237c8     6ee31dd3 0119ed88 00000000 ntdll!__RtlUserThreadStart+0x70</span><br><span class="line">2b 0188fefc 00000000     6ee31dd3 0119ed88 00000000 ntdll!_RtlUserThreadStart+0x1b</span><br></pre></td></tr></table></figure>

<p>而<code>DetachUser</code>的第二个参数就是上文提到的分配出来的出现UAF的堆块，在该函数的最后几句代码被释放：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LABEL_14:</span><br><span class="line">  SListRemove(a1 + <span class="number">13</span>, v5[<span class="number">3</span>], &amp;P);</span><br><span class="line">  <span class="keyword">if</span> ( P )</span><br><span class="line">  &#123;</span><br><span class="line">    SListDestroy((<span class="keyword">int</span>)P);</span><br><span class="line">    <span class="keyword">if</span> ( *((_BYTE *)P + <span class="number">56</span>) )</span><br><span class="line">      *((_BYTE *)P + <span class="number">57</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      WDLIBRT_MemFree(P);</span><br><span class="line">  &#125;</span><br><span class="line">  SListDestroy((<span class="keyword">int</span>)v11 + <span class="number">0x10</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *((_BYTE *)v11 + <span class="number">5</span>) )</span><br><span class="line">    *((_BYTE *)v11 + <span class="number">6</span>) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    WDLIBRT_MemFree(v11);                       <span class="comment">// 释放</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行完<code>NMDetachUserReq</code>之后，紧接着便会执行<code>SM_OnConnected</code>函数，进入执行流程后，会执行到这样的路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">SM_OnConnected -&gt; SM_Disconnect -&gt; NM_Disconnect</span><br><span class="line"></span><br><span class="line"># ChildEBP RetAddr      Args to Child              </span><br><span class="line">00 95921900 8cbbb99e     83247ae0 9592191c 8cbc1b67 RDPWD!NM_Disconnect</span><br><span class="line">01 9592190c 8cbc1b67     832477f4 83247ae0 9592193c RDPWD!SM_Disconnect+0x27</span><br><span class="line">02 9592191c 8cbc1aa8     832477f4 00000000 00000001 RDPWD!SM_OnConnected+0x70</span><br><span class="line">03 9592193c 8cbbc805     83247ae0 00000002 832477f4 RDPWD!NMAbortConnect+0x23</span><br><span class="line">04 9592197c 8cbbc26e     00247ae0 00000002 832475ce RDPWD!NM_Connect+0x68</span><br><span class="line">05 9592199c 8cbba296     832477f4 86b5ac38 86b5ac44 RDPWD!SM_Connect+0x11d</span><br><span class="line">06 959219d8 8cbbaa96     832471d8 86b5ab54 86b5ac38 RDPWD!WDWConnect+0x557</span><br><span class="line">07 95921a14 8cbb5af2     832471d8 00000000 86967674 RDPWD!WDLIB_TShareConfConnect+0xa0</span><br><span class="line">08 95921a30 906686f5     832471d8 95921a8c 86967670 RDPWD!WDSYS_Ioctl+0x79c</span><br><span class="line">09 95921a4c 90668bad     87c23928 00000005 95921a8c termdd!_IcaCallSd+0x37</span><br><span class="line">0a 95921a6c 90669109     86967668 00000005 95921a8c termdd!_IcaCallStack+0x57</span><br><span class="line">0b 95921ab4 90666f9f     86967668 863120a8 86312118 termdd!IcaDeviceControlStack+0x503</span><br><span class="line">0c 95921ae4 90667173     863120a8 86312118 87b9e288 termdd!IcaDeviceControl+0x59</span><br><span class="line">0d 95921afc 83c48593     86a356a8 863120a8 863120a8 termdd!IcaDispatch+0x13f</span><br><span class="line">0e 95921b14 83e3c99f     87b9e288 863120a8 86312118 nt!IofCallDriver+0x63</span><br><span class="line">0f 95921b34 83e3fb71     86a356a8 87b9e288 00000000 nt!IopSynchronousServiceTail+0x1f8</span><br><span class="line">10 95921bd0 83e863f4     86a356a8 863120a8 00000000 nt!IopXxxControlFile+0x6aa</span><br><span class="line">11 95921c04 83c4f1ea     00000670 00000000 00000000 nt!NtDeviceIoControlFile+0x2a</span><br><span class="line">12 95921c04 779070b4 (T) 00000670 00000000 00000000 nt!KiFastCallEntry+0x12a</span><br><span class="line">13 0188ebf0 77905864 (T) 6edc1948 00000670 00000000 ntdll!KiFastSystemCallRet</span><br><span class="line">14 0188ebf4 6edc1948     00000670 00000000 00000000 ntdll!ZwDeviceIoControlFile+0xc</span><br><span class="line">15 0188ec30 6edc1bc6     00000670 00382403 03591928 ICAAPI!IcaIoControl+0x29</span><br><span class="line">16 0188ec5c 6edc1b76     001910b0 00382403 03591928 ICAAPI!_IcaStackIoControlWorker+0x64</span><br><span class="line">17 0188ec84 6e9d50fe     001910b0 00382403 03591928 ICAAPI!IcaStackIoControl+0x29</span><br><span class="line">18 0188ecbc 6e9d532c     001910b0 00000000 0188ed0c rdpwsx!TSrvInitWDConnectInfo+0x6a</span><br><span class="line">19 0188ece4 6e9d53c1     035907d8 0188ed0c 00000000 rdpwsx!TSrvInitWD+0x23</span><br><span class="line">1a 0188ed04 6e9d54b1     00000000 00000000 035907d8 rdpwsx!TSrvConfCreateResp+0x26</span><br><span class="line">1b 0188ed18 6e9d559d     035907d8 0188ed78 00000000 rdpwsx!TSrvDoConnectResponse+0x10</span><br><span class="line">1c 0188ed44 6e9d55fe     035907d8 0000080c 01f50e60 rdpwsx!TSrvDoConnect+0xb6</span><br><span class="line">1d 0188ed58 6e9d44da     0000080c 001910b0 0188ed78 rdpwsx!TSrvStackConnect+0x33</span><br><span class="line">1e 0188ed7c 6e9ffaf7     01f50e60 0000080c 001910b0 rdpwsx!WsxIcaStackIoControl+0x19b</span><br><span class="line">1f 0188eda8 6e9fac07     0000080c 001910b0 0038004b rdpcorekmts!CWsx::StackIoControl+0x2f</span><br><span class="line">20 0188edd0 6edc1f28     011be760 001910b0 0038004b rdpcorekmts!CStack::staticExtensionIoControl+0x32</span><br><span class="line">21 0188ee00 6edc28f5     001910b0 0038004b 00000000 ICAAPI!_IcaStackIoControl+0x33</span><br><span class="line">22 0188f3e8 6edc3264     001910b0 011afe30 0188f42f ICAAPI!_IcaStackWaitForIca+0x40</span><br><span class="line">23 0188f9f0 6e9fe28e     0000080c 001910b0 011afdec ICAAPI!IcaStackConnectionAccept+0x19d</span><br><span class="line">24 0188fcc4 6e9ff482     011afdec 011afe30 011b3f94 rdpcorekmts!CStack::Accept+0x69</span><br><span class="line">25 0188fcf8 6ee30997     011afdb0 011b42f0 6ee31af0 rdpcorekmts!CKMRDPConnection::AcceptConnection+0xbf</span><br><span class="line">26 0188fe68 6ee31ab7     0119ed94 0119ed88 0119ed98 termsrv!CConnectionEx::Accept+0x20e</span><br><span class="line">27 0188fe7c 6ee31def     011b42f0 00000000 00000000 termsrv!CListenerEx::TransferWorkItem+0x21</span><br><span class="line">28 0188fe98 77a63c45     0119ed88 0188fee4 779237f5 termsrv!CListenerEx::staticTransferWorkItem+0x1c</span><br><span class="line">29 0188fea4 779237f5     0119ed88 7611a60e 00000000 kernel32!BaseThreadInitThunk+0xe</span><br><span class="line">2a 0188fee4 779237c8     6ee31dd3 0119ed88 00000000 ntdll!__RtlUserThreadStart+0x70</span><br><span class="line">2b 0188fefc 00000000     6ee31dd3 0119ed88 00000000 ntdll!_RtlUserThreadStart+0x1b</span><br></pre></td></tr></table></figure>

<p>而<code>NM_Disconnect</code>函数是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">NM_Disconnect</span><span class="params">(struct tagNM_HANDLE_DATA *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">0x1C</span>) &amp; <span class="number">1</span> )</span><br><span class="line">    result = NMDetachUserReq(a1);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同<code>NMAbortConnect</code>非常相似，而且，在这里<code>a1+0x1c</code>依旧是7，即这一个字节的最后一位依旧是1</p>
<p>从调用栈中我们可以看到，<code>NMAbortConnect</code>的第一个参数是<code>83247ae0</code>，同样也是它里面的<code>NMDetachUserReq</code>的参数，而<code>NM_Disconnect</code>的第一个参数也是<code>83247ae0</code>，其同样也是它里面的<code>NMDetachUserReq</code>的参数</p>
<p>这里其实就可以发现问题了：在<code>MCSAttachUserRequest</code>分配出来的堆，在<code>DetachUser</code>被释放了之后，又在<code>NM_Disconnect</code>被使用了！典型的UAF</p>
<p>再继续运行下去的话，便会崩溃(这里是另一次调试的结果，call stack中参数与上不符)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Access violation - code c0000005 (!!! second chance !!!)</span><br><span class="line">RDPWD!MCSDetachUserRequest+0x14:</span><br><span class="line">8cbd570c 8b11            mov     edx,dword ptr [ecx]</span><br><span class="line">0: kd&gt; kb</span><br><span class="line"> # ChildEBP RetAddr      Args to Child              </span><br><span class="line">00 8bff78e0 8cbc1a68     a2095f50 00000010 8326c624 RDPWD!MCSDetachUserRequest+0x14</span><br><span class="line">01 8bff78f4 8cbbc431     8326c910 8bff790c 8cbbb99e RDPWD!NMDetachUserReq+0x14</span><br><span class="line">02 8bff7900 8cbbb99e     8326c910 8bff791c 8cbc1b67 RDPWD!NM_Disconnect+0x16</span><br><span class="line">03 8bff790c 8cbc1b67     8326c624 8326c910 8bff793c RDPWD!SM_Disconnect+0x27</span><br><span class="line">04 8bff791c 8cbc1aa8     8326c624 00000000 00000001 RDPWD!SM_OnConnected+0x70</span><br><span class="line">05 8bff793c 8cbbc805     8326c910 00000002 8326c624 RDPWD!NMAbortConnect+0x23</span><br><span class="line">06 8bff797c 8cbbc26e     0026c910 00000002 8326c3fe RDPWD!NM_Connect+0x68</span><br><span class="line">07 8bff799c 8cbba296     8326c624 864b1128 864b1134 RDPWD!SM_Connect+0x11d</span><br><span class="line">08 8bff79d8 8cbbaa96     8326c008 864b1044 864b1128 RDPWD!WDWConnect+0x557</span><br><span class="line">09 8bff7a14 8cbb5af2     8326c008 00000000 86967674 RDPWD!WDLIB_TShareConfConnect+0xa0</span><br><span class="line">0a 8bff7a30 906686f5     8326c008 8bff7a8c 86967670 RDPWD!WDSYS_Ioctl+0x79c</span><br><span class="line">0b 8bff7a4c 90668bad     86b67f58 00000005 8bff7a8c termdd!_IcaCallSd+0x37</span><br><span class="line">0c 8bff7a6c 90669109     86967668 00000005 8bff7a8c termdd!_IcaCallStack+0x57</span><br><span class="line">0d 8bff7ab4 90666f9f     86967668 87b9f088 87b9f0f8 termdd!IcaDeviceControlStack+0x503</span><br><span class="line">0e 8bff7ae4 90667173     87b9f088 87b9f0f8 87bc8a00 termdd!IcaDeviceControl+0x59</span><br><span class="line">0f 8bff7afc 83c48593     86a356a8 87b9f088 87b9f088 termdd!IcaDispatch+0x13f</span><br><span class="line">10 8bff7b14 83e3c99f     87bc8a00 87b9f088 87b9f0f8 nt!IofCallDriver+0x63</span><br><span class="line">11 8bff7b34 83e3fb71     86a356a8 87bc8a00 00000000 nt!IopSynchronousServiceTail+0x1f8</span><br><span class="line">12 8bff7bd0 83e863f4     86a356a8 87b9f088 00000000 nt!IopXxxControlFile+0x6aa</span><br><span class="line">13 8bff7c04 83c4f1ea     000003e0 00000000 00000000 nt!NtDeviceIoControlFile+0x2a</span><br><span class="line">14 8bff7c04 779070b4 (T) 000003e0 00000000 00000000 nt!KiFastCallEntry+0x12a</span><br><span class="line">15 0193ea08 77905864 (T) 6edc1948 000003e0 00000000 ntdll!KiFastSystemCallRet</span><br><span class="line">16 0193ea0c 6edc1948     000003e0 00000000 00000000 ntdll!ZwDeviceIoControlFile+0xc</span><br><span class="line">17 0193ea48 6edc1bc6     000003e0 00382403 03591bb8 ICAAPI!IcaIoControl+0x29</span><br><span class="line">18 0193ea74 6edc1b76     001910b0 00382403 03591bb8 ICAAPI!_IcaStackIoControlWorker+0x64</span><br><span class="line">19 0193ea9c 6e9d50fe     001910b0 00382403 03591bb8 ICAAPI!IcaStackIoControl+0x29</span><br><span class="line">1a 0193ead4 6e9d532c     001910b0 00000000 0193eb24 rdpwsx!TSrvInitWDConnectInfo+0x6a</span><br><span class="line">1b 0193eafc 6e9d53c1     03591a88 0193eb24 00000000 rdpwsx!TSrvInitWD+0x23</span><br><span class="line">1c 0193eb1c 6e9d54b1     00000000 00000000 03591a88 rdpwsx!TSrvConfCreateResp+0x26</span><br><span class="line">1d 0193eb30 6e9d559d     03591a88 0193eb90 00000000 rdpwsx!TSrvDoConnectResponse+0x10</span><br><span class="line">1e 0193eb5c 6e9d55fe     03591a88 00000544 01f50e60 rdpwsx!TSrvDoConnect+0xb6</span><br><span class="line">1f 0193eb70 6e9d44da     00000544 001910b0 0193eb90 rdpwsx!TSrvStackConnect+0x33</span><br><span class="line">20 0193eb94 6e9ffaf7     01f50e60 00000544 001910b0 rdpwsx!WsxIcaStackIoControl+0x19b</span><br><span class="line">21 0193ebc0 6e9fac07     00000544 001910b0 0038004b rdpcorekmts!CWsx::StackIoControl+0x2f</span><br><span class="line">22 0193ebe8 6edc1f28     011bedf0 001910b0 0038004b rdpcorekmts!CStack::staticExtensionIoControl+0x32</span><br><span class="line">23 0193ec18 6edc28f5     001910b0 0038004b 00000000 ICAAPI!_IcaStackIoControl+0x33</span><br><span class="line">24 0193f200 6edc3264     001910b0 011b56c0 0193f247 ICAAPI!_IcaStackWaitForIca+0x40</span><br><span class="line">25 0193f808 6e9fe28e     00000544 001910b0 011b567c ICAAPI!IcaStackConnectionAccept+0x19d</span><br><span class="line">26 0193fadc 6e9ff482     011b567c 011b56c0 011b9824 rdpcorekmts!CStack::Accept+0x69</span><br><span class="line">27 0193fb10 6ee30997     011b5640 011afdb0 6ee31af0 rdpcorekmts!CKMRDPConnection::AcceptConnection+0xbf</span><br><span class="line">28 0193fc80 6ee31ab7     0119ed94 0119ed88 0119ed98 termsrv!CConnectionEx::Accept+0x20e</span><br><span class="line">29 0193fc94 6ee31def     011afdb0 00000000 00000000 termsrv!CListenerEx::TransferWorkItem+0x21</span><br><span class="line">2a 0193fcb0 77a63c45     0119ed88 0193fcfc 779237f5 termsrv!CListenerEx::staticTransferWorkItem+0x1c</span><br><span class="line">2b 0193fcbc 779237f5     0119ed88 760aa416 00000000 kernel32!BaseThreadInitThunk+0xe</span><br><span class="line">2c 0193fcfc 779237c8     6ee31dd3 0119ed88 00000000 ntdll!__RtlUserThreadStart+0x70</span><br><span class="line">2d 0193fd14 00000000     6ee31dd3 0119ed88 00000000 ntdll!_RtlUserThreadStart+0x1b</span><br></pre></td></tr></table></figure>

<p>崩溃的原因是，在<code>MCSDetachUserRequest</code>函数中，由于其第一个参数是已经被释放过的块，此时可能已经被其他地方分配出去了，结果就被填充了其他数据，这些数据并不符合原本该结构体的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> __<span class="function">stdcall <span class="title">MCSDetachUserRequest</span><span class="params">(<span class="keyword">int</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+8h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v1 = GetTotalLengthDeterminantEncodingSize(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( StackBufferAllocEx(*a1, *(_DWORD *)*a1, <span class="number">0</span>, v1 + <span class="number">13</span>, <span class="number">25</span>, (<span class="keyword">int</span>)&amp;v4) )	<span class="comment">//*a1不一定是合法地址，何况**a1呢</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">  CreateDetachUserInd(<span class="number">3</span>, <span class="number">1</span>, a1 + <span class="number">3</span>, *(_DWORD *)(v4 + <span class="number">16</span>));</span><br><span class="line">  *(_DWORD *)(v4 + <span class="number">20</span>) = GetTotalLengthDeterminantEncodingSize(<span class="number">1</span>) + <span class="number">13</span>;</span><br><span class="line">  <span class="keyword">if</span> ( SendOutBuf((_DWORD *)*a1, v4) &gt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> DetachUser((_DWORD *)*a1, a1, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="c-verify"><a href="#c-verify" class="headerlink" title="c. verify"></a>c. verify</h2><p>写如下windbg脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bp rdpwd!GetNewDynamicChannel+5 &quot;.printf \&quot;GetNewDynamicChannel(%x) \&quot;, poi(ebp+8);gc;&quot;</span><br><span class="line">bp rdpwd!GetNewDynamicChannel+21 &quot;.printf \&quot;index=%x maxChannelIds=%x ret_ID=%x\\n\&quot;, poi(poi(ebp+8)+34), poi(poi(ebp+8)+a8), eax;kb;.echo;gc;&quot;</span><br><span class="line">bp rdpwd!MCSAttachUserRequest+50 &quot;.printf \&quot;vul heap allocated: %x\\n\&quot;, eax;kb;.echo;gc;&quot;</span><br><span class="line">bp rdpwd!MCSDetachUserRequest+5 &quot;.printf \&quot;MCSDetachUserRequest(%x)\\n\&quot;, poi(ebp+8);kb;.echo;gc;&quot;</span><br><span class="line">bp rdpwd!NMAbortConnect+9 &quot;.printf \&quot;offset 0x1c is %x\\n\&quot;, by(esi+1c);kb;.echo;gc;&quot;</span><br><span class="line">bp rdpwd!DetachUser+10e &quot;.printf \&quot;heap %x freed!\\n\&quot;, eax;kb;.echo;gc;&quot;</span><br><span class="line">bp rdpwd!NM_Disconnect++b &quot;.printf \&quot;offset 0x1c is %x\\n\&quot;, by(ecx+1c);kb;.echo;gc;&quot;</span><br><span class="line">bp rdpwd!NM_Connect+63 &quot;.echo goto NMAbortConnect!;.echo;gc;&quot;</span><br></pre></td></tr></table></figure>

<h1 id="3-microsoft-official-patch"><a href="#3-microsoft-official-patch" class="headerlink" title="3. microsoft official patch"></a>3. microsoft official patch</h1><p>根据漏洞发生的原因，可以确定两个必须patch的位置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">stdcall <span class="title">NMAbortConnect</span><span class="params">(struct tagNM_HANDLE_DATA *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">0x1C</span>) &amp; <span class="number">1</span> )</span><br><span class="line">    NMDetachUserReq(a1);</span><br><span class="line">  SM_OnConnected(*(_DWORD *)a1, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">NM_Disconnect</span><span class="params">(struct tagNM_HANDLE_DATA *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">0x1C</span>) &amp; <span class="number">1</span> )</span><br><span class="line">    result = NMDetachUserReq(a1);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两处都检测了<code>a1+0x1C</code>的最后一位是否为1，但是<code>NMAbortConnect</code>中在执行完<code>NMDetachUserReq</code>释放了堆之后，没有将该位置0，导致<code>SM_OnConnected</code>中的<code>NM_Disconnect</code>又对相同的参数执行了一次<code>NMDetachUserReq</code>，这就是导致UAF发生的根本原因</p>
<p>因此，最应该的patch就是在这两个<code>NMDetachUserReq</code>之后加一个<code>*((_BYTE *)a1 + 0x1C) &amp;= 0xFFFFFFFE</code>来将该位置0</p>
<p>微软的官方patch总共有三处（上方为未patch，下方为patch）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">stdcall <span class="title">NMAbortConnect</span><span class="params">(struct tagNM_HANDLE_DATA *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">0x1C</span>) &amp; <span class="number">1</span> )</span><br><span class="line">    NMDetachUserReq(a1);</span><br><span class="line">  SM_OnConnected(*(_DWORD *)a1, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __<span class="function">stdcall <span class="title">NMAbortConnect</span><span class="params">(struct tagNM_HANDLE_DATA *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">28</span>) &amp; <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    NMDetachUserReq(a1);</span><br><span class="line">    *((_DWORD *)a1 + <span class="number">7</span>) &amp;= <span class="number">0xFFFFFFFE</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  SM_OnConnected(*(_DWORD *)a1, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">NM_Disconnect</span><span class="params">(struct tagNM_HANDLE_DATA *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">0x1C</span>) &amp; <span class="number">1</span> )</span><br><span class="line">    result = NMDetachUserReq(a1);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">NM_Disconnect</span><span class="params">(struct tagNM_HANDLE_DATA *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *((_BYTE *)a1 + <span class="number">0x1C</span>) &amp; <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = NMDetachUserReq(a1);</span><br><span class="line">    *((_DWORD *)a1 + <span class="number">7</span>) &amp;= <span class="number">0xFFFFFFFE</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> __<span class="function">thiscall <span class="title">HandleAttachUserReq</span><span class="params">(_BYTE *<span class="keyword">this</span>, <span class="keyword">int</span> a2, _DWORD *a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> ( SendOutBuf(v3, v10) &lt; <span class="number">0</span> )</span><br><span class="line">      SListRemove(v3 + <span class="number">0x1D</span>, P, &amp;P);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> __<span class="function">thiscall <span class="title">HandleAttachUserReq</span><span class="params">(_BYTE *<span class="keyword">this</span>, <span class="keyword">int</span> a2, _DWORD *a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> ( SendOutBuf(v3, v9) &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      SListRemove(v3 + <span class="number">29</span>, (<span class="keyword">int</span>)P, &amp;P);</span><br><span class="line">      <span class="keyword">if</span> ( P )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !*((_BYTE *)P + <span class="number">5</span>) )</span><br><span class="line">          WDLIBRT_MemFree(P);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前两处patch不多说，但是第三处patch似乎并没有什么用处，至少对于这个漏洞是如此</p>

        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-09-23T16:40:30.198Z" itemprop="dateUpdated">2020-09-24 00:40:30</time>
</span><br>


        
        转载注明出处，原文地址：<a href="/2020/09/24/CVE-2012-0002分析/" target="_blank" rel="external">http://dayjun.top/2020/09/24/CVE-2012-0002分析/</a>
        
    </div>
    <footer>
        <a href="http://dayjun.top">
            <img src="/img/girl.jpg" alt="DaJun">
            DaJun
        </a>
    </footer>
</blockquote>

        
        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/windows-kernel/">windows kernel</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://dayjun.top/2020/09/24/CVE-2012-0002分析/&title=《CVE-2012-0002分析》 — DaJun的Blog&pic=http://dayjun.top/img/girl.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://dayjun.top/2020/09/24/CVE-2012-0002分析/&title=《CVE-2012-0002分析》 — DaJun的Blog&source=关于该漏洞，网上并没有什么详细的分析文章，大多所述都非常浅显，说root cause是HandleAttachUserReq函数处理错误，但是经过我的分析..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            
    <div id="comment"></div>



        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2021/02/21/年度总结及来年计划/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">年度总结及来年计划</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2020/07/17/windbg插件编写摸索/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">windbg插件编写摸索</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-overview"><span class="post-toc-number">1.</span> <span class="post-toc-text">1. overview</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-Analyze"><span class="post-toc-number">2.</span> <span class="post-toc-text">2. Analyze</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#a-Poc"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">a. Poc</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#b-Root-Cause"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">b. Root Cause</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#c-verify"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">c. verify</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-microsoft-official-patch"><span class="post-toc-number">3.</span> <span class="post-toc-text">3. microsoft official patch</span></a></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    
</article>


</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://3nd.xyz/" target="_blank">3ND</a>
    </span>
    
    <span class="blogroll-item">
        <a href="http://blog.douluodalu.wang/" target="_blank">PwmHt</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
        <p>
            <span>
                DaJun &copy; 2019 - 2021
            </span>
        		
           	
           	<span>
           		<a href="http://www.beian.miit.gov.cn" target="_blank">苏ICP备19059861号</a>
           	</span>
           	
            
            
            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            
            
            

            
                
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

            
        </p>
    </div>
</footer>

    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://dayjun.top/2020/09/24/CVE-2012-0002分析/&title=《CVE-2012-0002分析》 — DaJun的Blog&pic=http://dayjun.top/img/girl.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://dayjun.top/2020/09/24/CVE-2012-0002分析/&title=《CVE-2012-0002分析》 — DaJun的Blog&source=关于该漏洞，网上并没有什么详细的分析文章，大多所述都非常浅显，说root cause是HandleAttachUserReq函数处理错误，但是经过我的分析..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLElEQVR42u3ay47jIBAF0P7/n/ZsR+oxfS/QIwUOq8hxYo4XJerx9RWv5681/vb7Pd+vv31+u7JtYWBgfCzjGa7xPTljfOf48/jpGBgY9zDeIlgeIpOtJJjxs16vY2BgYMRbXwnNyXMxMDAwdgXcJMVtj4kYGBgYSaBM/i5JONuAuzkXx8DA+EBGXnX//59/pb+BgYHxUYynXElYbLfVJsP/2BUGBsbRjDzArbQekyDeDltgYGDcxphrTK6PkbXBtz7DYmBgHMRoN7eS+rZjZ0VAx8DAOJTRDmatF8ueqfXDa8LAwDiaMRcuk4ZBkgDn5baVoI+BgXE2Yx2Tj1m0zQMMDIzbGOsHxDbsriS9r8/CwMA4lDGXoObl+3wrG8ptGBgYRzNWRsGStLP9hzpwY2BgXMMYp51zwTe/p01xMTAw7mGsFNTmJjvaX03OjGBgYBzKmCvut2G3bWoWwxYYGBjXMKJOQnmlTVbHgKi/gYGBcRwjD6z5YTH5nyg1LYtxGBgYpzKWilzlkTEPqRtqhxgYGIcy2nS0LcD93uAsBgbGDYwoRSxHTtvf5ryov4GBgXEE4ylXGwrbZsNkCxMDA+NoRntQW283tqnpXHkOAwPjPMauFubce5prJPzQGMDAwDiUsSvJTI5xSQmvTn0xMDAwymZA8qv86dGrxMDAwNh0TJxLg6NxDQwMjAsY7chFDs63ODcyi4GBcQNjJSmdK7rlr2xvao2BgfGBjD+JLUHPZ5rgeAAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.4.4"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.js"></script>

<script type="text/javascript" src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/blog.js?v=1.4.4"></script>

<!-- third-party -->






<script type="text/javascript" src="/js/plugins/local_search.js?v=1.4.4"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    
        <script type="text/javascript" src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script type="text/javascript" src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script type="text/javascript" src="/js/plugins/valine.js?v=1.4.4"></script>
    
    



<script type="text/javascript" src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
<script type="text/javascript" src="/js/plugins/leancloud_visitors.js?v=1.4.4"></script>



    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>




    <script>
    (function() {
        var OriginTitile = document.title, titleTime;
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                document.title = '(～﹃～)~zZ';
                clearTimeout(titleTime);
            } else {
                document.title = '(￣▽￣)';
                titleTime = setTimeout(function() {
                    document.title = OriginTitile;
                },2000);
            }
        });
    })();
</script>





    
</body>
</html>
