<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    
    <title>CVE-2020-8835: Linux eBPF模块verifier组件漏洞分析 | DaJun的Blog | 脑袋空空</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="Kernel">
    <link rel="shortcut icon" href="/img/girl.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.4.4">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	false,
            lv: JSON.parse('{"enable":true,"app_id":"ekgad1tINypClpAa8y0wrbvl-gzGzoHsz","app_key":"Qn93YchF3LXlS54tbXjzMvAI","icon":true}'),
            v: JSON.parse('{"enable":true,"appid":"ekgad1tINypClpAa8y0wrbvl-gzGzoHsz","appkey":"Qn93YchF3LXlS54tbXjzMvAI","notify":true,"verify":true,"placeholder":"想说什么...","avatar":"wavatar"}'),
            g: JSON.parse('{"enable":false,"lazy":true,"owner":"codefine","repo":"gitment","oauth":{"client_id":null,"client_secret":null},"perPage":10}'),
            d: JSON.parse('{"app_id":null}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
</head>


<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/girl.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">DaJun</h5>
          <a href="mailto:571986260@qq.com" title="571986260@qq.com" class="mail">
            
              <span>5</span>
            
              <span>7</span>
            
              <span>1</span>
            
              <span>9</span>
            
              <span>8</span>
            
              <span>6</span>
            
              <span>2</span>
            
              <span>6</span>
            
              <span>0</span>
            
              <span>@</span>
            
              <span>q</span>
            
              <span>q</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
        </hgroup>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                HOME
              </a>
            </li>
        
            <li class="">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                CATEGORIES
              </a>
            </li>
        
            <li class="">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                TAGS
              </a>
            </li>
        
            <li class="">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                ARCHIVES
              </a>
            </li>
        
            <li class="">
              <a href="/about"  >
                <i class="icon icon-lg icon-user"></i>
                ABOUT
              </a>
            </li>
        
            <li class="">
              <a href="/pwn-tips"  >
                <i class="icon icon-lg icon-info"></i>
                PWN TIPS
              </a>
            </li>
        
            <li class="">
              <a href="/todo"  >
                <i class="icon icon-lg icon-clock-o"></i>
                TODO
              </a>
            </li>
        
            <li class="">
              <a href="https://github.com/DayJun" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>CVE-2020-8835: Linux eBPF模块verifier组件漏洞分析</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/dawn.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title">CVE-2020-8835: Linux eBPF模块verifier组件漏洞分析</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-04-21T03:28:01.000Z" itemprop="datePublished" class="page-time">
  2020-04-21
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/CVE/">CVE</a></li></ul>

            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
    <article id="post-CVE-2020-8835-Linux-eBPF模块verifier组件漏洞分析"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">CVE-2020-8835: Linux eBPF模块verifier组件漏洞分析</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-04-21 11:28:01" datetime="2020-04-21T03:28:01.000Z"  itemprop="datePublished">2020-04-21</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/CVE/">CVE</a></li></ul>



            
	<span id="/2020/04/21/CVE-2020-8835-Linux-eBPF模块verifier组件漏洞分析/" class="leancloud_visitors" data-flag-title="CVE-2020-8835: Linux eBPF模块verifier组件漏洞分析" title="CVE-2020-8835: Linux eBPF模块verifier组件漏洞分析">
		
			<i class="icon icon-eye"></i>
		
		<span class="leancloud-visitors-count"></span>
	</span>
 

            
    <span class="leancloud-comment">
        <i class="icon icon-comment-o"></i>
        <a href="/2020/04/21/CVE-2020-8835-Linux-eBPF模块verifier组件漏洞分析/#comment">
            <span class="valine-comment-count" data-xid="/2020/04/21/CVE-2020-8835-Linux-eBPF模块verifier组件漏洞分析/"></span>
        </a>
    </span>



            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <p>首发自安全客：<a href="https://www.anquanke.com/post/id/203284" target="_blank" rel="noopener">https://www.anquanke.com/post/id/203284</a></p>
<a id="more"></a>

<h1 id="eBPF简介"><a href="#eBPF简介" class="headerlink" title="eBPF简介"></a>eBPF简介</h1><blockquote>
<p>bpf系统调用执行一系列与extended Berkeley Packet Filters相关的操作，eBPF与传统的BPF相似，作用为 过滤网络包。对于eBPF和传统的BPF来说，为了确保它们进行的操作不会损伤运行时的系统，内核会在加载程序之前静态地分析它们。</p>
</blockquote>
<p>简而言之，eBPF可以加载数据过滤代码到内核，并在进行相关操作的时候触发代码</p>
<p>通常见到的seccomp沙箱就是使用了eBPF模块</p>
<h2 id="eBPF程序的载入"><a href="#eBPF程序的载入" class="headerlink" title="eBPF程序的载入"></a>eBPF程序的载入</h2><h3 id="bpf-insn"><a href="#bpf-insn" class="headerlink" title="bpf_insn"></a>bpf_insn</h3><p><code>bpf_insn</code>是一个结构体，代表一条eBPF指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> &#123;</span></span><br><span class="line">	__u8	code;		<span class="comment">/* opcode */</span></span><br><span class="line">	__u8	dst_reg:<span class="number">4</span>;	<span class="comment">/* dest register */</span></span><br><span class="line">	__u8	src_reg:<span class="number">4</span>;	<span class="comment">/* source register */</span></span><br><span class="line">	__s16	off;		<span class="comment">/* signed offset */</span></span><br><span class="line">	__s32	imm;		<span class="comment">/* signed immediate constant */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每一个eBPF程序都是一个<code>bpf_insn</code>数组，使用bpf系统调用将其载入内核</p>
<p>具体每个字段的含义可以随之后的分析进行了解</p>
<h3 id="bpf-prog-load"><a href="#bpf-prog-load" class="headerlink" title="bpf_prog_load"></a>bpf_prog_load</h3><p>要将eBPF程序载入内核中，需要使用bpf系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_BUF_SIZE 65536</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_BPF 321</span></span><br><span class="line"><span class="keyword">char</span> bpf_log_buf[LOG_BUF_SIZE];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">enum</span> bpf_prog_type type,</span></span></span><br><span class="line"><span class="function"><span class="params">				  <span class="keyword">const</span> struct bpf_insn *insns, <span class="keyword">int</span> insn_cnt,</span></span></span><br><span class="line"><span class="function"><span class="params">				  <span class="keyword">const</span> <span class="keyword">char</span> *license)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> bpf_attr attr = &#123;</span><br><span class="line">		.prog_type = type,</span><br><span class="line">		.insns = ptr_to_u64(insns),</span><br><span class="line">		.insn_cnt = insn_cnt,</span><br><span class="line">		.license = ptr_to_u64(license),</span><br><span class="line">		.log_buf = ptr_to_u64(bpf_log_buf),</span><br><span class="line">		.log_size = LOG_BUF_SIZE,</span><br><span class="line">		.log_level = <span class="number">1</span>,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> syscall(__NR_BPF, BPF_PROG_LOAD, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>type</code>表示eBPF程序类型，不同类型的程序作用不同，例如当<code>type</code>为<code>BPF_PROG_TYPE_SOCKET_FILTER</code>时，表示该程序的作用是过滤进出口网络报文</p>
<p><code>insns</code>是<code>bpf_insn</code>数组，表示该程序的指令</p>
<p><code>insn_cnt</code>表示指令的条数</p>
<p><code>license</code>必须为<code>&quot;GPL&quot;</code></p>
<p><code>bpf_log_bpf</code>中存储的是log信息，可以在程序载入内核之后打印它，能获取比较详细的验证时信息</p>
<h3 id="load-prog"><a href="#load-prog" class="headerlink" title="load_prog"></a>load_prog</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">load_prog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] = &#123;</span></span><br><span class="line">        ……</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		指令……</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, <span class="keyword">sizeof</span>(prog)/<span class="keyword">sizeof</span>(struct bpf_insn), <span class="string">"GPL"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此这般，如何在用户态将一个eBPF程序载入内核就清楚了</p>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>2020年3月30日，漏洞作者分享了他触发漏洞的一段<code>eBPF</code>程序[1]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: (b7) r0 = <span class="number">808464432</span></span><br><span class="line"><span class="number">1</span>: (<span class="number">7f</span>) r0 &gt;&gt;= r0</span><br><span class="line"><span class="number">2</span>: (<span class="number">14</span>) w0 -= <span class="number">808464432</span></span><br><span class="line"><span class="number">3</span>: (<span class="number">07</span>) r0 += <span class="number">808464432</span></span><br><span class="line"><span class="number">4</span>: (b7) r1 = <span class="number">808464432</span></span><br><span class="line"><span class="number">5</span>: (de) <span class="keyword">if</span> w1 s&lt;= w0 <span class="keyword">goto</span> pc+<span class="number">0</span></span><br><span class="line"><span class="number">6</span>: (<span class="number">07</span>) r0 += <span class="number">-2144337872</span></span><br><span class="line"><span class="number">7</span>: (<span class="number">14</span>) w0 -= <span class="number">-1607454672</span></span><br><span class="line"><span class="number">8</span>: (<span class="number">25</span>) <span class="keyword">if</span> r0 &gt; <span class="number">0x30303030</span> <span class="keyword">goto</span> pc+<span class="number">0</span></span><br><span class="line"><span class="number">9</span>: (<span class="number">76</span>) <span class="keyword">if</span> w0 s&gt;= <span class="number">0x303030</span> <span class="keyword">goto</span> pc+<span class="number">2</span></span><br><span class="line"><span class="number">10</span>: (<span class="number">05</span>) <span class="keyword">goto</span> pc<span class="number">-1</span></span><br><span class="line"><span class="number">11</span>: (<span class="number">05</span>) <span class="keyword">goto</span> pc<span class="number">-1</span></span><br><span class="line"><span class="number">12</span>: (<span class="number">95</span>) <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>这段程序触发会使当前进程空转，陷入死循环</p>
<p>乍一看，两个<code>goto pc-1</code>，当然会陷入死循环了，那这个Poc还有什么参考价值？</p>
<h2 id="bpf-check"><a href="#bpf-check" class="headerlink" title="bpf_check"></a>bpf_check</h2><p>以<code>Linux v5.6-rc5</code>的代码为例[2]，源码文件于[4]下载</p>
<p>在使用<code>bpf</code>系统调用将<code>eBPF</code>程序载入内核时，内核会对载入的程序进行合法性检测，以此来保证程序的安全性</p>
<p>在<code>bpf_check</code>中有两个主要的检查，一个是<code>check_cfg</code>，检查程序流程图，另一个是<code>do_check_main</code>，模拟执行程序来检查是否有非法操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_check</span><span class="params">(struct bpf_prog **prog, <span class="keyword">union</span> bpf_attr *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">	      <span class="keyword">union</span> bpf_attr __user *uattr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 start_time = ktime_get_ns();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_verifier_env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_verifier_log</span> *<span class="title">log</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i, len, ret = -EINVAL;</span><br><span class="line">	<span class="keyword">bool</span> is_priv;</span><br><span class="line"></span><br><span class="line">	……</span><br><span class="line">    ret = check_cfg(env);		&lt;------------</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">	ret = do_check_subprogs(env);</span><br><span class="line">	ret = ret ?: do_check_main(env);	&lt;-------------</span><br><span class="line"></span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="check-cfg"><a href="#check-cfg" class="headerlink" title="check_cfg"></a>check_cfg</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check_cfg</span><span class="params">(struct bpf_verifier_env *env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> *<span class="title">insns</span> = <span class="title">env</span>-&gt;<span class="title">prog</span>-&gt;<span class="title">insnsi</span>;</span></span><br><span class="line">	<span class="keyword">int</span> insn_cnt = env-&gt;prog-&gt;len;</span><br><span class="line">	<span class="keyword">int</span> *insn_stack, *insn_state;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i, t;</span><br><span class="line"></span><br><span class="line">	insn_state = env-&gt;cfg.insn_state = kvcalloc(insn_cnt, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!insn_state)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	insn_stack = env-&gt;cfg.insn_stack = kvcalloc(insn_cnt, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!insn_stack) &#123;</span><br><span class="line">		kvfree(insn_state);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	insn_state[<span class="number">0</span>] = DISCOVERED; <span class="comment">/* mark 1st insn as discovered */</span></span><br><span class="line">	insn_stack[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">/* 0 is the first instruction */</span></span><br><span class="line">	env-&gt;cfg.cur_stack = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">peek_stack:</span><br><span class="line">	<span class="keyword">if</span> (env-&gt;cfg.cur_stack == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> check_state;</span><br><span class="line">	t = insn_stack[env-&gt;cfg.cur_stack - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (BPF_CLASS(insns[t].code) == BPF_JMP ||</span><br><span class="line">	    BPF_CLASS(insns[t].code) == BPF_JMP32) &#123;</span><br><span class="line">		u8 opcode = BPF_OP(insns[t].code);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</span><br><span class="line">			<span class="keyword">goto</span> mark_explored;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_CALL) &#123;</span><br><span class="line">			ret = push_insn(t, t + <span class="number">1</span>, FALLTHROUGH, env, <span class="literal">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">goto</span> peek_stack;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> err_free;</span><br><span class="line">			<span class="keyword">if</span> (t + <span class="number">1</span> &lt; insn_cnt)</span><br><span class="line">				init_explored_state(env, t + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (insns[t].src_reg == BPF_PSEUDO_CALL) &#123;</span><br><span class="line">				init_explored_state(env, t);</span><br><span class="line">				ret = push_insn(t, t + insns[t].imm + <span class="number">1</span>, BRANCH,</span><br><span class="line">						env, <span class="literal">false</span>);</span><br><span class="line">				<span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">goto</span> peek_stack;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">goto</span> err_free;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_JA) &#123;</span><br><span class="line">			<span class="keyword">if</span> (BPF_SRC(insns[t].code) != BPF_K) &#123;</span><br><span class="line">				ret = -EINVAL;</span><br><span class="line">				<span class="keyword">goto</span> err_free;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* unconditional jump with single edge */</span></span><br><span class="line">			ret = push_insn(t, t + insns[t].off + <span class="number">1</span>,	&lt;----------------- <span class="number">1</span></span><br><span class="line">					FALLTHROUGH, env, <span class="literal">true</span>);</span><br><span class="line">			<span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">goto</span> peek_stack;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> err_free;</span><br><span class="line">			<span class="comment">/* unconditional jmp is not a good pruning point,</span></span><br><span class="line"><span class="comment">			 * but it's marked, since backtracking needs</span></span><br><span class="line"><span class="comment">			 * to record jmp history in is_state_visited().</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			init_explored_state(env, t + insns[t].off + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">/* tell verifier to check for equivalent states</span></span><br><span class="line"><span class="comment">			 * after every call and jump</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (t + <span class="number">1</span> &lt; insn_cnt)</span><br><span class="line">				init_explored_state(env, t + <span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* conditional jump with two edges */</span></span><br><span class="line">			init_explored_state(env, t);</span><br><span class="line">			ret = push_insn(t, t + <span class="number">1</span>, FALLTHROUGH, env, <span class="literal">true</span>);</span><br><span class="line">			<span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">goto</span> peek_stack;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> err_free;</span><br><span class="line"></span><br><span class="line">			ret = push_insn(t, t + insns[t].off + <span class="number">1</span>, BRANCH, env, <span class="literal">true</span>);</span><br><span class="line">			<span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">goto</span> peek_stack;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> err_free;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* all other non-branch instructions with single</span></span><br><span class="line"><span class="comment">		 * fall-through edge</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ret = push_insn(t, t + <span class="number">1</span>, FALLTHROUGH, env, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">goto</span> peek_stack;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> err_free;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">mark_explored:				&lt;------------------------ <span class="number">2</span></span><br><span class="line">	insn_state[t] = EXPLORED;</span><br><span class="line">	<span class="keyword">if</span> (env-&gt;cfg.cur_stack-- &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		verbose(env, <span class="string">"pop stack internal bug\n"</span>);</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> err_free;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> peek_stack;</span><br><span class="line"></span><br><span class="line">check_state:				&lt;------------------------ <span class="number">3</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn_cnt; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (insn_state[i] != EXPLORED) &#123;</span><br><span class="line">			verbose(env, <span class="string">"unreachable insn %d\n"</span>, i);</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err_free;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="number">0</span>; <span class="comment">/* cfg looks good */</span></span><br><span class="line"></span><br><span class="line">err_free:</span><br><span class="line">	kvfree(insn_state);</span><br><span class="line">	kvfree(insn_stack);</span><br><span class="line">	env-&gt;cfg.insn_state = env-&gt;cfg.insn_stack = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中，<code>insn_state[i]</code>代表第<code>i</code>条指令的状态，<code>EXPLORED</code>表示第<code>i</code>条指令已经被遍历过了</p>
<p>故箭头标记2处，表示标记一条指令被经过，然后再去取下一条指令</p>
<p>箭头3处，有一个<code>for</code>循环来检查所有指令是否已经被遍历过，如果有任何一条指令没有被遍历，则返回错误码，并在log中写入错误信息<code>unreachable insn</code></p>
<p>因此，一个合格的<code>eBPF</code>程序要满足的第一个条件是，没有不可到达的指令</p>
<p>另外，也要注意箭头1处所指的函数<code>pusn_insn</code></p>
<p>在程序中有<code>opcode</code>为<code>BPF_JA</code>，即 “无条件跳转” 的时候，会调用<code>push_insn(t, t + insns[t].off + 1, FALLTHROUGH, env, true);</code>来把下一条指令push入栈</p>
<p>这里，<code>t</code>是当前指令的索引，<code>t+insns[t].off+1</code>是下一条指令的索引</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* t, w, e - match pseudo-code above:</span></span><br><span class="line"><span class="comment"> * t - index of current instruction</span></span><br><span class="line"><span class="comment"> * w - next instruction</span></span><br><span class="line"><span class="comment"> * e - edge</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">push_insn</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> w, <span class="keyword">int</span> e, struct bpf_verifier_env *env,</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="keyword">bool</span> loop_ok)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *insn_stack = env-&gt;cfg.insn_stack;</span><br><span class="line">	<span class="keyword">int</span> *insn_state = env-&gt;cfg.insn_state;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (e == FALLTHROUGH &amp;&amp; insn_state[t] &gt;= (DISCOVERED | FALLTHROUGH))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (e == BRANCH &amp;&amp; insn_state[t] &gt;= (DISCOVERED | BRANCH))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (w &lt; <span class="number">0</span> || w &gt;= env-&gt;prog-&gt;len) &#123;</span><br><span class="line">		verbose_linfo(env, t, <span class="string">"%d: "</span>, t);</span><br><span class="line">		verbose(env, <span class="string">"jump out of range from insn %d to %d\n"</span>, t, w);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (e == BRANCH)</span><br><span class="line">		<span class="comment">/* mark branch target for state pruning */</span></span><br><span class="line">		init_explored_state(env, w);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (insn_state[w] == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* tree-edge */</span></span><br><span class="line">		insn_state[t] = DISCOVERED | e;</span><br><span class="line">		insn_state[w] = DISCOVERED;</span><br><span class="line">		<span class="keyword">if</span> (env-&gt;cfg.cur_stack &gt;= env-&gt;prog-&gt;len)</span><br><span class="line">			<span class="keyword">return</span> -E2BIG;</span><br><span class="line">		insn_stack[env-&gt;cfg.cur_stack++] = w;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((insn_state[w] &amp; <span class="number">0xF0</span>) == DISCOVERED) &#123;</span><br><span class="line">		<span class="keyword">if</span> (loop_ok &amp;&amp; env-&gt;allow_ptr_leaks)		&lt;----------------- <span class="number">1</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		verbose_linfo(env, t, <span class="string">"%d: "</span>, t);</span><br><span class="line">		verbose_linfo(env, w, <span class="string">"%d: "</span>, w);</span><br><span class="line">		verbose(env, <span class="string">"back-edge from insn %d to %d\n"</span>, t, w);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (insn_state[w] == EXPLORED) &#123;</span><br><span class="line">		<span class="comment">/* forward- or cross-edge */</span></span><br><span class="line">		insn_state[t] = DISCOVERED | e;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		verbose(env, <span class="string">"insn state internal bug\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>箭头1处，如果<code>insn_state[w]</code>即下一条指令的状态为<code>DISCOVERED</code>，即当前的无条件跳转指令是往回跳的，就会进入箭头1这一分支。这时，<code>loop_ok</code>为1，如果<code>env-&gt;allow_ptr_leaks</code>为0的话，会报错<code>back-edge</code>，如果非0，则会继续运行</p>
<p>那么，<code>env-&gt;allow_ptr_leaks</code>是由什么影响的呢？</p>
<p>在<code>bpf_check</code>函数中有这么两句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">is_priv = capable(CAP_SYS_ADMIN);</span><br><span class="line">……</span><br><span class="line">env-&gt;allow_ptr_leaks = is_priv;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>意味如果当前用户有<code>CAP_SYS_ADMIN</code>这个权限，那么<code>env-&gt;allow_ptr_leaks</code>就是1，否则就是0 。那么一般我们的用户不是root，没有这个权限，因此<code>env-&gt;allow_ptr_leaks</code>一般为0</p>
<p>这样的话，如果我们的<code>eBPF</code>程序中有往回跳转的指令，<code>push_insn</code>函数就会报错</p>
<p>因此，一个权限一般的合格的<code>eBPF</code>程序要满足的第二个条件是，没有往回跳转的指令</p>
<p>到这里，一般用户能正常通过<code>check_cfg</code>这一个函数所需要的条件就很明白了：</p>
<ul>
<li>没有不可到达的指令</li>
<li>没有往回跳转的指令</li>
<li>没有跳的太远超出指令范围的指令</li>
</ul>
<p>而本文开始所展示的<code>eBPF</code>程序不符合第一个条件和第二个条件，那么它又是如何被载入内核的呢？</p>
<h3 id="do-check-main"><a href="#do-check-main" class="headerlink" title="do_check_main"></a>do_check_main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_check_main</span><span class="params">(struct bpf_verifier_env *env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	env-&gt;insn_idx = <span class="number">0</span>;</span><br><span class="line">	ret = do_check_common(env, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!ret)</span><br><span class="line">		env-&gt;prog-&gt;aux-&gt;stack_depth = env-&gt;subprog_info[<span class="number">0</span>].stack_depth;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>do_check_main</code>函数中，调用了<code>do_check_commin</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_check_common</span><span class="params">(struct bpf_verifier_env *env, <span class="keyword">int</span> subprog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	……</span><br><span class="line">	ret = do_check(env);</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>且不管其他，我们主要注意的地方是这个<code>do_check</code>函数。在该函数中，内核会模拟执行被载入的程序，并逐条指令检查其合法性。何为不合法？<code>eBPF</code>程序的指令是包括内存存取相关指令的，因此对被存取的指针它会有类型以及范围的限定，而且限定非常严格。如果说限定的部分有漏洞，或者其他的原因导致限定失效，那么将会带来非常恐怖的后果。例如<strong>任意地址读写</strong></p>
<p>在遇到具有分支，例如<code>if xxx goto pc+x</code>这样的语句，内核会检测<code>if</code>判断的条件是否恒成立。若判断为恒成立或者恒不成立，则只分析相应的那一分支，而另一分支则不进行分析。没有被分析到的指令被视为<code>dead code</code></p>
<h2 id="Poc分析"><a href="#Poc分析" class="headerlink" title="Poc分析"></a>Poc分析</h2><p>Poc的c文件链接在文末[3]，注意要用普通用户执行Poc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: (b7) r0 = <span class="number">808464432</span></span><br><span class="line"><span class="number">1</span>: (<span class="number">7f</span>) r0 &gt;&gt;= r0</span><br><span class="line"><span class="number">2</span>: (<span class="number">14</span>) w0 -= <span class="number">808464432</span></span><br><span class="line"><span class="number">3</span>: (<span class="number">07</span>) r0 += <span class="number">808464432</span></span><br><span class="line"><span class="number">4</span>: (b7) r1 = <span class="number">808464432</span></span><br><span class="line"><span class="number">5</span>: (de) <span class="keyword">if</span> w1 s&lt;= w0 <span class="keyword">goto</span> pc+<span class="number">0</span></span><br><span class="line"><span class="number">6</span>: (<span class="number">07</span>) r0 += <span class="number">-2144337872</span></span><br><span class="line"><span class="number">7</span>: (<span class="number">14</span>) w0 -= <span class="number">-1607454672</span></span><br><span class="line"><span class="number">8</span>: (<span class="number">25</span>) <span class="keyword">if</span> r0 &gt; <span class="number">0x30303030</span> <span class="keyword">goto</span> pc+<span class="number">0</span></span><br><span class="line"><span class="number">9</span>: (<span class="number">76</span>) <span class="keyword">if</span> w0 s&gt;= <span class="number">0x303030</span> <span class="keyword">goto</span> pc+<span class="number">2</span></span><br><span class="line"><span class="number">10</span>: (<span class="number">05</span>) <span class="keyword">goto</span> pc<span class="number">-1</span></span><br><span class="line"><span class="number">11</span>: (<span class="number">05</span>) <span class="keyword">goto</span> pc<span class="number">-1</span></span><br><span class="line"><span class="number">12</span>: (<span class="number">95</span>) <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>首先先回答一个问题，为什么<code>goto pc-1</code>这样不能通过<code>check_cfg</code>的指令会被载入到内核中呢？</p>
<p>答案在<code>bpf_check</code>函数中</p>
<p>就在调用<code>do_check_main</code>那条语句的下方，还有几条代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_priv) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">			opt_hard_wire_dead_code_branches(env);</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">			ret = opt_remove_dead_code(env);</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">			ret = opt_remove_nops(env);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">			sanitize_dead_code(env);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>代码中，<code>is_priv</code>为何物我们已经了解，如果用户为root的话，<code>is_priv</code>为1，用户为具有一般权限的一般用户的话，其为0</p>
<p>关于<code>is_priv</code>为1的情况下内核究竟对<code>eBPF</code>程序做了什么不去细说，总结为一句话就是：内核将<code>dead code</code>全部替换为<code>exit</code>，即退出指令</p>
<p>那么接下来来看<code>sanitize_dead_code</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The verifier does more data flow analysis than llvm and will not</span></span><br><span class="line"><span class="comment"> * explore branches that are dead at run time. Malicious programs can</span></span><br><span class="line"><span class="comment"> * have dead code too. Therefore replace all dead at-run-time code</span></span><br><span class="line"><span class="comment"> * with 'ja -1'.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Just nops are not optimal, e.g. if they would sit at the end of the</span></span><br><span class="line"><span class="comment"> * program and through another bug we would manage to jump there, then</span></span><br><span class="line"><span class="comment"> * we'd execute beyond program memory otherwise. Returning exception</span></span><br><span class="line"><span class="comment"> * code also wouldn't work since we can have subprogs where the dead</span></span><br><span class="line"><span class="comment"> * code could be located.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sanitize_dead_code</span><span class="params">(struct bpf_verifier_env *env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn_aux_data</span> *<span class="title">aux_data</span> = <span class="title">env</span>-&gt;<span class="title">insn_aux_data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">trap</span> = <span class="title">BPF_JMP_IMM</span>(<span class="title">BPF_JA</span>, 0, 0, -1);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> *<span class="title">insn</span> = <span class="title">env</span>-&gt;<span class="title">prog</span>-&gt;<span class="title">insnsi</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> insn_cnt = env-&gt;prog-&gt;len;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn_cnt; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (aux_data[i].seen)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">memcpy</span>(insn + i, &amp;trap, <span class="keyword">sizeof</span>(trap));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释写的很清楚，这个函数会将所有的<code>dead code</code>改为<code>goto pc-1</code>，这样就能解释清楚<code>Poc</code>中10，11这两句不合法语句的来历了</p>
<p>内核在检查程序合法性的过程中，第9句在检查时被判断为恒成立，之后的检查便只检查了第12句，第10和第11句被视为<code>dead code</code>，在之后的<code>sanitize_dead_code</code>函数中被修改为<code>goto pc-1</code>。而没有想到的是，在实际执行的时候第9句实际上是恒不成立，因此就导致程序执行了<code>goto pc-1</code>。在实际执行跳转指令的时候，跳转的偏移会默认加1，因此实际上<code>goto pc-1</code>跳转到的地方不是自己的上一条，而是自己，这就导致程序空转，陷入死循环</p>
<p>那么为什么在检查的时候第九句的状态和实际执行时的状态不同呢？我们来一步步动态地分析一下</p>
<p>在分析之前，要先了解寄存器结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> &#123;</span></span><br><span class="line">	<span class="keyword">enum</span> bpf_reg_type type;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="comment">/* valid when type == PTR_TO_PACKET */</span></span><br><span class="line">		u16 range;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span></span><br><span class="line"><span class="comment">		 *   PTR_TO_MAP_VALUE_OR_NULL</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">		u32 btf_id; <span class="comment">/* for PTR_TO_BTF_ID */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Max size from any of the above. */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> raw;</span><br><span class="line">	&#125;;</span><br><span class="line">	s32 off;</span><br><span class="line">	u32 id;</span><br><span class="line">	u32 ref_obj_id;</span><br><span class="line">	<span class="comment">/* For scalar types (SCALAR_VALUE), this represents our knowledge of</span></span><br><span class="line"><span class="comment">	 * the actual value.</span></span><br><span class="line"><span class="comment">	 * For pointer types, this represents the variable part of the offset</span></span><br><span class="line"><span class="comment">	 * from the pointed-to object, and is shared with all bpf_reg_states</span></span><br><span class="line"><span class="comment">	 * with the same id as us.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">var_off</span>;</span></span><br><span class="line">	<span class="comment">/* Used to determine if any memory access using this register will</span></span><br><span class="line"><span class="comment">	 * result in a bad access.</span></span><br><span class="line"><span class="comment">	 * These refer to the same value as var_off, not necessarily the actual</span></span><br><span class="line"><span class="comment">	 * contents of the register.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s64 smin_value; <span class="comment">/* minimum possible (s64)value */</span></span><br><span class="line">	s64 smax_value; <span class="comment">/* maximum possible (s64)value */</span></span><br><span class="line">	u64 umin_value; <span class="comment">/* minimum possible (u64)value */</span></span><br><span class="line">	u64 umax_value; <span class="comment">/* maximum possible (u64)value */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> *<span class="title">parent</span>;</span></span><br><span class="line">	u32 frameno;</span><br><span class="line">	s32 subreg_def;</span><br><span class="line">	<span class="keyword">enum</span> bpf_reg_liveness live;</span><br><span class="line">	<span class="comment">/* if (!precise &amp;&amp; SCALAR_VALUE) min/max/tnum don't affect safety */</span></span><br><span class="line">	<span class="keyword">bool</span> precise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>理解该漏洞之前要先理解该结构体，要注意的一个字段是<code>var_off</code>，它是一个<code>tnum</code>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* tnum: tracked (or tristate) numbers</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A tnum tracks knowledge about the bits of a value.  Each bit can be either</span></span><br><span class="line"><span class="comment"> * known (0 or 1), or unknown (x).  Arithmetic operations on tnums will</span></span><br><span class="line"><span class="comment"> * propagate the unknown bits such that the tnum result represents all the</span></span><br><span class="line"><span class="comment"> * possible results for possible values of the operands.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> &#123;</span></span><br><span class="line">	u64 value;</span><br><span class="line">	u64 mask;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>tnum</code>的注释没太懂，我的理解是：</p>
<ul>
<li><code>mask</code>为0的时候，表示该<code>tnum</code>是一个数字，值为<code>value</code></li>
<li><code>mask</code>非0的时候，表示一个范围，所有与<code>mask</code>进行与操作不为0的数字都在这个范围内，而此时的<code>value</code>只是该范围内的一个数字，并不精确</li>
</ul>
<h3 id="0-b7-r0-808464432"><a href="#0-b7-r0-808464432" class="headerlink" title="0: (b7) r0 = 808464432"></a>0: (b7) r0 = 808464432</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x30303030</span>,</span><br><span class="line">    mask = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  smax_value = <span class="number">0x30303030</span>,</span><br><span class="line">  umin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  umax_value = <span class="number">0x30303030</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x0</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，r0存储着一个确定的值，为0x30303030</p>
<h3 id="1-7f-r0-gt-gt-r0"><a href="#1-7f-r0-gt-gt-r0" class="headerlink" title="1: (7f) r0 &gt;&gt;= r0"></a>1: (7f) r0 &gt;&gt;= r0</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x0</span>,</span><br><span class="line">    mask = <span class="number">0xffffffffffffffff</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x8000000000000000</span>,</span><br><span class="line">  smax_value = <span class="number">0x7fffffffffffffff</span>,</span><br><span class="line">  umin_value = <span class="number">0x0</span>,</span><br><span class="line">  umax_value = <span class="number">0xffffffffffffffff</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x0</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>var_off</code>改变了，变为了一个完全不确定的值，且<code>smin_value, smax_value, umin_value, umax_value</code>都变为了相应范围的最大最小值</p>
<p>相应代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BPF_RSH:</span><br><span class="line">		<span class="keyword">if</span> (umax_val &gt;= insn_bitness) &#123;</span><br><span class="line">			<span class="comment">/* Shifts greater than 31 or 63 are undefined.</span></span><br><span class="line"><span class="comment">			 * This includes shifts by a negative number.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			mark_reg_unknown(env, regs, insn-&gt;dst_reg);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		scalar_min_max_rsh(dst_reg, &amp;src_reg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>这里的<code>umax_val</code>就是<code>r0-&gt;umax_val</code>，在执行到这里的时候，为<code>0x30303030</code>，大于<code>insn_bitness</code>即64，所以就会标记寄存器为<code>unknown</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark_reg_unknown</span><span class="params">(struct bpf_verifier_env *env,</span></span></span><br><span class="line"><span class="function"><span class="params">			     struct bpf_reg_state *regs, u32 regno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(regno &gt;= MAX_BPF_REG)) &#123;</span><br><span class="line">		verbose(env, <span class="string">"mark_reg_unknown(regs, %u)\n"</span>, regno);</span><br><span class="line">		<span class="comment">/* Something bad happened, let's kill all regs except FP */</span></span><br><span class="line">		<span class="keyword">for</span> (regno = <span class="number">0</span>; regno &lt; BPF_REG_FP; regno++)</span><br><span class="line">			__mark_reg_not_init(env, regs + regno);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	__mark_reg_unknown(env, regs + regno);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __mark_reg_unknown(<span class="keyword">const</span> struct bpf_verifier_env *env,</span><br><span class="line">			       struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Clear type, id, off, and union(map_ptr, range) and</span></span><br><span class="line"><span class="comment">	 * padding between 'type' and union</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">memset</span>(reg, <span class="number">0</span>, offsetof(struct bpf_reg_state, var_off));</span><br><span class="line">	reg-&gt;type = SCALAR_VALUE;</span><br><span class="line">	reg-&gt;var_off = tnum_unknown;</span><br><span class="line">	reg-&gt;frameno = <span class="number">0</span>;</span><br><span class="line">	reg-&gt;precise = env-&gt;subprog_cnt &gt; <span class="number">1</span> || !env-&gt;allow_ptr_leaks ?</span><br><span class="line">		       <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">	__mark_reg_unbounded(reg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __mark_reg_unbounded(struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	reg-&gt;smin_value = S64_MIN;</span><br><span class="line">	reg-&gt;smax_value = S64_MAX;</span><br><span class="line">	reg-&gt;umin_value = <span class="number">0</span>;</span><br><span class="line">	reg-&gt;umax_value = U64_MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>mark_reg_unknown</code>总共做了这些事：</p>
<ul>
<li>reg-&gt;type = SCALAR_VALUE</li>
<li>reg-&gt;var_off = {0, 0xffffffffffffffff}</li>
<li>reg-&gt;smin_value = 0x8000000000000000</li>
<li>reg-&gt;smax_value = 0x7fffffffffffffff</li>
<li>reg-&gt;umin_value = 0</li>
<li>reg-&gt;umax_value = 0xffffffffffffffff</li>
</ul>
<h3 id="2-14-w0-808464432"><a href="#2-14-w0-808464432" class="headerlink" title="2: (14) w0 -= 808464432"></a>2: (14) w0 -= 808464432</h3><p>主要代码位于<code>adjust_scalar_min_max_vals</code>函数中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust_scalar_min_max_vals</span><span class="params">(struct bpf_verifier_env *env,</span></span></span><br><span class="line"><span class="function"><span class="params">				      struct bpf_insn *insn,</span></span></span><br><span class="line"><span class="function"><span class="params">				      struct bpf_reg_state *dst_reg,</span></span></span><br><span class="line"><span class="function"><span class="params">				      struct bpf_reg_state src_reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> *<span class="title">regs</span> = <span class="title">cur_regs</span>(<span class="title">env</span>);</span></span><br><span class="line">	u8 opcode = BPF_OP(insn-&gt;code);</span><br><span class="line">	<span class="keyword">bool</span> src_known, dst_known;</span><br><span class="line">	s64 smin_val, smax_val;</span><br><span class="line">	u64 umin_val, umax_val;</span><br><span class="line">	u64 insn_bitness = (BPF_CLASS(insn-&gt;code) == BPF_ALU64) ? <span class="number">64</span> : <span class="number">32</span>;</span><br><span class="line">	u32 dst = insn-&gt;dst_reg;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (insn_bitness == <span class="number">32</span>) &#123;</span><br><span class="line">		<span class="comment">/* Relevant for 32-bit RSH: Information can propagate towards</span></span><br><span class="line"><span class="comment">		 * LSB, so it isn't sufficient to only truncate the output to</span></span><br><span class="line"><span class="comment">		 * 32 bits.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		coerce_reg_to_size(dst_reg, <span class="number">4</span>);</span><br><span class="line">		coerce_reg_to_size(&amp;src_reg, <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	smin_val = src_reg.smin_value;</span><br><span class="line">	smax_val = src_reg.smax_value;</span><br><span class="line">	umin_val = src_reg.umin_value;</span><br><span class="line">	umax_val = src_reg.umax_value;</span><br><span class="line">	src_known = tnum_is_const(src_reg.var_off);</span><br><span class="line">	dst_known = tnum_is_const(dst_reg-&gt;var_off);</span><br><span class="line"></span><br><span class="line">	……</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">case</span> BPF_SUB:</span><br><span class="line">		ret = sanitize_val_alu(env, insn);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			verbose(env, <span class="string">"R%d tried to sub from different pointers or scalars\n"</span>, dst);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">		scalar_min_max_sub(dst_reg, &amp;src_reg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	……</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (BPF_CLASS(insn-&gt;code) != BPF_ALU64) &#123;</span><br><span class="line">		<span class="comment">/* 32-bit ALU ops are (32,32)-&gt;32 */</span></span><br><span class="line">		coerce_reg_to_size(dst_reg, <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__update_reg_bounds(dst_reg);</span><br><span class="line">	__reg_deduce_bounds(dst_reg);</span><br><span class="line">	__reg_bound_offset(dst_reg);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于该条指令使用的是32位寄存器，因此会先调用<code>coerce_reg_to_size</code>将寄存器转化为32位的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">coerce_reg_to_size</span><span class="params">(struct bpf_reg_state *reg, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* clear high bits in bit representation */</span></span><br><span class="line">	reg-&gt;var_off = tnum_cast(reg-&gt;var_off, size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fix arithmetic bounds */</span></span><br><span class="line">	mask = ((u64)<span class="number">1</span> &lt;&lt; (size * <span class="number">8</span>)) - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> ((reg-&gt;umin_value &amp; ~mask) == (reg-&gt;umax_value &amp; ~mask)) &#123;</span><br><span class="line">		reg-&gt;umin_value &amp;= mask;</span><br><span class="line">		reg-&gt;umax_value &amp;= mask;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		reg-&gt;umin_value = <span class="number">0</span>;</span><br><span class="line">		reg-&gt;umax_value = mask;</span><br><span class="line">	&#125;</span><br><span class="line">	reg-&gt;smin_value = reg-&gt;umin_value;</span><br><span class="line">	reg-&gt;smax_value = reg-&gt;umax_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换完之后，寄存器的状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x0</span>,</span><br><span class="line">    mask = <span class="number">0xffffffff</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x0</span>,</span><br><span class="line">  smax_value = <span class="number">0xffffffff</span>,</span><br><span class="line">  umin_value = <span class="number">0x0</span>,</span><br><span class="line">  umax_value = <span class="number">0xffffffff</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x3</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后开始做减法，此时的<code>src_reg</code>其实就是<code>808464432</code>，只不过是用一个暂时的寄存器将其保存了</p>
<p>相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scalar_min_max_sub</span><span class="params">(struct bpf_reg_state *dst_reg,</span></span></span><br><span class="line"><span class="function"><span class="params">			       struct bpf_reg_state *src_reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s64 smin_val = src_reg-&gt;smin_value;</span><br><span class="line">	s64 smax_val = src_reg-&gt;smax_value;</span><br><span class="line">	u64 umin_val = src_reg-&gt;umin_value;</span><br><span class="line">	u64 umax_val = src_reg-&gt;umax_value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (signed_sub_overflows(dst_reg-&gt;smin_value, smax_val) ||</span><br><span class="line">	    signed_sub_overflows(dst_reg-&gt;smax_value, smin_val)) &#123;</span><br><span class="line">		<span class="comment">/* Overflow possible, we know nothing */</span></span><br><span class="line">		dst_reg-&gt;smin_value = S64_MIN;</span><br><span class="line">		dst_reg-&gt;smax_value = S64_MAX;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dst_reg-&gt;smin_value -= smax_val;	&lt;-------------</span><br><span class="line">		dst_reg-&gt;smax_value -= smin_val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dst_reg-&gt;umin_value &lt; umax_val) &#123;</span><br><span class="line">		<span class="comment">/* Overflow possible, we know nothing */</span></span><br><span class="line">		dst_reg-&gt;umin_value = <span class="number">0</span>;			&lt;-------------</span><br><span class="line">		dst_reg-&gt;umax_value = U64_MAX;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Cannot overflow (as long as bounds are consistent) */</span></span><br><span class="line">		dst_reg-&gt;umin_value -= umax_val;</span><br><span class="line">		dst_reg-&gt;umax_value -= umin_val;</span><br><span class="line">	&#125;</span><br><span class="line">	dst_reg-&gt;var_off = tnum_sub(dst_reg-&gt;var_off, src_reg-&gt;var_off);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>smin_value, smax_value, umin_value, umax_value</code>都是<code>0x30303030</code>，经过两个箭头所指的代码，就将寄存器的状态变成了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x0</span>,</span><br><span class="line">    mask = <span class="number">0xffffffff</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0xffffffffcfcfcfd0</span>,</span><br><span class="line">  smax_value = <span class="number">0xcfcfcfcf</span>,</span><br><span class="line">  umin_value = <span class="number">0x0</span>,</span><br><span class="line">  umax_value = <span class="number">0xffffffff</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x3</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完减法之后，因为<code>BPF_CLASS</code>不是<code>BPF_ALU64</code>，所以其又进行了一次<code>coerce_reg_to_size</code>，之后的寄存器状态如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x0</span>,</span><br><span class="line">    mask = <span class="number">0xffffffff</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x0</span>,</span><br><span class="line">  smax_value = <span class="number">0xffffffff</span>,</span><br><span class="line">  umin_value = <span class="number">0x0</span>,</span><br><span class="line">  umax_value = <span class="number">0xffffffff</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x3</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后执行完<code>__update_reg_bounds</code>、<code>__reg_deduce_bounds</code>、<code>__reg_bound_offset</code>之后寄存器的状态都没有改变</p>
<p>第四句和第三句一样，是一个算术运算，其流程类似，故不分析</p>
<p>执行完第四句之后，寄存器的状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x0</span>,</span><br><span class="line">    mask = <span class="number">0x1ffffffff</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  smax_value = <span class="number">0x13030302f</span>,</span><br><span class="line">  umin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  umax_value = <span class="number">0x13030302f</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x0</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-de-if-w1-s-lt-w0-goto-pc-0"><a href="#5-de-if-w1-s-lt-w0-goto-pc-0" class="headerlink" title="5: (de) if w1 s&lt;= w0 goto pc+0"></a>5: (de) if w1 s&lt;= w0 goto pc+0</h3><p>执行这条语句之前，<code>r0</code>和<code>r1</code>的状态分别为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x0</span>,</span><br><span class="line">    mask = <span class="number">0x1ffffffff</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  smax_value = <span class="number">0x13030302f</span>,</span><br><span class="line">  umin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  umax_value = <span class="number">0x13030302f</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x0</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$r1 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x30303030</span>,</span><br><span class="line">    mask = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  smax_value = <span class="number">0x30303030</span>,</span><br><span class="line">  umin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  umax_value = <span class="number">0x30303030</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x0</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行这条语句之后，<code>r0</code>的状态变为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x30303020</span>,</span><br><span class="line">    mask = <span class="number">0x10000001f</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  smax_value = <span class="number">0x13030302f</span>,</span><br><span class="line">  umin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  umax_value = <span class="number">0x13030302f</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x0</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来解释下为什么会有这样的变化</p>
<p>在遇到跳转指令的时候，会调用<code>check_cond_jmp_op</code>来检查该指令</p>
<p>在该函数中，由于<code>r0</code>不是一个确定的数字，因此会调用<code>reg_set_min_max_inv</code>来设置寄存器的最大最小值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reg_set_min_max_inv</span><span class="params">(struct bpf_reg_state *true_reg,</span></span></span><br><span class="line"><span class="function"><span class="params">				struct bpf_reg_state *false_reg, u64 val,</span></span></span><br><span class="line"><span class="function"><span class="params">				u8 opcode, <span class="keyword">bool</span> is_jmp32)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s64 sval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (__is_pointer_value(<span class="literal">false</span>, false_reg))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	val = is_jmp32 ? (u32)val : val;</span><br><span class="line">	sval = is_jmp32 ? (s64)(s32)val : (s64)val;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">case</span> BPF_JSLE:</span><br><span class="line">	<span class="keyword">case</span> BPF_JSLT:</span><br><span class="line">	&#123;</span><br><span class="line">		s64 false_smax = opcode == BPF_JSLT ? sval    : sval - <span class="number">1</span>;</span><br><span class="line">		s64 true_smin = opcode == BPF_JSLT ? sval + <span class="number">1</span> : sval;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (is_jmp32 &amp;&amp; !cmp_val_with_extended_s64(sval, false_reg))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		false_reg-&gt;smax_value = min(false_reg-&gt;smax_value, false_smax);</span><br><span class="line">		true_reg-&gt;smin_value = max(true_reg-&gt;smin_value, true_smin);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__reg_deduce_bounds(false_reg);</span><br><span class="line">	__reg_deduce_bounds(true_reg);</span><br><span class="line">	<span class="comment">/* We might have learned some bits from the bounds. */</span></span><br><span class="line">	__reg_bound_offset(false_reg);</span><br><span class="line">	__reg_bound_offset(true_reg);</span><br><span class="line">	<span class="keyword">if</span> (is_jmp32) &#123;			&lt;----------------------</span><br><span class="line">		__reg_bound_offset32(false_reg);	&lt;-------------------</span><br><span class="line">		__reg_bound_offset32(true_reg);		&lt;-------------------</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Intersecting with the old var_off might have improved our bounds</span></span><br><span class="line"><span class="comment">	 * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),</span></span><br><span class="line"><span class="comment">	 * then new var_off is (0; 0x7f...fc) which improves our umax.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__update_reg_bounds(false_reg);</span><br><span class="line">	__update_reg_bounds(true_reg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>false_reg</code>和<code>true_reg</code>表示两种状态，即该<code>if</code>不成立时的<code>reg</code>和<code>if</code>成立时的<code>reg</code></p>
<p>漏洞所处代码就在箭头所指的地方，这里仅跟进<code>false_reg</code></p>
<p>先说明执行<code>__reg_bound_offset32</code>函数之前，<code>false_reg</code>的状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$false_reg = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x0</span>,</span><br><span class="line">    mask = <span class="number">0x1ffffffff</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  smax_value = <span class="number">0x13030302f</span>,</span><br><span class="line">  umin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  umax_value = <span class="number">0x13030302f</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x0</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __reg_bound_offset32(struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	u64 mask = <span class="number">0xffffFFFF</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">range</span> = <span class="title">tnum_range</span>(<span class="title">reg</span>-&gt;<span class="title">umin_value</span> &amp; <span class="title">mask</span>,</span></span><br><span class="line"><span class="class">				       <span class="title">reg</span>-&gt;<span class="title">umax_value</span> &amp; <span class="title">mask</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">lo32</span> = <span class="title">tnum_cast</span>(<span class="title">reg</span>-&gt;<span class="title">var_off</span>, 4);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">hi32</span> = <span class="title">tnum_lshift</span>(<span class="title">tnum_rshift</span>(<span class="title">reg</span>-&gt;<span class="title">var_off</span>, 32), 32);</span></span><br><span class="line"></span><br><span class="line">	reg-&gt;var_off = tnum_or(hi32, tnum_intersect(lo32, range));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数执行完之后，寄存器的状态变为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x30303020</span>,</span><br><span class="line">    mask = <span class="number">0x10000001f</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  smax_value = <span class="number">0x13030302f</span>,</span><br><span class="line">  umin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  umax_value = <span class="number">0x13030302f</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x0</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再之后，执行<code>__update_reg_bounds(false_reg)</code>之后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __update_reg_bounds(struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* min signed is max(sign bit) | min(other bits) */</span></span><br><span class="line">	reg-&gt;smin_value = <span class="keyword">max_t</span>(s64, reg-&gt;smin_value,</span><br><span class="line">				reg-&gt;var_off.value | (reg-&gt;var_off.mask &amp; S64_MIN));</span><br><span class="line">	<span class="comment">/* max signed is min(sign bit) | max(other bits) */</span></span><br><span class="line">	reg-&gt;smax_value = <span class="keyword">min_t</span>(s64, reg-&gt;smax_value,</span><br><span class="line">				reg-&gt;var_off.value | (reg-&gt;var_off.mask &amp; S64_MAX));</span><br><span class="line">	reg-&gt;umin_value = max(reg-&gt;umin_value, reg-&gt;var_off.value);</span><br><span class="line">	reg-&gt;umax_value = min(reg-&gt;umax_value,</span><br><span class="line">			      reg-&gt;var_off.value | reg-&gt;var_off.mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>reg</code>不变，这里可以推导一下</p>
<h3 id="6-07-r0-2144337872"><a href="#6-07-r0-2144337872" class="headerlink" title="6: (07) r0 += -2144337872"></a>6: (07) r0 += -2144337872</h3><p>执行完这一句之后，寄存器状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0xb0603040</span>,</span><br><span class="line">    mask = <span class="number">0xffffffff0000003f</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0xffffffffb0603060</span>,</span><br><span class="line">  smax_value = <span class="number">0xb060305f</span>,</span><br><span class="line">  umin_value = <span class="number">0x0</span>,</span><br><span class="line">  umax_value = <span class="number">0xffffffffffffffff</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x0</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-14-w0-1607454672"><a href="#7-14-w0-1607454672" class="headerlink" title="7: (14) w0 -= -1607454672"></a>7: (14) w0 -= -1607454672</h3><p>执行这一句的时候，先会用<code>coerce_reg_to_size</code>把寄存器转换为32位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0xb0603040</span>,</span><br><span class="line">    mask = <span class="number">0x3f</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x0</span>,</span><br><span class="line">  smax_value = <span class="number">0xffffffff</span>,</span><br><span class="line">  umin_value = <span class="number">0x0</span>,</span><br><span class="line">  umax_value = <span class="number">0xffffffff</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x8</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再做减法并改变<code>var_off</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x10300000</span>,</span><br><span class="line">    mask = <span class="number">0x7f</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0xffffffff5fcfcfd0</span>,</span><br><span class="line">  smax_value = <span class="number">0x5fcfcfcf</span>,</span><br><span class="line">  umin_value = <span class="number">0x0</span>,</span><br><span class="line">  umax_value = <span class="number">0xffffffffffffffff</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x8</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再<code>coerce_reg_to_size</code>转为32位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x10300000</span>,</span><br><span class="line">    mask = <span class="number">0x7f</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x0</span>,</span><br><span class="line">  smax_value = <span class="number">0xffffffff</span>,</span><br><span class="line">  umin_value = <span class="number">0x0</span>,</span><br><span class="line">  umax_value = <span class="number">0xffffffff</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x8</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在<code>__update_reg_bounds</code>函数中，寄存器被变为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x10300000</span>,</span><br><span class="line">    mask = <span class="number">0x7f</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x10300000</span>,</span><br><span class="line">  smax_value = <span class="number">0x1030007f</span>,</span><br><span class="line">  umin_value = <span class="number">0x10300000</span>,</span><br><span class="line">  umax_value = <span class="number">0x1030007f</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x8</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-76-if-w0-s-gt-0x303030-goto-pc-2"><a href="#9-76-if-w0-s-gt-0x303030-goto-pc-2" class="headerlink" title="9: (76) if w0 s&gt;= 0x303030 goto pc+2"></a>9: (76) if w0 s&gt;= 0x303030 goto pc+2</h3><p>相关代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BPF_JSGE:</span><br><span class="line">		<span class="keyword">if</span> (reg-&gt;smin_value &gt;= sval)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (reg-&gt;smax_value &lt; sval)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>这里<code>reg-&gt;smin_value</code>为<code>0x10300000</code>，<code>sval</code>为<code>0x303030</code>，可以看到这里会返回1，表示该if语句恒成立</p>
<p>那么从此刻开始，下一个被检测的语句就变成了第12句，而第10和第11句就被patch成了<code>goto pc-1</code></p>
<p>然而，在实际的计算过程中，此刻的<code>w0</code>为<code>0xCFD0</code>，小于<code>0x303030</code>，就会导致真正在执行的过程中，内核会执行<code>goto pc-1</code>，导致空转，死循环</p>
<h2 id="深入思考"><a href="#深入思考" class="headerlink" title="深入思考"></a>深入思考</h2><p>作者是如何修复该漏洞的？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</span><br><span class="line">index <span class="number">047b</span>2e8.<span class="number">.2</span>a84f73 <span class="number">100644</span></span><br><span class="line">--- a/kernel/bpf/verifier.c</span><br><span class="line">+++ b/kernel/bpf/verifier.c</span><br><span class="line">@@ <span class="number">-1036</span>,<span class="number">17</span> +<span class="number">1036</span>,<span class="number">6</span> @@ <span class="keyword">static</span> <span class="keyword">void</span> __reg_bound_offset(struct bpf_reg_state *reg)</span><br><span class="line"> 						 reg-&gt;umax_value));</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">-<span class="keyword">static</span> <span class="keyword">void</span> __reg_bound_offset32(struct bpf_reg_state *reg)</span><br><span class="line">-&#123;</span><br><span class="line">-	u64 mask = <span class="number">0xffffFFFF</span>;</span><br><span class="line">-	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">range</span> = <span class="title">tnum_range</span>(<span class="title">reg</span>-&gt;<span class="title">umin_value</span> &amp; <span class="title">mask</span>,</span></span><br><span class="line"><span class="class">-				       <span class="title">reg</span>-&gt;<span class="title">umax_value</span> &amp; <span class="title">mask</span>);</span></span><br><span class="line">-	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">lo32</span> = <span class="title">tnum_cast</span>(<span class="title">reg</span>-&gt;<span class="title">var_off</span>, 4);</span></span><br><span class="line">-	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">hi32</span> = <span class="title">tnum_lshift</span>(<span class="title">tnum_rshift</span>(<span class="title">reg</span>-&gt;<span class="title">var_off</span>, 32), 32);</span></span><br><span class="line">-</span><br><span class="line">-	reg-&gt;var_off = tnum_or(hi32, tnum_intersect(lo32, range));</span><br><span class="line">-&#125;</span><br><span class="line">-</span><br><span class="line"> <span class="comment">/* Reset the min/max bounds of a register */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">void</span> __mark_reg_unbounded(struct bpf_reg_state *reg)</span><br><span class="line"> &#123;</span><br><span class="line">@@ <span class="number">-5805</span>,<span class="number">10</span> +<span class="number">5794</span>,<span class="number">6</span> @@ <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reg_set_min_max</span><span class="params">(struct bpf_reg_state *true_reg,</span></span></span><br><span class="line"><span class="function"><span class="params"> 	<span class="comment">/* We might have learned some bits from the bounds. */</span></span></span></span><br><span class="line"><span class="function"><span class="params"> 	__reg_bound_offset(false_reg);</span></span></span><br><span class="line"><span class="function"><span class="params"> 	__reg_bound_offset(true_reg);</span></span></span><br><span class="line"><span class="function"><span class="params">-	<span class="keyword">if</span> (is_jmp32) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">-		__reg_bound_offset32(false_reg);</span></span></span><br><span class="line"><span class="function"><span class="params">-		__reg_bound_offset32(true_reg);</span></span></span><br><span class="line"><span class="function"><span class="params">-	&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"> 	<span class="comment">/* Intersecting with the old var_off might have improved our bounds</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment"> 	 * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment"> 	 * then new var_off is (0; 0x7f...fc) which improves our umax.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">@@ -5918,10 +5903,6 @@ static void reg_set_min_max_inv(struct bpf_reg_state *true_reg,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment"> 	/* We might have learned some bits from the bounds. */</span></span></span></span><br><span class="line"><span class="function"><span class="params"> 	__reg_bound_offset(false_reg);</span></span></span><br><span class="line"><span class="function"><span class="params"> 	__reg_bound_offset(true_reg);</span></span></span><br><span class="line"><span class="function"><span class="params">-	<span class="keyword">if</span> (is_jmp32) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">-		__reg_bound_offset32(false_reg);</span></span></span><br><span class="line"><span class="function"><span class="params">-		__reg_bound_offset32(true_reg);</span></span></span><br><span class="line"><span class="function"><span class="params">-	&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"> 	<span class="comment">/* Intersecting with the old var_off might have improved our bounds</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment"> 	 * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment"> 	 * then new var_off is (0; 0x7f...fc) which improves our umax.</span></span></span></span><br></pre></td></tr></table></figure>

<p>可以看到，作者只删除了<code>__reg_bound_offset32</code>这一函数便完成了漏洞的修补</p>
<p>为什么<code>__reg_bound_offset32</code>函数会导致漏洞呢？</p>
<p>如果将该函数patch掉，发现，在执行完第五句指令之后，<code>r0-&gt;var_off = {0x0, 0x1ffffffff}</code>，而不是patch前的<code>r0-&gt;var_off = {0x30303020, 0x10000001f}</code></p>
<p>正是由于这里<code>var_off</code>的偏差，如同导火索一般，导致在之后的ALU运算中，内核在调用<code>__update_reg_bounds</code>等函数来更新边界的过程中出现了偏差，导致检验系统的出错</p>
<p>另外，由于系统增加了<code>patch dead code</code>的操作，导致想要利用漏洞构造任意读写的难度大大增加</p>
<h1 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h1><h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><p>可以将内核中<code>debug info</code>打开，然后再编辑<code>.config</code>文件，开启所有带有<code>BPF</code>字样的配置</p>
<p>其中，<code>CONFIG_BPF_SYSCALL</code>必须打开，不然无法使用<code>bpf</code>系统调用</p>
<p>其他的配置中，某个配置没有打开会导致gdb调试的时候无法在相关函数下断点，而我并没有找是哪一个配置，索性就全部打开</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>主要调试的代码位于<code>kernel/bpf/verifier.c</code>中，可以根据源代码，利用<code>b kernel/bpf/verifier.c:行数</code>的方式下断点</p>
<p>另外，调试的时候Poc中最后一个跳转最好改变一下，比如从<code>JSGE</code>改为<code>JSLT</code>，使条件不成立，这样可以方便我们多次调试</p>
<h2 id="打印内核中载入的eBPF程序"><a href="#打印内核中载入的eBPF程序" class="headerlink" title="打印内核中载入的eBPF程序"></a>打印内核中载入的eBPF程序</h2><p>可以将内核源码复制到镜像中，然后在虚拟机中进入<code>tools/bpf/bpftool</code>目录下，执行<code>make</code>，编译出<code>bpftool</code></p>
<p>编译完成之后，有两条相关指令</p>
<p><code>./bpftool p s</code>会显示出内核中载入的<code>eBPF</code>程序的<code>id</code>等信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@syzkaller:~# ./bpftool p s</span><br><span class="line"><span class="number">5</span>: socket_filter  tag <span class="number">31b</span>ce63e92f471c4  gpl</span><br><span class="line">	loaded_at <span class="number">2020</span><span class="number">-04</span><span class="number">-17</span>T03:<span class="number">31</span>:<span class="number">44</span>+<span class="number">0000</span>  uid <span class="number">1000</span></span><br><span class="line">	xlated <span class="number">88B</span>  jited <span class="number">89B</span>  memlock <span class="number">4096B</span></span><br></pre></td></tr></table></figure>

<p><code>./bpftool p d x i id</code>可以打印出具体的<code>eBPF</code>程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@syzkaller:~# ./bpftool p d x i <span class="number">5</span></span><br><span class="line">   <span class="number">0</span>: (b7) r0 = <span class="number">808464432</span></span><br><span class="line">   <span class="number">1</span>: (<span class="number">7f</span>) r0 &gt;&gt;= r0</span><br><span class="line">   <span class="number">2</span>: (<span class="number">14</span>) w0 -= <span class="number">808464432</span></span><br><span class="line">   <span class="number">3</span>: (<span class="number">07</span>) r0 += <span class="number">808464432</span></span><br><span class="line">   <span class="number">4</span>: (b7) r1 = <span class="number">808464432</span></span><br><span class="line">   <span class="number">5</span>: (de) <span class="keyword">if</span> w1 s&lt;= w0 <span class="keyword">goto</span> pc+<span class="number">0</span></span><br><span class="line">   <span class="number">6</span>: (<span class="number">07</span>) r0 += <span class="number">-2144337872</span></span><br><span class="line">   <span class="number">7</span>: (<span class="number">14</span>) w0 -= <span class="number">-1607454672</span></span><br><span class="line">   <span class="number">8</span>: (<span class="number">76</span>) <span class="keyword">if</span> w0 s&gt;= <span class="number">0x303030</span> <span class="keyword">goto</span> pc+<span class="number">1</span></span><br><span class="line">   <span class="number">9</span>: (<span class="number">05</span>) <span class="keyword">goto</span> pc<span class="number">-1</span></span><br><span class="line">  <span class="number">10</span>: (<span class="number">95</span>) <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>[1] <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f2d67fec0b43edce8c416101cdc52e71145b5fef" target="_blank" rel="noopener">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f2d67fec0b43edce8c416101cdc52e71145b5fef</a></p>
<p>[2] <a href="https://elixir.bootlin.com/linux/v5.6-rc5/source/kernel/bpf/verifier.c#L9984" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.6-rc5/source/kernel/bpf/verifier.c#L9984</a></p>
<p>[3] <a href="https://github.com/DayJun/Blogs/blob/master/Articles/CVES/CVE-2020-8835/poc.c" target="_blank" rel="noopener">https://github.com/DayJun/Blogs/blob/master/Articles/CVES/CVE-2020-8835/poc.c</a></p>
<p>[4] <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-641cd7b06c911c5935c34f24850ea18690649917.tar.gz" target="_blank" rel="noopener">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-641cd7b06c911c5935c34f24850ea18690649917.tar.gz</a></p>

        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-04-21T03:30:12.997Z" itemprop="dateUpdated">2020-04-21 11:30:12</time>
</span><br>


        
        转载注明出处，原文地址：<a href="/2020/04/21/CVE-2020-8835-Linux-eBPF模块verifier组件漏洞分析/" target="_blank" rel="external">http://dayjun.top/2020/04/21/CVE-2020-8835-Linux-eBPF模块verifier组件漏洞分析/</a>
        
    </div>
    <footer>
        <a href="http://dayjun.top">
            <img src="/img/girl.jpg" alt="DaJun">
            DaJun
        </a>
    </footer>
</blockquote>

        
        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/">Kernel</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://dayjun.top/2020/04/21/CVE-2020-8835-Linux-eBPF模块verifier组件漏洞分析/&title=《CVE-2020-8835: Linux eBPF模块verifier组件漏洞分析》 — DaJun的Blog&pic=http://dayjun.top/img/girl.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://dayjun.top/2020/04/21/CVE-2020-8835-Linux-eBPF模块verifier组件漏洞分析/&title=《CVE-2020-8835: Linux eBPF模块verifier组件漏洞分析》 — DaJun的Blog&source=首发自安全客：https://www.anquanke.com/post/id/203284" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            
    <div id="comment"></div>



        
    </div>
    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="next">
      <a href="/2020/04/12/初步了解Linux内核BPF模块/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">初步了解Linux内核eBPF程序，以及资料参考</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#eBPF简介"><span class="post-toc-number">1.</span> <span class="post-toc-text">eBPF简介</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#eBPF程序的载入"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">eBPF程序的载入</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#bpf-insn"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">bpf_insn</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#bpf-prog-load"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">bpf_prog_load</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#load-prog"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">load_prog</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#漏洞分析"><span class="post-toc-number">2.</span> <span class="post-toc-text">漏洞分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#bpf-check"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">bpf_check</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#check-cfg"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">check_cfg</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#do-check-main"><span class="post-toc-number">2.1.2.</span> <span class="post-toc-text">do_check_main</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Poc分析"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">Poc分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#0-b7-r0-808464432"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">0: (b7) r0 = 808464432</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-7f-r0-gt-gt-r0"><span class="post-toc-number">2.2.2.</span> <span class="post-toc-text">1: (7f) r0 &gt;&gt;= r0</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-14-w0-808464432"><span class="post-toc-number">2.2.3.</span> <span class="post-toc-text">2: (14) w0 -= 808464432</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-de-if-w1-s-lt-w0-goto-pc-0"><span class="post-toc-number">2.2.4.</span> <span class="post-toc-text">5: (de) if w1 s&lt;= w0 goto pc+0</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-07-r0-2144337872"><span class="post-toc-number">2.2.5.</span> <span class="post-toc-text">6: (07) r0 += -2144337872</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-14-w0-1607454672"><span class="post-toc-number">2.2.6.</span> <span class="post-toc-text">7: (14) w0 -= -1607454672</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-76-if-w0-s-gt-0x303030-goto-pc-2"><span class="post-toc-number">2.2.7.</span> <span class="post-toc-text">9: (76) if w0 s&gt;= 0x303030 goto pc+2</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#深入思考"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">深入思考</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#调试技巧"><span class="post-toc-number">3.</span> <span class="post-toc-text">调试技巧</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#编译选项"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">编译选项</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#调试"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">调试</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#打印内核中载入的eBPF程序"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">打印内核中载入的eBPF程序</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#链接"><span class="post-toc-number">4.</span> <span class="post-toc-text">链接</span></a></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    
</article>


</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://3nd.xyz/" target="_blank">3ND</a>
    </span>
    
    <span class="blogroll-item">
        <a href="http://blog.douluodalu.wang/" target="_blank">PwmHt</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
        <p>
            <span>
                DaJun &copy; 2019 - 2020
            </span>
        		
           	
           	<span>
           		<a href="http://www.beian.miit.gov.cn" target="_blank">苏ICP备19059861号</a>
           	</span>
           	
            
            
            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            
            
            

            
                
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

            
        </p>
    </div>
</footer>

    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://dayjun.top/2020/04/21/CVE-2020-8835-Linux-eBPF模块verifier组件漏洞分析/&title=《CVE-2020-8835: Linux eBPF模块verifier组件漏洞分析》 — DaJun的Blog&pic=http://dayjun.top/img/girl.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://dayjun.top/2020/04/21/CVE-2020-8835-Linux-eBPF模块verifier组件漏洞分析/&title=《CVE-2020-8835: Linux eBPF模块verifier组件漏洞分析》 — DaJun的Blog&source=首发自安全客：https://www.anquanke.com/post/id/203284" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADNUlEQVR42u3aQXLjMAwEQP//095rDpE9AypbEtU6pVwOxWYOEwB8veLn/eM5+jz5ztHK7SfJyic82NjY2Ddhvz8++dY/b/dotc/vylfILdjY2Ni7sj9HSx4VeVAlB5QE2+x3sbGxsbFzUgLLAWcdGTY2NvaT2XlZMis2kkIo+RkbGxv7aexko+0r29bPZ2Teujq5l4aNjY19efbKv/tX+/lP5tvY2NjYF2a/F54kWtrrNbPV6p1jY2Njb8TOW/N54yZvBq0fSnslCBsbG/s57JaxEjztHk67ToSNjY29Bbtt6M+oydi1PY5Z+A1fj42NjX0Tdt2UKUuR5EBXCpvPIXcYYNjY2NgbsZOhad5+ykNoNrLND/FwKoKNjY29Ebttu+ct+7wI+bv21i/7x8bGxt6Unbdp8ks8SVCtBFheohwGGDY2NvbN2W3jPl80j5PZFZ/Zbl9nLYSNjY19SfZZDaMZY1bMtOXTLytjY2Nj35w9e03bJFqJw/aqUFQaYWNjY2/EPqvdM2sq5UPlc1tX2NjY2Huzk8ZN3k5qr+zMgjMfb/yS3tjY2NhbsPMyo/1+3mxaj8NhAGNjY2PfnL3S7p81m/IYm5Ui0RuxsbGxN2UnC9UvCA43afTPmlDRoBcbGxv7AexZ2ZDEz0oUtdeA6gDDxsbGvgl7vZ2UFyezUKwx2NjY2I9krxcYeRDOYm821h3+AbCxsbFvyF4Z2a4UNivXNBP8l3dhY2Njb8FuG+55Bq60gdZX/hKE2NjY2Bux25BoIyTZaFKo5I2t4r3Y2NjYW7DzRVtAOzBYXzMZWrzas8TGxsa+PLstDNrW/FnHMYu0LweKjY2NvQW7LRLywiMfCbdT6LbUwcbGxt6bvTI0zfErw93kXXn4Dc8PGxsb+8Lsd/m01Lyh3x59UuQc/hY2Njb2Ruz8yUOoPY7/U3gM8djY2Ng3YbdNn9nYdXaIefjln2NjY2Pvyk5Gp7OoSAYM68dUD4mxsbGxH8nOL9m0BUbyzYRdNJWwsbGxH8meXdA5a9NtsH05XGxsbOzt2PlwdwY4d2CQD5UPP8fGxsbeiH1uSZAcRzt4mJHy48DGxsa+LfsfjNZY3J0eJ/0AAAAASUVORK5CYII=" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.4.4"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.js"></script>

<script type="text/javascript" src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/blog.js?v=1.4.4"></script>

<!-- third-party -->






<script type="text/javascript" src="/js/plugins/local_search.js?v=1.4.4"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    
        <script type="text/javascript" src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script type="text/javascript" src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script type="text/javascript" src="/js/plugins/valine.js?v=1.4.4"></script>
    
    



<script type="text/javascript" src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
<script type="text/javascript" src="/js/plugins/leancloud_visitors.js?v=1.4.4"></script>



    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>




    <script>
    (function() {
        var OriginTitile = document.title, titleTime;
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                document.title = '(～﹃～)~zZ';
                clearTimeout(titleTime);
            } else {
                document.title = '(￣▽￣)';
                titleTime = setTimeout(function() {
                    document.title = OriginTitile;
                },2000);
            }
        });
    })();
</script>





    
</body>
</html>
